---
title:  回溯法求解幂集    
date: 2019-11-29
author: SinclairWang
# img: 
top: false # 是否推荐
cover: false # 是否轮播
# password: 
toc: false
mathjax: false
# img: /source/images/xxx.jpg
tags:
    - 回溯法
    - 幂集问题
categories:
	- 数据结构与算法训练
---

## 回溯--使用解向量
使用一个大小为n的数组x，来标记解向量，在每次迭代过程重要要么选择当前值，要么不选择
```cpp
#include<bits/stdc++.h>
using namespace std;

void print(int a[], int x[], int n){
	cout << "{";
	for(int i=0;i<n;i++){
		if(x[i]) printf("%d ",a[i]);
	}
	cout << "}" << endl;
	cout << endl;
}
void dfs(int a[], int x[], int n, int i){
	if(i>=n) {
		print(a,x,n);return ;
	}
	else{
		x[i] = 0; dfs(a,x,n,i+1);
		x[i] = 1; dfs(a,x,n,i+1);
	}
}
int main(){
	int n;
	cin >> n;
	int a[n];
	for(int i=0;i<n;i++)
		cin >> a[i];
	int x[n];
	memset(x,0,sizeof(x));
	dfs(a,x,n,0);
	return 0;
}
```

## 回溯法--使用容器存放结果
不去采用标准的解向量，而是用一个边长数组vector去存放解。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,m,n) for(int i=m;i<n;i++)
#define pb push_back

int res = 0;
void print(vector<int> v){
	rep(i,0,v.size()){
		cout << v[i] << " ";
	}
	cout << endl;
}
void dfs(int a[], int n, int i, vector<int> path){
	if(i>=n){
		print(path);
		res++; // 统计个数 
		return ;
	}
	else {
		dfs(a,n,i+1,path);
		path.pb(a[i]);
		dfs(a,n,i+1,path);
	}
}
int main(){
	int n;
	cin >> n;
	int a[n];
	rep(i,0,n)
		cin >> a[i];
	vector<int> path;
	dfs(a,n,0,path);
	cout << "Total : " << res << endl; 
	return 0;
}
```
## 枚举法--使用二进位对应解空间
用二进制位来对应解

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,m,n) for(int i=m;i<n;i++)
#define pb push_back

int res = 0;
void print(int a[],int n,int x){
	int j = 0; // 也可令j变为n,只是会调整输出顺序 
	cout << "{";
	while(x){
		if(x&1) {
			cout << a[j];
			if(x>=2) cout << " "; // 输出格式控制 
		}
		x >>= 1;j++;
	}
	cout << "}";
	cout << endl;
	res++;
}

int main(){
	int n;
	cin >> n;
	int a[n];
	rep(i,0,n)
		cin >> a[i];
	rep(i,0,1<<n){
		print(a,n,i);
	}
	cout << "Total：" << res ; 
}
```

