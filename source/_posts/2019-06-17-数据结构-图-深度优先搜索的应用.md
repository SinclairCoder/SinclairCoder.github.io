---
title:      数据结构-图-深度优先搜索的应用
date:       2019-06-17
tags:
	- 数据结构与算法训练
	- 图算法

categories:
	- 数据结构与算法训练
---

@[toc]
之前还写过一篇关于DFS的题解入门学习文章，详情见[DFS入门学习](https://blog.csdn.net/SinclairWang/article/details/90346900)
# 深度优先搜索的应用

## 头文件声明
即图的基本运算，详情见[数据结构-图-基本运算](https://blog.csdn.net/SinclairWang/article/details/92407493)

```c
#include"Graph.cpp"
```
## 顶点u到顶点v是否有简单路径

<!-- more -->
```c
/*
 顶点u到顶点v是否有简单路径，has表示是否存在 
 典型的DFS 
*/
void ExistPath(AdjGraph *G,int u, int v, bool &has)
{
	int w;
	ArcNode *p;
	visited[u] = 1; 
	if(u == v)  // 出口 
	{
		has = true;
		return ;
	}
	p = G->adjlist[u].firstarc;
	while(p!=NULL)
	{
		w = p->adjvex;
		if(visited[w] == 0)
			ExistPath(G,w,v,has);
		p = p->nextarc; 
	}
}
```

## 输出图G中从定点u到v的一条简单路径

```c
/*
	输出图G中从定点u到v的一条简单路径
	典型的DFS 
*/ 
void FindPath(AdjGraph *G, int u, int v,int path[], int d)
{
	// d 为路径长度 初始为-1
	int w;
	ArcNode *p;
	visited[u] = 1;
	d++;
	path[d] = u; 
	if(u==v)  // 出口 
	{
		for(int i=0;i<=d;i++)
			printf("%2d",path[i]);	
		cout << endl;
		return ; 
	}	
	p = G->adjlist[u].firstarc;
	while(p!=NULL)
	{
		w = p->adjvex;
		if(visited[w]==0)
			FindPath(G,w,v,path,d);
		p = p->nextarc; 
	} 
}
```

## 输出图G中从定点u到v的所有简单路径

```c
/*
	输出图G中从定点u到v的所有简单路径
	典型的DFS 需要额外写一个恢复 
*/ 
void FindAllPath(AdjGraph *G, int u, int v,int path[], int d)
{
	int w;
	ArcNode *p;
	visited[u] = 1;
	d++;
	path[d] = u;
	if(u == v && d>=0) // 出口 
	{
		for(int i=0;i<=d;i++)
			printf("%2d",path[i]);
		cout << endl;	
	} 
	p = G->adjlist[u].firstarc;
	while(p!=NULL)
	{
		w = p->adjvex;
		if(visited[w]==0)
			FindAllPath(G,w,v,path,d);
		p = p->nextarc;
	}
	visited[u] = 0; // 恢复，该顶点可重复使用 
} 
```

## 求图G中所有从顶点u到v的长度为l的简单路径

```c
/*
	求图G中所有从顶点u到v的长度为l的简单路径
	典型DFS 
*/
void  PathlenAll(AdjGraph *G, int u, int v, int l, int path[], int d)
{
	int w;
	ArcNode *p;
	visited[u] = 1;
	d++;
	path[d] = u;
	if(u == v&& d==l)
	{
		printf(" ");
		for(int i=0;i<=d;i++)
			printf("%2d",path[i]);
		cout << endl;
	}
	p = G->adjlist[u].firstarc;
	while(p!=NULL)
	{
	 	w = p->adjvex;
		if(visited[w]==0)
			PathlenAll(G,w,v,l,path,d);
		p = p->nextarc;	
	}
	visited[u] = 0;  // 恢复 
} 
```

## 主函数测试

```c
int main()
{
	int path[MAXV];
	int u=1,v=4,l=3;
	int n=5,e =8;
	int A[MAXV][MAXV]={{0,1,0,1,1},{1,0,1,1,0},{0,1,0,1,1},{1,1,1,0,1},{1,0,1,1,0}};
	
	AdjGraph *G;
	CreateAdj(G,A,n,e);
	for(int i=0;i<n;i++)
		visited[i] = 0;
	cout << "图G的邻接表：";
	DispAdj(G);
	cout << "顶点1到4之间是否有简单路径：";
	bool has;
	ExistPath(G,1,4,has);
	cout << has << endl;
	memset(visited,0,sizeof(visited));
	cout << "输出一条顶点1到4之间的简单路径：";
	FindPath(G,1,4,path,-1);
	cout << endl;
	memset(visited,0,sizeof(visited));
	cout << "输出所有顶点1到4之间的简单路径：" << endl;
	memset(path,-1,sizeof(path));
	FindAllPath(G,1,4,path,-1); 
	cout << "输出所有顶点1到4之间长度为4的简单路径：" << endl;
	memset(visited,0,sizeof(visited));
	memset(path,-1,sizeof(path));
	PathlenAll(G,1,4,4,path,-1);
	cout << "输出所有顶点1到4之间长度为3的简单路径：" << endl;
	memset(visited,0,sizeof(visited));
	memset(path,-1,sizeof(path));
	PathlenAll(G,1,4,3,path,-1);
	return 0;
 } 
```


## 结果
![DFS应用](https://img-blog.csdnimg.cn/20190617001056832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NpbmNsYWlyV2FuZw==,size_16,color_FFFFFF,t_70)


写于2019/6/17 00:37  坚持很酷~
