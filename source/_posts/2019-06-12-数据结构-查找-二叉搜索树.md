---
title: 数据结构-查找-二叉搜索树
date: 2019-06-12
tags:
	- 数据结构与算法训练
	- 图算法
categories:
	- 数据结构与算法训练
---


**二叉排序树**（Binary Search Tree ，BST）又称**二叉排序树**，其定义为二叉排序树，或空树，或者是满足以下性质的二叉树：
>1.若根节点的左子树非空，则左子树上所有节点关键字小于根节点关键字；
2.若根节点的右子树非空，则右子树上所有节点关键字大于根节点关键字；
3.根节点的左右子树本身又是一棵二叉排序树。

即在二叉树的基础上添加了结点值的约束。

以下是二叉搜索树的实现。
<!-- more -->
```java
/*
	@author:Sinclair
	@time:2019-06-12
	Binary Search Tree
	数据结构之二叉搜索（排序）树 
*/
typedef int KeyType;
typedef struct tree{
	KeyType key;
	// other
	struct tree *lchild,*rchild;
}BST;
// 插入关键字为k的结点 
bool Insert(BST *&bt, KeyType k)
{
	if(bt==NULL)
	{
		bt = (BST *)malloc(sizeof(BST));
		bt->key = k;
		bt->lchild = bt->rchild = NULL;
		return true; 
	}
	else if(k == bt->key){
		return false;
	}
	else if(k < bt->key){
		return Insert(bt->lchild,k);
	}
	else{
		return Insert(bt->rchild,k);
	}
}
// 创建二叉排序树 
BST* Create(KeyType A[],int n)
{
	BST *bt = NULL;
	int i=0;
	while(i<n)
	{
		Insert(bt,A[i]);
		i++;
	} 
	return bt;
}

// 查找关键字为k的结点 返回地址 
BST* Search(BST *bt, KeyType k)
{
	if(bt == NULL || bt->key == k)
	{
		return bt;
	}
	if(k<bt->key){
		return Search(bt->lchild, k);
	}
	else{
		return Search(bt->rchild,k);
	}
}

// 查找关键字为k的结点并且还要查找其双亲结点

BST* SearchParents(BST *bt,KeyType k,BST *temp, BST *&father)
{
	if(bt == NULL)
	{
		father = NULL;
		return bt;
	}
	else if(bt->key == k)
	{
		father = temp;
		return bt;
	}
	if(k<bt->key){
		return SearchParents(bt->lchild,k,bt,father);
	}
	else{
		return SearchParents(bt->rchild, k, bt, father);
	}
}
// 找出树中k最大的和最小的结点
KeyType FindMaxNode( BST *p)
{
	while(p->rchild !=NULL){
		p = p->rchild;
	}
	return p->key;
} 

KeyType FindMinNode( BST *p)
{
	while(p->lchild !=NULL){
		p = p->rchild;
	}
	return p->key;
} 
void FindMaxMinNode(BST *p)
{
	if(p!=NULL)
	{
		if(p->lchild !=NULL)
			printf("左子树的最大结点为:%d\n",FindMaxNode(p->lchild));
		if(p->rchild !=NULL)
			printf("右子树的最大结点为:%d\n",FindMinNode(p->rchild));
	}
}


void Delete1(BST *p,BST *& r)
{
	BST *q;
	if(r->rchild!=NULL){
		Delete1(p,p->rchild);
	}
	else{
		p->key = r->key;
		q = r;
		r = r->lchild;
		free(q);
	}	
} 
// 删除树中关键字为k的结点 
void Delete(BST *&bt, KeyType k)
{
	BST *p = Search(bt,k); 
	BST *q;
	if(p->rchild==NULL) // 右子树为空，左子树结点代替 
	{
		q = p;
		p = p->lchild;
		free(q);	
	}
	else if(p->lchild ==NULL){ // 左子树为空，右子树结点代替 
		q = p;
		p = p->rchild;
		free(q);
	}
	else Delete1(p, p->lchild);	 // 结点p既有左子树又有右子树 
} 

void DisplayBST(BST* bt)
{
	if(bt != NULL)
	{
		cout << bt->key;
		if(bt->lchild != NULL ||bt->rchild !=NULL)
		{
			cout << "(";
			DisplayBST(bt->lchild);
			if(bt->rchild != NULL){
				cout << ",";
			}
			DisplayBST(bt->rchild);
			cout << ")";
		}
	}
}

```

## 测试下

```java
int main()
{
	KeyType a[] ={25,18,46,2,53,39,32,4,74,67,60,11};
	BST *bt;
	bt = Create(a,12);
	FindMaxMinNode(bt);
	DisplayBST(bt);
	cout << endl;
	cout << "删除关键字为25的节点后树形结构如下：" << endl;
	Delete(bt,25);
	DisplayBST(bt); 
	cout << endl;
	return 0; 
}
```

## 结果截图

![BST](https://img-blog.csdnimg.cn/20190612231234830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NpbmNsYWlyV2FuZw==,size_5,color_FFFFFF,t_70)

注：其实一直想将树可视化一下，暂时还没实现出来，先占个坑，稍后补上。
