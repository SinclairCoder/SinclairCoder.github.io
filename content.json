{"meta":{"title":"SinclairWangのBlog","subtitle":null,"description":"嚼的草根 做得大事","author":"Sinclair Wang","url":"https://sinclaircoder.top","root":"/"},"pages":[{"title":"about","date":"2019-08-03T00:33:24.000Z","updated":"2019-08-03T08:11:39.534Z","comments":true,"path":"about/index.html","permalink":"https://sinclaircoder.top/about/index.html","excerpt":"","text":"个人简介 00后学生党一枚 完美主义者，强迫症中期患者… 喜欢吃鱼，偶尔摸鱼，讨厌咸鱼 过于真实了 教育经历17级WIT本科SE在读 技术栈啊，好像啥也不会 目前在学 JavaWeb ML 关于本站本站建于2019年8月1日，托管与Github Pages，用于积累技术、记录生活等。 Powered by: Hexo: 基础博客框架 Next: 基于 Hexo 的博客主题 Tidio: 在线聊天通信 LeanCloud: 数据云存储与后端支持 Valine: 文章评论组件 Busuanzi 数据统计分析 Algolia 站内搜索服务 Baidu Analytics: 网站监测与数据分析 Google Analytics: 网站监测与数据分析 足足配置两天"},{"title":"tags","date":"2019-08-02T15:38:10.000Z","updated":"2019-08-02T15:40:04.106Z","comments":false,"path":"tags/index.html","permalink":"https://sinclaircoder.top/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-02T15:40:46.000Z","updated":"2019-08-02T15:41:38.842Z","comments":false,"path":"categories/index.html","permalink":"https://sinclaircoder.top/categories/index.html","excerpt":"","text":""},{"title":"top","date":"2019-08-03T07:03:32.000Z","updated":"2019-08-03T07:03:32.875Z","comments":true,"path":"top/index.html","permalink":"https://sinclaircoder.top/top/index.html","excerpt":"","text":""}],"posts":[{"title":"Tomcat 8080端口被占用","slug":"2019-07-14-Tomcat 8080端口被占用","date":"2019-07-13T16:00:00.000Z","updated":"2019-08-03T06:09:12.978Z","comments":true,"path":"2019/07/14/2019-07-14-Tomcat 8080端口被占用/","link":"","permalink":"https://sinclaircoder.top/2019/07/14/2019-07-14-Tomcat 8080端口被占用/","excerpt":"最近在学习Spring Boot ，新建项目运行的时候出现了Tomcat 8080端口被占用的问题","text":"最近在学习Spring Boot ，新建项目运行的时候出现了Tomcat 8080端口被占用的问题 描述如下： 解决方法1.管理员身份打开cmd窗口2.使用命令 netstat -ano 查看当前端口信息 3.找到对应端口PID ，输入指令找到对应进程杀掉 4.重新运行程序","categories":[],"tags":[{"name":"工程项目","slug":"工程项目","permalink":"https://sinclaircoder.top/tags/工程项目/"},{"name":"javaWeb","slug":"javaWeb","permalink":"https://sinclaircoder.top/tags/javaWeb/"}]},{"title":"一线爬虫爬虫工程师纪实","slug":"2019-07-14-一线爬虫工程师纪实","date":"2019-07-13T16:00:00.000Z","updated":"2019-08-02T15:31:39.845Z","comments":true,"path":"2019/07/14/2019-07-14-一线爬虫工程师纪实/","link":"","permalink":"https://sinclaircoder.top/2019/07/14/2019-07-14-一线爬虫工程师纪实/","excerpt":"最近遇到了反爬虫","text":"最近遇到了反爬虫 在CSDN上逛到了一篇很不错的博文Java 那些你不知道的爬虫反爬虫套路 一篇一线爬虫工程师的纪实~ ==注：侵删==","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://sinclaircoder.top/tags/爬虫/"}]},{"title":"JavaScript的prototype属性","slug":"2019-06-24-JavaScript的prototype属性","date":"2019-06-23T16:00:00.000Z","updated":"2019-08-03T06:08:54.546Z","comments":true,"path":"2019/06/24/2019-06-24-JavaScript的prototype属性/","link":"","permalink":"https://sinclaircoder.top/2019/06/24/2019-06-24-JavaScript的prototype属性/","excerpt":"今天写js代码的时候，看别的用prototype看的我云里雾里的，了解了一下： prototype 是函数的属性，它的本质是函数的原型对象 可以以此执行一下如下代码，体会一下。","text":"今天写js代码的时候，看别的用prototype看的我云里雾里的，了解了一下： prototype 是函数的属性，它的本质是函数的原型对象 可以以此执行一下如下代码，体会一下。 1234567&lt;script&gt;var ob = &#123; &#125;;//超级简单的空对象alert(JSON.stringify(ob.prototype));function func()&#123;&#125;alert(func.prototype);&lt;/script&gt; 12345&lt;script&gt;function func()&#123; &#125;alert(JSON.stringify(func.prototype));&lt;/script&gt; 123456&lt;script&gt; function func()&#123;&#125;func.prototype.name ='prototype是函数的的属性，本质是函数的原型对象';alert(JSON.stringify(func.prototype))&lt;/script&gt; 1234567891011121314&lt;script&gt;function func()&#123;&#125;//给函数的属性prototype赋予一个方法getfunc.prototype.get=function(value)&#123; return value;&#125;var ob1 = new func;//用func实例化出来的对象来调用get属性函数alert(ob1.get('hello,prototype原型对象'));var ob2 = new func;//用func实例化出来的对象来调用get属性方法alert(ob2.get('我依然是func实例化出来的对象'));&lt;/script&gt; 详情请见==&gt;简单理解js的prototype属性","categories":[{"name":"前端","slug":"前端","permalink":"https://sinclaircoder.top/categories/前端/"},{"name":"javascript","slug":"前端/javascript","permalink":"https://sinclaircoder.top/categories/前端/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sinclaircoder.top/tags/javascript/"}]},{"title":"数据结构-图-深度优先搜索的应用","slug":"2019-06-17-数据结构-图-深度优先搜索的应用","date":"2019-06-16T16:00:00.000Z","updated":"2019-08-03T06:08:33.574Z","comments":true,"path":"2019/06/17/2019-06-17-数据结构-图-深度优先搜索的应用/","link":"","permalink":"https://sinclaircoder.top/2019/06/17/2019-06-17-数据结构-图-深度优先搜索的应用/","excerpt":"@[toc]之前还写过一篇关于DFS的题解入门学习文章，详情见DFS入门学习 深度优先搜索的应用头文件声明即图的基本运算，详情见数据结构-图-基本运算 1#include\"Graph.cpp\" 顶点u到顶点v是否有简单路径","text":"@[toc]之前还写过一篇关于DFS的题解入门学习文章，详情见DFS入门学习 深度优先搜索的应用头文件声明即图的基本运算，详情见数据结构-图-基本运算 1#include\"Graph.cpp\" 顶点u到顶点v是否有简单路径 1234567891011121314151617181920212223/* 顶点u到顶点v是否有简单路径，has表示是否存在 典型的DFS */void ExistPath(AdjGraph *G,int u, int v, bool &amp;has)&#123; int w; ArcNode *p; visited[u] = 1; if(u == v) // 出口 &#123; has = true; return ; &#125; p = G-&gt;adjlist[u].firstarc; while(p!=NULL) &#123; w = p-&gt;adjvex; if(visited[w] == 0) ExistPath(G,w,v,has); p = p-&gt;nextarc; &#125;&#125; 输出图G中从定点u到v的一条简单路径12345678910111213141516171819202122232425262728/* 输出图G中从定点u到v的一条简单路径 典型的DFS */ void FindPath(AdjGraph *G, int u, int v,int path[], int d)&#123; // d 为路径长度 初始为-1 int w; ArcNode *p; visited[u] = 1; d++; path[d] = u; if(u==v) // 出口 &#123; for(int i=0;i&lt;=d;i++) printf(\"%2d\",path[i]); cout &lt;&lt; endl; return ; &#125; p = G-&gt;adjlist[u].firstarc; while(p!=NULL) &#123; w = p-&gt;adjvex; if(visited[w]==0) FindPath(G,w,v,path,d); p = p-&gt;nextarc; &#125; &#125; 输出图G中从定点u到v的所有简单路径123456789101112131415161718192021222324252627/* 输出图G中从定点u到v的所有简单路径 典型的DFS 需要额外写一个恢复 */ void FindAllPath(AdjGraph *G, int u, int v,int path[], int d)&#123; int w; ArcNode *p; visited[u] = 1; d++; path[d] = u; if(u == v &amp;&amp; d&gt;=0) // 出口 &#123; for(int i=0;i&lt;=d;i++) printf(\"%2d\",path[i]); cout &lt;&lt; endl; &#125; p = G-&gt;adjlist[u].firstarc; while(p!=NULL) &#123; w = p-&gt;adjvex; if(visited[w]==0) FindAllPath(G,w,v,path,d); p = p-&gt;nextarc; &#125; visited[u] = 0; // 恢复，该顶点可重复使用 &#125; 求图G中所有从顶点u到v的长度为l的简单路径12345678910111213141516171819202122232425262728/* 求图G中所有从顶点u到v的长度为l的简单路径 典型DFS */void PathlenAll(AdjGraph *G, int u, int v, int l, int path[], int d)&#123; int w; ArcNode *p; visited[u] = 1; d++; path[d] = u; if(u == v&amp;&amp; d==l) &#123; printf(\" \"); for(int i=0;i&lt;=d;i++) printf(\"%2d\",path[i]); cout &lt;&lt; endl; &#125; p = G-&gt;adjlist[u].firstarc; while(p!=NULL) &#123; w = p-&gt;adjvex; if(visited[w]==0) PathlenAll(G,w,v,l,path,d); p = p-&gt;nextarc; &#125; visited[u] = 0; // 恢复 &#125; 主函数测试1234567891011121314151617181920212223242526272829303132333435int main()&#123; int path[MAXV]; int u=1,v=4,l=3; int n=5,e =8; int A[MAXV][MAXV]=&#123;&#123;0,1,0,1,1&#125;,&#123;1,0,1,1,0&#125;,&#123;0,1,0,1,1&#125;,&#123;1,1,1,0,1&#125;,&#123;1,0,1,1,0&#125;&#125;; AdjGraph *G; CreateAdj(G,A,n,e); for(int i=0;i&lt;n;i++) visited[i] = 0; cout &lt;&lt; \"图G的邻接表：\"; DispAdj(G); cout &lt;&lt; \"顶点1到4之间是否有简单路径：\"; bool has; ExistPath(G,1,4,has); cout &lt;&lt; has &lt;&lt; endl; memset(visited,0,sizeof(visited)); cout &lt;&lt; \"输出一条顶点1到4之间的简单路径：\"; FindPath(G,1,4,path,-1); cout &lt;&lt; endl; memset(visited,0,sizeof(visited)); cout &lt;&lt; \"输出所有顶点1到4之间的简单路径：\" &lt;&lt; endl; memset(path,-1,sizeof(path)); FindAllPath(G,1,4,path,-1); cout &lt;&lt; \"输出所有顶点1到4之间长度为4的简单路径：\" &lt;&lt; endl; memset(visited,0,sizeof(visited)); memset(path,-1,sizeof(path)); PathlenAll(G,1,4,4,path,-1); cout &lt;&lt; \"输出所有顶点1到4之间长度为3的简单路径：\" &lt;&lt; endl; memset(visited,0,sizeof(visited)); memset(path,-1,sizeof(path)); PathlenAll(G,1,4,3,path,-1); return 0; &#125; 结果 写于2019/6/17 00:37 坚持很酷~","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"知识","slug":"数据结构与算法/知识","permalink":"https://sinclaircoder.top/categories/数据结构与算法/知识/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/tags/数据结构与算法/"}]},{"title":"数据结构-图-基本运算","slug":"2019-06-16-数据结构-图-基本运算","date":"2019-06-15T16:00:00.000Z","updated":"2019-08-03T06:08:18.375Z","comments":true,"path":"2019/06/16/2019-06-16-数据结构-图-基本运算/","link":"","permalink":"https://sinclaircoder.top/2019/06/16/2019-06-16-数据结构-图-基本运算/","excerpt":"@[TOC] 定义 图G由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有限集合，记为V(G), E是连接V中两个不同顶点（顶点对）的边的有限集合，记为E(G)","text":"@[TOC] 定义 图G由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有限集合，记为V(G), E是连接V中两个不同顶点（顶点对）的边的有限集合，记为E(G) 存储结构 邻接矩阵 邻接表 十字链表 邻接多重表 结构体定义12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;deque&gt;using namespace std;#define MAXV 100 #define INF 32767typedef struct &#123; int num; // 序号 int data;&#125;VertexType; // 顶点类型typedef struct &#123; int edges[MAXV][MAXV]; // 邻接矩阵数组 int n,e; // 顶点数，边数 VertexType vertex[MAXV]; // 顶点&#125;MatGraph;// 图的邻接表表示typedef struct ANode &#123; //边结点类型 int adjvex; //该边邻接点编号 struct ANode *nextarc; int weight;&#125;ArcNode; typedef struct Vnode&#123; // 头结点类型 VertexType data; // 顶点信息 int count; // 增加数据域：存放顶点入度 ArcNode *firstarc;&#125;VNode;typedef struct &#123; VNode adjlist[MAXV]; int n; int e;&#125;AdjGraph; // 用一个头节点数组构造的图 邻接表创建图12345678910111213141516171819202122// 用邻接表创建图 void CreateAdj(AdjGraph *&amp;G,int A[MAXV][MAXV], int n, int e)&#123; int i,j; ArcNode* p; G = (AdjGraph*)malloc(sizeof(AdjGraph)); for(i=0;i&lt;n;i++) G-&gt;adjlist[i].firstarc = NULL; for(i=0;i&lt;n;i++) for(j=n-1;j&gt;=0;j--) &#123; if(A[i][j] !=0&amp;&amp;A[i][j]!=INF) &#123; p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;weight = A[i][j]; p-&gt;nextarc = G-&gt;adjlist[i].firstarc; G-&gt;adjlist[i].firstarc = p; &#125; &#125; G-&gt;n = n , G-&gt;e = e;&#125; 输出图G1234567891011121314151617// 输出图Gvoid DispAdj(AdjGraph *G)&#123; int i; ArcNode *p; for(i=0;i&lt;G-&gt;n;i++) &#123; p = G-&gt;adjlist[i].firstarc; printf(\"%3d:\",i); while(p!=NULL) &#123; printf(\"%3d[%d]-&gt;\",p-&gt;adjvex,p-&gt;weight); p = p-&gt;nextarc; &#125; cout &lt;&lt; \"^\\n\"; &#125;&#125; 销毁图12345678910111213141516171819202122// 销毁图void DestroyAdj(AdjGraph *&amp;G)&#123; int i; ArcNode *pre, *p; for(i=0;i&lt;G-&gt;n;i++) &#123; pre = G-&gt;adjlist[i].firstarc; if(pre!=NULL) &#123; p = pre-&gt;nextarc; while(p!=NULL) &#123; free(pre); pre = p; p = p-&gt;nextarc; &#125; free(pre); &#125; &#125; free(G); &#125; 邻接矩阵与邻接表的相互转化1234567891011121314151617181920212223242526272829303132333435363738394041// 邻接矩阵转邻接表 复杂度：O(n^2) void MatToList(MatGraph g, AdjGraph *&amp;G)&#123; int i,j; ArcNode *p; G = (AdjGraph*)malloc(sizeof(AdjGraph)); for(i=0;i&lt;G-&gt;n;i++) G-&gt;adjlist[i].firstarc = NULL; for(i=0;i&lt;g.n;i++) for(j=g.n-1;j&gt;=0;j--) if(g.edges[i][j]!=0&amp;&amp;g.edges[i][j]!=INF) &#123; p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;weight = g.edges[i][j]; p-&gt;nextarc = G-&gt;adjlist[i].firstarc; G-&gt;adjlist[i].firstarc = p; &#125; G-&gt;n = g.n; G-&gt;e = g.e; &#125; // 邻接表转邻接矩阵 复杂度 O(n+e) void ListToMat(AdjGraph *G, MatGraph &amp;g)&#123; int i; ArcNode *p; for(i=0;i&lt;G-&gt;n;i++) &#123; p = G-&gt;adjlist[i].firstarc; while(p!=NULL) &#123; g.edges[i][p-&gt;adjvex] = p-&gt;weight; p = p-&gt;nextarc; &#125; &#125; g.n = G-&gt;n; g.e = G-&gt;e; &#125; 图的遍历深度优先搜索1234567891011121314151617181920212223int visited[MAXV]=&#123;0&#125;; // 深度优先搜索 DFS O(n+e) void DFS(AdjGraph *G,int v) // 遍历连通图&#123; ArcNode *p; visited[v] = 1; printf(\"%2d\",v); p = G-&gt;adjlist[v].firstarc; while(p!=NULL) &#123; if(visited[p-&gt;adjvex] == 0) DFS(G,p-&gt;adjvex); p = p-&gt;nextarc; &#125; &#125;void DFS1(AdjGraph *G) // 遍历非连通图&#123; for(int i=0;i&lt;G-&gt;n;i++) if(visited[i]==0) DFS(G,i); &#125; 广度优先搜索12345678910111213141516171819202122232425262728293031323334// 广度优先搜索 O(n^2)void BFS(AdjGraph *&amp;G, int v) // 遍历连通图 &#123; int w; ArcNode *p; int visited[MAXV] =&#123;0&#125;; visited[v] = 1; printf(\"%2d\",v); deque&lt;int&gt; de; de.push_back(v); while(!de.empty()) &#123; w = *de.begin(); de.pop_front(); p = G-&gt;adjlist[w].firstarc; while(p!=NULL)&#123; if(visited[p-&gt;adjvex] == 0) &#123; printf(\"%2d\",p-&gt;adjvex); visited[p-&gt;adjvex] = 1; de.push_back(p-&gt;adjvex); &#125; p = p-&gt;nextarc; &#125; &#125; cout &lt;&lt; endl;&#125; void BFS1(AdjGraph *G) // 遍历非连通图&#123; for(int i=0;i&lt;G-&gt;n;i++) if(visited[i]==0) BFS(G,i); &#125; 判断图是否连通12345678910111213141516bool Connect(AdjGraph *G)&#123; int i; bool flag = true; for(int i=0;i&lt;G-&gt;n;i++) visited[i] = 0; DFS(G,0); for(int i=0;i&lt;G-&gt;n;i++) if(visited[i]==0) &#123; flag = false; break; &#125; return flag; &#125; 主函数调用测试1234567891011121314151617181920212223242526int main()&#123; int A[MAXV][MAXV] = &#123; &#123;0,28,INF,INF,INF,10,INF&#125;, &#123;26,0,16,INF,INF,INF,14&#125;, &#123;INF,16,0,12,INF,INF,INF&#125;, &#123;INF,INF,12,0,22,INF,18&#125;, &#123;INF,INF,INF,22,0,25,24&#125;, &#123;10,INF,INF,INF,25,0,INF&#125;, &#123;INF,14,INF,18,24,INF,0&#125; &#125;; AdjGraph *G; int n = 7,e = 18; CreateAdj(G,A,n,e); DispAdj(G); cout &lt;&lt; \"广度优先搜索产生的序列为： \"; BFS(G,0); cout &lt;&lt; \"深度优先搜索产生的序列为： \"; DFS(G,0); cout &lt;&lt; endl; //cout &lt;&lt; \"图G是否连通： \"; //printf(\" %d\",Connect(G)); DestroyAdj(G); return 0; &#125; 结果 P.S：马上考试了，我还在写博客，但我觉得这才是正确的复习方式，hahahha太真实了…….","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/tags/数据结构与算法/"},{"name":"知识","slug":"知识","permalink":"https://sinclaircoder.top/tags/知识/"}]},{"title":"数据结构-查找-二叉搜索树","slug":"2019-06-12-数据结构-查找-二叉搜索树","date":"2019-06-11T16:00:00.000Z","updated":"2019-08-03T06:07:15.028Z","comments":true,"path":"2019/06/12/2019-06-12-数据结构-查找-二叉搜索树/","link":"","permalink":"https://sinclaircoder.top/2019/06/12/2019-06-12-数据结构-查找-二叉搜索树/","excerpt":"二叉排序树（Binary Search Tree ，BST）又称二叉排序树，其定义为二叉排序树，或空树，或者是满足以下性质的二叉树： 1.若根节点的左子树非空，则左子树上所有节点关键字小于根节点关键字；2.若根节点的右子树非空，则右子树上所有节点关键字大于根节点关键字；3.根节点的左右子树本身又是一棵二叉排序树。 即在二叉树的基础上添加了结点值的约束。 以下是二叉搜索树的实现。","text":"二叉排序树（Binary Search Tree ，BST）又称二叉排序树，其定义为二叉排序树，或空树，或者是满足以下性质的二叉树： 1.若根节点的左子树非空，则左子树上所有节点关键字小于根节点关键字；2.若根节点的右子树非空，则右子树上所有节点关键字大于根节点关键字；3.根节点的左右子树本身又是一棵二叉排序树。 即在二叉树的基础上添加了结点值的约束。 以下是二叉搜索树的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/* @author:Sinclair @time:2019-06-12 Binary Search Tree 数据结构之二叉搜索（排序）树 */typedef int KeyType;typedef struct tree&#123; KeyType key; // other struct tree *lchild,*rchild;&#125;BST;// 插入关键字为k的结点 bool Insert(BST *&amp;bt, KeyType k)&#123; if(bt==NULL) &#123; bt = (BST *)malloc(sizeof(BST)); bt-&gt;key = k; bt-&gt;lchild = bt-&gt;rchild = NULL; return true; &#125; else if(k == bt-&gt;key)&#123; return false; &#125; else if(k &lt; bt-&gt;key)&#123; return Insert(bt-&gt;lchild,k); &#125; else&#123; return Insert(bt-&gt;rchild,k); &#125;&#125;// 创建二叉排序树 BST* Create(KeyType A[],int n)&#123; BST *bt = NULL; int i=0; while(i&lt;n) &#123; Insert(bt,A[i]); i++; &#125; return bt;&#125;// 查找关键字为k的结点 返回地址 BST* Search(BST *bt, KeyType k)&#123; if(bt == NULL || bt-&gt;key == k) &#123; return bt; &#125; if(k&lt;bt-&gt;key)&#123; return Search(bt-&gt;lchild, k); &#125; else&#123; return Search(bt-&gt;rchild,k); &#125;&#125;// 查找关键字为k的结点并且还要查找其双亲结点BST* SearchParents(BST *bt,KeyType k,BST *temp, BST *&amp;father)&#123; if(bt == NULL) &#123; father = NULL; return bt; &#125; else if(bt-&gt;key == k) &#123; father = temp; return bt; &#125; if(k&lt;bt-&gt;key)&#123; return SearchParents(bt-&gt;lchild,k,bt,father); &#125; else&#123; return SearchParents(bt-&gt;rchild, k, bt, father); &#125;&#125;// 找出树中k最大的和最小的结点KeyType FindMaxNode( BST *p)&#123; while(p-&gt;rchild !=NULL)&#123; p = p-&gt;rchild; &#125; return p-&gt;key;&#125; KeyType FindMinNode( BST *p)&#123; while(p-&gt;lchild !=NULL)&#123; p = p-&gt;rchild; &#125; return p-&gt;key;&#125; void FindMaxMinNode(BST *p)&#123; if(p!=NULL) &#123; if(p-&gt;lchild !=NULL) printf(\"左子树的最大结点为:%d\\n\",FindMaxNode(p-&gt;lchild)); if(p-&gt;rchild !=NULL) printf(\"右子树的最大结点为:%d\\n\",FindMinNode(p-&gt;rchild)); &#125;&#125;void Delete1(BST *p,BST *&amp; r)&#123; BST *q; if(r-&gt;rchild!=NULL)&#123; Delete1(p,p-&gt;rchild); &#125; else&#123; p-&gt;key = r-&gt;key; q = r; r = r-&gt;lchild; free(q); &#125; &#125; // 删除树中关键字为k的结点 void Delete(BST *&amp;bt, KeyType k)&#123; BST *p = Search(bt,k); BST *q; if(p-&gt;rchild==NULL) // 右子树为空，左子树结点代替 &#123; q = p; p = p-&gt;lchild; free(q); &#125; else if(p-&gt;lchild ==NULL)&#123; // 左子树为空，右子树结点代替 q = p; p = p-&gt;rchild; free(q); &#125; else Delete1(p, p-&gt;lchild); // 结点p既有左子树又有右子树 &#125; void DisplayBST(BST* bt)&#123; if(bt != NULL) &#123; cout &lt;&lt; bt-&gt;key; if(bt-&gt;lchild != NULL ||bt-&gt;rchild !=NULL) &#123; cout &lt;&lt; \"(\"; DisplayBST(bt-&gt;lchild); if(bt-&gt;rchild != NULL)&#123; cout &lt;&lt; \",\"; &#125; DisplayBST(bt-&gt;rchild); cout &lt;&lt; \")\"; &#125; &#125;&#125; 测试下1234567891011121314int main()&#123; KeyType a[] =&#123;25,18,46,2,53,39,32,4,74,67,60,11&#125;; BST *bt; bt = Create(a,12); FindMaxMinNode(bt); DisplayBST(bt); cout &lt;&lt; endl; cout &lt;&lt; \"删除关键字为25的节点后树形结构如下：\" &lt;&lt; endl; Delete(bt,25); DisplayBST(bt); cout &lt;&lt; endl; return 0; &#125; 结果截图 注：其实一直想将树可视化一下，暂时还没实现出来，先占个坑，稍后补上。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"知识","slug":"数据结构与算法/知识","permalink":"https://sinclaircoder.top/categories/数据结构与算法/知识/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/tags/数据结构与算法/"}]},{"title":"2019第十届蓝桥杯CB组国赛心得","slug":"2019-05-28-2019第十届蓝桥杯CB组国赛心得","date":"2019-05-27T16:00:00.000Z","updated":"2019-08-03T06:47:30.588Z","comments":true,"path":"2019/05/28/2019-05-28-2019第十届蓝桥杯CB组国赛心得/","link":"","permalink":"https://sinclaircoder.top/2019/05/28/2019-05-28-2019第十届蓝桥杯CB组国赛心得/","excerpt":"一年一度的传说中的“暴力”杯又过去了，今年是第一次参加蓝桥杯省赛跟国赛，今天刚从北京回来，觉得应该写点东西，觉得不能再叫蓝桥杯暴力杯了当然大佬觉得还是暴力还请忽略，要改名了，今年难度有点大，首先题目数量变成了 10个，分值设置相对均匀5~25分的样子，之前分数梯度很大，然后难度也加了些，具体多少我也不是很清楚，我做去年第九届跟前年第十届的题目的时候也是很多也都不会做，有人下午比赛比了一半就溜出来了，觉得比CCPC还难，好吧，我还没参加过。我是C/C++B组，当时大概开始2小时左右我也想溜了，题目看到结尾了，好几个不会做的，看别人吃起了面包，觉得可能会分心，就没吃只是喝了口水，然后开始继续写，坚持到了最后，最后还是空了3个题目，大概两个大题，一个填空题，考完心凉了一半，下午6点考完，出来合了个影，既然比赛不顺利，那就玩耍的愉快吧，然后就开始了流浪北京，北京印象的日子。欢迎大家收看一年一集的《北京印象》，总共三集，当前是第一集。","text":"一年一度的传说中的“暴力”杯又过去了，今年是第一次参加蓝桥杯省赛跟国赛，今天刚从北京回来，觉得应该写点东西，觉得不能再叫蓝桥杯暴力杯了当然大佬觉得还是暴力还请忽略，要改名了，今年难度有点大，首先题目数量变成了 10个，分值设置相对均匀5~25分的样子，之前分数梯度很大，然后难度也加了些，具体多少我也不是很清楚，我做去年第九届跟前年第十届的题目的时候也是很多也都不会做，有人下午比赛比了一半就溜出来了，觉得比CCPC还难，好吧，我还没参加过。我是C/C++B组，当时大概开始2小时左右我也想溜了，题目看到结尾了，好几个不会做的，看别人吃起了面包，觉得可能会分心，就没吃只是喝了口水，然后开始继续写，坚持到了最后，最后还是空了3个题目，大概两个大题，一个填空题，考完心凉了一半，下午6点考完，出来合了个影，既然比赛不顺利，那就玩耍的愉快吧，然后就开始了流浪北京，北京印象的日子。欢迎大家收看一年一集的《北京印象》，总共三集，当前是第一集。 比赛那天是周六，周六晚上在首都经贸吃了顿饭（考点在首都经贸）然后去奥体公园看了看，看了下鸟巢，水立方，逛了逛然后就回去了。周日早上下雨其实周六武汉淹了，真遗憾错过了，到了11点觉得待在酒店有点奢侈，有点浪费大好时光，然后冒雨出去逛故宫，逛之前吃了顿烤鸭，真难忘，逛完故宫，骑车观光北京，逛了几个北京的高校，感慨颇多，还是要努力学习，觉得自己的危机意识还是不强，周一中午就踏上了回学校的路。 周日上午大概10点左右在隔壁蓝桥备考群有人上传了获奖名单，翻了半天找到了自己，国二，属于国二下游那种，大概是矬子里拔将军，轮到了我，不过还是听惊喜的，拿了个奖， 下面简单写下题目情况，等到题目放出来更新题解。1.填空题求满足2019 &lt; x &lt; y且20192，x2，y2构成等差数列的x,y，使得x+y最小，输出最小的x+y。 2x2=20192+y2,写个循环找一下，结果是7020 2.填空题把2019分解成若干个两个质数之和，例如2017和2 与 2 和2017是一种情况，求有多少种。 比赛时，这个题目读题不仔细，看成了两个质数之和，暴力搜了一遍发现只有一种，反复核对还是一种，然后半信半疑的写了个1，就提交了。这个题目需要用DP ３.填空题给的是3x3的九个格子，然后如何分割，进行旋转，能完美拼接在一起，好像是问7*7的格子有多少种分案？ 这个题目真的跪了，一开始还能想象到是如何旋转的，后来怎末想都转不过去了，罢了罢了，是在下输了还是太菜 4.填空题大概是求有100个约数的最小整数（比如6有4个约数，1，2，3，6） 暴力枚举搜一下，搜到有100个约数的数就直接break 5.填空题6*6的方格里面从左上角顶点出发，问有多少条有向回路（尽管路径相同，但方向不同也是不同）路线不能出现交叉情况，路径长度不大于12 明显是个深搜题目，比赛之前准备了深搜，地图迷宫类没怎末准备，果然***，应该还是对深搜的理解不够深入，比赛之前敲了个DFS全排列的板子，在这上面改，当时改了半天，觉得很浪费时间，熟练度不够，然后就果断放弃，做后面的题目，唉，惋惜~ 6.编程大题字符串题目，给一个长串s1，一个短串s2，然后在s2中找s1的子序列，然后问最少需要修改s2的几个字符才能实现s2是s1的子序列 每次都被字符串教育，一看根本就不是板子题目，然后需要在板子的基础上稍加处理，当时先机智的跳过了，后来转过头来，写的时候硬着头皮写了个解法，当字符串中出现相同字符的时候的测试数据就过不去，罢了罢了能过几个过几个吧，因为最后回过头来写的时候，时间也不多了。 7.编程大题单调序列，如果三个数a,b,c，如果b&gt;a并且b&gt;c，或者b&lt;a并且b&lt;c则称b点为1个转折点（大概是这个意思）然后就会有1+1个严格单调区间，然后求1~n之间的数，全排列有多少个严格单调区间？ 用next_permutation全排列函数，或者用dfs深搜实现全排列，后来发现这样最多只能实现1~10之间的求解（20%的数据测试），n稍微一大，就一时半会出不来了，优化当时没想出来，反正20分的大题只能拿20%的分数，凉了 ~ 比赛完了，有个学长说这是个找规律的题目，是道数学题 ~ 果然，不加思索直接上去写，真的暴力 ~ 8.编程大题解密 题目记不太清了，当时直接跳了 9.编程大题求第八大奇迹，大致是一边输入数据一边查询第八大奇迹，第k大的问题？？然后奇迹值x会更新，每个查询求区间[l,r]之间的第八大奇迹。简化下：长度为n的序列A，初始值均为0。有m次操作，分为以下两种：1、C p x：把A[p]的值改为x.2、Q l r： 询问区间[l,r] 的第8大的数，不存在输出0。 当时写了好久这个题目，最后用了一个结构体，来保存查询信息，即Q，然后C就直接用数组即a[p] = x 然后拷贝出区间数据，然后进行排序，查询，觉得应该能过大部分数据，比赛完我看群里说要用线段树~ 还没学到~ 10.编程大题他们说是数学题，概率DP？？？当时直接跳了~ 所以算下来大概就是2道填空题，2道能过10%~20%数据的大题，还有一道能过70%或者80%数据的题目，国二下游，还是要努力，明年再见 ~ 哦 ~ 今年发了件T恤，蓝桥十周年，考场面包带回去给室友吃了、牛奶、矿泉水还可以，还有只印有蓝桥的圆珠笔。","categories":[{"name":"感悟","slug":"感悟","permalink":"https://sinclaircoder.top/categories/感悟/"},{"name":"竞赛感悟","slug":"感悟/竞赛感悟","permalink":"https://sinclaircoder.top/categories/感悟/竞赛感悟/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"https://sinclaircoder.top/tags/感悟/"}]},{"title":"最妙不过位运算","slug":"2019-05-23-最妙不过位运算","date":"2019-05-22T16:00:00.000Z","updated":"2019-08-03T06:09:54.600Z","comments":true,"path":"2019/05/23/2019-05-23-最妙不过位运算/","link":"","permalink":"https://sinclaircoder.top/2019/05/23/2019-05-23-最妙不过位运算/","excerpt":"先来占个坑，以后慢慢补充。 一道蓝桥杯2018B组国赛题目 格雷码补全代码的题目 格雷码是以n位的二进制来表示数。 与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。 首尾两个数字也要求只有1位之差。有很多算法来生成格雷码。以下是较常见的一种： 从编码全0开始生成。 当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0） 当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。 用这个规则产生的4位格雷码序列","text":"先来占个坑，以后慢慢补充。 一道蓝桥杯2018B组国赛题目 格雷码补全代码的题目 格雷码是以n位的二进制来表示数。 与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。 首尾两个数字也要求只有1位之差。有很多算法来生成格雷码。以下是较常见的一种： 从编码全0开始生成。 当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0） 当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。 用这个规则产生的4位格雷码序列 思路：偶数时直接异或1；奇数时找到最低位的1，然后将其左移一位，在于原来的值进行异或。试问，如何找到最低位的1？直接x&amp;(-x)即可！ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;void show(int a,int n)&#123; int i; int msk = 1; for(i=0; i&lt;n-1; i++) msk = msk &lt;&lt; 1; for(i=0; i&lt;n; i++)&#123; printf((a &amp; msk)? \"1\" : \"0\"); msk = msk &gt;&gt; 1; &#125; printf(\"\\n\");&#125; void f(int n)&#123; int i; int num = 1; for(i=0; i&lt;n; i++) num = num&lt;&lt;1; int a = 0; for(i=0; i&lt;num; i++)&#123; show(a,n); if(i%2==0)&#123; a = a ^ 1; &#125; else&#123; a = a^( (a&amp;(-a))&lt;&lt;1 ) ; //填空 &#125; &#125;&#125; int main()&#123; f(4); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"刷题","slug":"数据结构与算法/刷题","permalink":"https://sinclaircoder.top/categories/数据结构与算法/刷题/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"}]},{"title":"DFS入门学习","slug":"2019-05-22-DFS入门学习","date":"2019-05-21T16:00:00.000Z","updated":"2019-08-03T06:10:08.915Z","comments":true,"path":"2019/05/22/2019-05-22-DFS入门学习/","link":"","permalink":"https://sinclaircoder.top/2019/05/22/2019-05-22-DFS入门学习/","excerpt":"学习DFS看了很多篇博客慢慢入门，感谢我看过的所有博客，我把其中做过的题目汇总起来，里面有很多是大神的代码，与大家分享。","text":"学习DFS看了很多篇博客慢慢入门，感谢我看过的所有博客，我把其中做过的题目汇总起来，里面有很多是大神的代码，与大家分享。 @[toc] 计蒜客A1601全排列 计蒜客A1601全排列找的是全排列中，排列结果互不相同的个数 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1e3;char str[N], buf[N];//bufferint vis[N], total, len;void arrange(int num) &#123; if (num == len)&#123; printf(\"%s\\n\", buf); total++; return; &#125; for (int i = 0; i &lt; len; ++i) &#123; if (!vis[i]) &#123; int j; for (j = i + 1; j &lt; len; ++j) &#123; if (vis[j]&amp;&amp;str[i] == str[j]) &#123; break; &#125; &#125; if (j == len) &#123; vis[i] = 1; buf[num] = str[i]; arrange(num + 1); vis[i] = 0; &#125; &#125; &#125;&#125;int main() &#123; while (~scanf(\"%s\",str)) &#123; len = strlen(str); sort(str, str + len); total = 0; buf[len] = '\\0'; arrange(0); printf(\"Total %d\\n\", total); &#125; return 0;&#125; 计蒜客A1636素数个数 计蒜客A1636素数个数 题目大致是求0~7的全排列组成的数字（首位不为0）中素数的个数，该题可理解为在全排列的基础上进行了条件限制 DFS+判断 答案：2668 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std;typedef unsigned long long ll;int isPrime1(ll s)&#123; if(s==2||s==3) return 1; if(s%6!=1&amp;&amp;s%6!=5) return 0; int t = sqrt(s); for(int i=5;i&lt;=t;i++) &#123; if(s%i==0||s%(i+2)==0) return 0; &#125; return 1;&#125;int isPrime2(ll s)&#123; for(int i=2;i*i&lt;=s;i++) &#123; if(s%i==0) return 0 ; &#125; return 1;&#125;int a[8]= &#123;0&#125;;int vis[8] =&#123;false&#125;;int n;int cnt;void dfs(int x)&#123; if(x == n) &#123; int s = 0; for(int i=0;i&lt;n;i++) s += (a[i]*pow(10,x-1-i)); if(isPrime1(s)) &#123; //cout &lt;&lt; s &lt;&lt; endl; cnt++; &#125; return ; &#125; for(int i=0;i&lt;n;i++) &#123; if(i==0&amp;&amp;a[i]==0) continue; if(vis[i] ==false) &#123; a[x] = i; vis[i] = true; dfs(x+1); vis[i] = false; &#125; &#125;&#125;int main()&#123; //cin &gt;&gt; n; n = 8; cnt = 0; dfs(0); //从0开始搜 cout &lt;&lt; cnt; return 0;&#125; 调用现成的排列函数next_permutation(a,a+8)P.S：其实一开始把它给忘了，一直在想怎末用DFS来实现\\捂脸=_=，记得这个函数如果n较大会很耗时间，但是用这个函数可以减少代码量，刚好这个题是填空题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ll;int isPrime1(ll s)&#123; if(s==2||s==3) return 1; if(s%6!=1&amp;&amp;s%6!=5) return 0; int t = sqrt(s); for(int i=5;i&lt;=t;i++) &#123; if(s%i==0||s%(i+2)==0) return 0; &#125; return 1;&#125;int isPrime2(ll s)&#123; for(int i=2;i*i&lt;=s;i++) &#123; if(s%i==0) return 0 ; &#125; return 1;&#125;int a[8];int main()&#123; int t=0; int a[8]=&#123;0,1,2,3,4,5,6,7&#125;; do&#123; if(a[0]==0) continue; else &#123; int b=0; b=a[0]*10000000+a[1]*1000000+a[2]*100000+a[3]*10000+a[4]*1000+a[5]*100+a[6]*10+a[7]*1; if(isPrime1(b)) t++; &#125; &#125;while(next_permutation(a,a+8));//C++中的全排列函数 cout&lt;&lt;t; return 0;&#125; 计蒜客A1146补全等式计蒜客A1146补全等式1.暴力解法：全排列+判断 时间稍长预计需要172.4s 答案：122368 1234567891011121314151617181920//#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; int a[13]; for(int i=0;i&lt;13;i++) &#123; a[i] = i+1; &#125; int cnt =0; do&#123; if(a[0]*a[1]+a[2]*a[3] == a[4]*a[5]&amp;&amp; a[6]*a[7]-a[8]*a[9] == a[10]*a[11]) cnt ++; &#125;while(next_permutation(a,a+13)); cout &lt;&lt; cnt; return 0;&#125; DFS+剪枝 0.88s12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int vis[15], a[15];int ans;void dfs(int cur) &#123; if(cur == 6) &#123; if(a[0]*a[1] + a[2]*a[3] != a[4]*a[5]) return; &#125; if(cur == 12) &#123; if(a[6]*a[7] + a[8]*a[9] == a[10]*a[11]) ans++; return; &#125; for(int i = 1; i &lt;= 13; ++i) &#123; if(!vis[i]) &#123; vis[i] = 1; a[cur] = i; dfs(cur+1); vis[i] = 0; &#125; &#125;&#125;int main() &#123; ans = 0; memset(vis, 0, sizeof(vis)); dfs(0); cout &lt;&lt; ans; return 0;&#125; Codeup5974: 【递归入门】组合+判断素数Codeup5974: 【递归入门】组合+判断素数 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;int a[21] = &#123;0&#125;;int num,k,n;ll sum;int isPrime(int s)&#123; for(int i=2;i*i&lt;=s;i++) &#123; if(s%i==0) return 0; &#125; return 1;&#125;void dfs(int index, int x, ll sum)&#123; if(x == k)&#123; if(isPrime(sum)) num++; return ; &#125; if(index == n+1) return ; dfs(index+1, x+1, sum+a[index]); //index 数组a的下标 x为已选个数 dfs(index+1, x, sum);&#125;int main()&#123; num = 0; cin &gt;&gt; n &gt;&gt; k; for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i]; dfs(1,0,0); cout &lt;&lt; num; return 0;&#125; 实现全排列（可单调递增）12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int p[10]= &#123;0&#125;;bool vis[10] = &#123;false&#125;;int n;void dfs(int x)&#123; if(x == n+1) &#123; for(int i=1;i&lt;=n;i++) cout &lt;&lt; p[i] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; for(int i=1;i&lt;=n;i++) &#123; //if(vis[i]==false) if(vis[i]==false&amp;&amp;i&gt;p[x-1]) /*如若实现单调递增的全排列 */ &#123; p[x] = i; vis[i] = true; dfs(x+1); vis[i] = false; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n) &#123; dfs(1); memset(p,0,sizeof(p)); memset(vis,false,sizeof(vis)); &#125; return 0;&#125; 1~n求所有可能的出栈序列（序列个数）首先先考虑序列个数有两种解法1.卡特兰树$\\tbinom{n}{2n}$/(n+1) 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int n;int fun(int n) //当然这里n不能过大，过大的话会爆，需要另当别论&#123; int s = 1; for(int i=2*n,j=1;i&gt;=n+1,j&lt;=n;i--,j++) &#123; s = s*i/j; &#125; return s;&#125;int main()&#123; cin &gt;&gt; n; cout &lt;&lt; fun(n)/(n+1); return 0;&#125; 2.DFS思想，用三个变量，num表示栈内元素个数，假如想进栈出栈n个元素对应的需要进栈n次出栈n次，用push表示所需进栈次数，pop表示所需出栈次数 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int n;int p[10]=&#123;0&#125;;bool vis[10] = &#123;false&#125;;int count;void dfs(int num, int pop, int push)&#123; if(pop==0&amp;&amp;push==0) &#123; count++; return ; &#125; if(push&gt;0) dfs(num+1,pop,push-1); if(pop&gt;0&amp;&amp;num&gt;0) dfs(num-1,pop-1,push);&#125;int main()&#123; cin &gt;&gt; n; count = 0; dfs(0,n,n); cout &lt;&lt; count; return 0;&#125; 【递归入门】n皇后 问题（原始的8皇后问题）【递归入门】n皇后 问题（原始的8皇后问题） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 25;int c = 0,Data[maxn] = &#123;0&#125;;//c代表解的个数bool hashTable[maxn] = &#123;0&#125;;void dfs(int n, int k) // 在n行n列的棋盘上在第k行放置皇后，进行尝试 &#123; if(k &gt; n) &#123; for(int i=1;i&lt;=n;i++) &#123; cout &lt;&lt; Data[i]; if(i&lt;n) cout &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; c++; &#125; for(int i=1;i&lt;=n;i++) &#123; if(hashTable[i] == false) &#123; bool isvalid = true; for(int j =1;j&lt;k;j++) &#123; if(k-j == abs(i-Data[j])) // (k,i) 与 (j,Data[j]) &#123; isvalid = false; break; &#125; &#125; if(isvalid) &#123; hashTable[i] = true; Data[k] = i; dfs(n,k+1); hashTable[i] = false; &#125; &#125; &#125; &#125; int main()&#123; int n; cin &gt;&gt; n; c = 0; dfs(n,1); if(c==0) cout &lt;&lt; \"no solute!\"&lt;&lt; endl; cout &lt;&lt; \"total:\" &lt;&lt; c &lt;&lt; endl; return 0;&#125; HDU2553 N皇后问题HDU2553 N皇后问题DFS+打表打表很重要，不然很可能超时，来个TLE！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;int sum,n;int x[15],y[15]=&#123;0&#125;;int place(int k)&#123; int i; for(i=1;i&lt;k;i++) &#123; if(abs(k-i)==abs(x[k]-x[i])||x[k]==x[i]) &#123; return 0; &#125; &#125; return 1;&#125;void dfs(int a)&#123; int i; if(a&gt;n) &#123; sum++; return ; &#125; else for(i=1;i&lt;=n;i++) &#123; x[a] = i; if(place(a)) dfs(a+1); &#125;&#125;int main()&#123; int i,j,n1; for(int i=1;i&lt;=10;i++) &#123; n = i; sum = 0; dfs(1); y[i] = sum; &#125; while(cin &gt;&gt; n1 &amp;&amp;n1) &#123; cout &lt;&lt; y[n1] &lt;&lt; endl; &#125; return 0;&#125; 激光样式 这是一道2018蓝桥B组国赛题目 大概是就是有三十盏灯，排成一排，相邻两盏灯不能同时打开，问有多少种打开方式？当然全都不打开也算一种。1.位运算 2.433s偶然间看到一位大神的解法，觉得位运算是真的厉害，大概思想是用一个整型x来表示排列情况，将x左移一位，然后在于x本身相与，假如结果为0，就表明这是一种正确的排列方式，然后计数，代码真的是太简单了 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;bool get(int x)&#123; if(x&amp;(x&lt;&lt;1)) return false; else return true;&#125;int main()&#123; int ans = 0; for(int i=0;i&lt;1&lt;&lt;30;i++) &#123; if(get(i))&#123; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 2.DFS不过说起来还是深搜快，零点几秒，反正这是个填空题，能做出来就行呗。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;ll ans;int light[31];void dfs(int x)&#123; if(x == 31) &#123; ans++; return ; &#125; if(light[x-1] == 0) &#123; light[x] = 1; dfs(x+1); light[x] = 0; &#125; dfs(x+1);&#125;int main()&#123; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 【递归入门】走迷宫Codeup5978【递归入门】走迷宫 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;int a[20][20], endx, endy, m, n;bool no = true;int dx[4] = &#123; 0,-1,0,1 &#125;, dy[4] = &#123; -1,0,1,0 &#125;; struct Route &#123; int x, y;&#125;route[5000]; void DFS(int x, int y, int num) &#123; if (x == endx&amp;&amp;y == endy) &#123; for (int i = 0; i &lt; num; i++) &#123; printf(\"(%d,%d)-&gt;\",route[i].x,route[i].y); &#125; printf(\"(%d,%d)\\n\",x,y); no = false; return; &#125; route[num].x = x, route[num].y = y; for (int i = 0; i &lt; 4; i++) &#123; if (a[x + dx[i]][y + dy[i]] == 1 &amp;&amp; 1 &lt;= x + dx[i] &lt;= m &amp;&amp; 1 &lt;= y + dy[i] &lt;= n) &#123; a[x][y] = 0; DFS(x + dx[i], y + dy[i], num + 1); a[x][y] = 1; &#125; &#125; &#125; int main() &#123; while (cin &gt;&gt; m &gt;&gt; n) &#123; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; int startx, starty; cin &gt;&gt; startx &gt;&gt; starty &gt;&gt; endx &gt;&gt; endy; DFS(startx, starty, 0); if (no) cout &lt;&lt; -1 &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"刷题","slug":"数据结构与算法/刷题","permalink":"https://sinclaircoder.top/categories/数据结构与算法/刷题/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"}]},{"title":"7-29 修理牧场","slug":"2019-05-04-7-29 修理牧场","date":"2019-05-03T16:00:00.000Z","updated":"2019-08-03T06:10:02.048Z","comments":true,"path":"2019/05/04/2019-05-04-7-29 修理牧场/","link":"","permalink":"https://sinclaircoder.top/2019/05/04/2019-05-04-7-29 修理牧场/","excerpt":"来源：(PTA数据结构与算法题目集(中文) 农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数Li个长度单位，于是他购买了一条很长的、能锯成N块的木头，即该木头的长度是Li的总和。但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。请编写程序帮助农夫计算将木头锯成N块的最少花费。","text":"来源：(PTA数据结构与算法题目集(中文) 农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数Li个长度单位，于是他购买了一条很长的、能锯成N块的木头，即该木头的长度是Li的总和。但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。请编写程序帮助农夫计算将木头锯成N块的最少花费。 输入格式:输入首先给出正整数N（≤10​4），表示要将木头锯成N块。第二行给出N个正整数（≤50），表示每段木块的长度。 输出格式:输出一个整数，即将木头锯成N块的最少花费。 输入样例:84 5 1 2 1 3 1 1输出样例:49 12345678910111213141516171819202122232425262728// 哈夫曼树#include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;p; int n; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; int t; cin &gt;&gt; t; p.push(t); &#125; int s=0; while(p.size()&gt;1)&#123; int num1 = p.top(); p.pop(); int num2 = p.top(); p.pop(); s += (num1+num2); p.push(num1+num2); &#125; cout &lt;&lt; s; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"刷题","slug":"数据结构与算法/刷题","permalink":"https://sinclaircoder.top/categories/数据结构与算法/刷题/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"}]},{"title":"第一次参加蓝桥杯(第十届)感怀","slug":"2019-03-24-第一次参加蓝桥杯(第十届)感怀","date":"2019-03-23T16:00:00.000Z","updated":"2019-08-03T06:05:35.594Z","comments":true,"path":"2019/03/24/2019-03-24-第一次参加蓝桥杯(第十届)感怀/","link":"","permalink":"https://sinclaircoder.top/2019/03/24/2019-03-24-第一次参加蓝桥杯(第十届)感怀/","excerpt":"四个小时，十道题目，花了学院300块大洋 \\捂脸","text":"四个小时，十道题目，花了学院300块大洋 \\捂脸 这是我第一次参加规模还差不多的程序设计比赛，蓝桥杯，当然一些大牛高校的王牌选手是不稀罕参加的，网上风评称其为“暴力杯”，说根本用不到什么算法技巧，只要会点数学，全程暴力求解就ok，比赛之前看了很多关于蓝桥杯的经验贴，其中出现频率最高的词汇是暴力求解，后来慢慢的训练的做题目的时候，才知道什么是真正的暴力求解，所谓暴力求解，并非无脑不假思索的就直接暴力枚举，而是要经过若干逻辑判断之后，进行求解，相比于十分精巧的算法技巧来说，是暴力了些。比赛的前一天，也就是昨天，我还在看蓝桥杯必考的快排、DFS、贪心….结果必考的没考，没考快排，考了DFS，一道迷宫题目，当时看了看，因为深搜不熟练，觉得做这道题目的话，做半天可能也做不出来，白浪费时间干脆直接跳过，这道题是填空题，15分，下了考场之后，群里有人说这是一道华为的面试题目，好吧。同样是参加蓝桥杯，车上有18级的、17级的还有16级的，我是17级但是今年是第一次参加蓝桥杯，我大一这时候，听老师的话自己的笔记本还没买…经过我的亲身经历证明，对于计算机专业来说，这是万万不行的，我大一一年一直停留在C，C还没精通，而别人大一就学完了C、C++、数据结构甚至更多，而我大一的时间都去哪儿了，我用我的时间换来了什么？都是值得思考的问题，终于我在大一的暑假反应过来，励志大二上学完数据结构，可是大二上课多，再加上自己的惰性，这个历史性的任务终究还是没完成。大二上参加的学院老师讲的蓝桥杯培训课，去是每次都去了，可是也仅仅是听了听，自己也没有下去动手，导致编码能力太差，到现在，我发现18级的很多学生的编码能力已经比我强了…当然这种事情也说不好，毕竟起跑线不同我又在给自己找借口，菜就是原罪。等到了大二上期末考试考完之后，留校做课设，那个时候我开始准备蓝桥杯，从数论开始学起，没学多少放寒假了，打算寒假训练自己的编码能力，顺便学学数据结构的，结果学习的重心不知不觉跑到了JAVA上。我就是这样一步一步的鸽掉我的算法训练的…到了大二下学期，正儿八经的自我反思过后，决心要努力学习训练算法，没事就刷题，周末时间抱着电脑图书馆刷各大OJ上的题目，看别人说，先来刷个杭电OJ 100题水题100道。然而我到现在也只是异常费劲的写了35道，前几天学习算法知识，做题目，越做越绝望，看一道不会，看一道不会，然后去网上找解题报告看，学习别人的思路，看别人的做法，我立誓要学好算法，去参加各种程序设计比赛，让日后的每一天都不会像现在一样窘迫。昨天周六，比赛前一天，我在图书馆看了一天的往年题目，也思考了很多，思考我努力学习算法到底是为了什么？为了参加比赛？为了拿奖？用拿来的奖来证明自己？用拿来的奖来争取推免资格？我想了又想，我最初就是为了拿到推免资格来参加比赛，一直心急的去参加各种比赛，以前参加的全国大学生数学竞赛、全国大学英语竞赛，每次都是匆匆上阵，每次都是落荒而逃，每次都是说下次一定再去努力。那便是我的2018年的写照。参加程序设计比赛是为了拿奖，而不是出于对编程的热爱，一直以来，觉得自己一个很大的缺点，就是太过于急功近利，我没有别人的聪明才智，也没有别人的超高效率，更没有比别人很强的能力，却总想着去用做一件事的时间来做两件事，有时候会面对两个比赛，别人可能会有所取舍，而我却总想着我能做到，然后急功近利的去报了两个比赛的名，然后最后可能一个比赛的作品都提交不上。如今2019了，不能再鸽了，不能再中途放弃了，包括写博客，这是我2019年开始写的，我的博客搭建好了, 2019年要去更加努力、更加自律、更加脚踏实地、不能再去做思想上的巨人而行动上的侏儒了，今天的蓝桥杯落下帷幕，下周的高校天梯赛，由于种种原因，参赛名单里没我，正好我可以重新训练，学习我要今年3月份完成的数据结构教程学习，还要补作业，写一个带界面的迷宫算法，算是个小课设。接下来的希望就是我能进阶决赛，去首都走一趟。能不能进决赛，下周比赛结果就出来了。最近的一个比赛可能就是中国高校微信小程序比赛，要准备参赛了。总要做出点东西来，才不枉自己对一步步接近梦想时内心的汹涌与澎湃。另外，自己的暑假也被安排上了，前20天去导师实验室跟着做项目学习假如我啥都不会做，那我扫地好了后面的一个月参加数学建模培训，参赛，另外把去年失之交臂的数竞再来一遍，不到长城非好汉，人啊，总是失去了才知道珍惜，当我重新再拿到机会时我想我会倍加珍惜…再来谈谈今天的蓝桥杯，今天去的赛点是一个民办大学，一下车觉得这所学校未免也有点太高端，比我的学校好太多，这建筑、这校园、这高楼，真想来这里读大学，当然这是参赛之前的想法，当我参加完比赛之后，我的认知发生了变化你懂的，与更好的校园设施（宽敞的校园、气派的大门，高端的大楼）相比，我还是更喜欢学习氛围、学术氛围更加浓厚的学校，尽管它的校门可能不是那么气派。 更于2019年3月28日初赛结果出来了，省一，要准备国赛了…","categories":[{"name":"感悟","slug":"感悟","permalink":"https://sinclaircoder.top/categories/感悟/"},{"name":"竞赛感悟","slug":"感悟/竞赛感悟","permalink":"https://sinclaircoder.top/categories/感悟/竞赛感悟/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"https://sinclaircoder.top/tags/感悟/"}]},{"title":"HDU2032之杨辉三角的多种解法","slug":"2019-03-09-HDU2032之杨辉三角的多种解法","date":"2019-03-08T16:00:00.000Z","updated":"2019-08-03T06:10:18.914Z","comments":true,"path":"2019/03/09/2019-03-09-HDU2032之杨辉三角的多种解法/","link":"","permalink":"https://sinclaircoder.top/2019/03/09/2019-03-09-HDU2032之杨辉三角的多种解法/","excerpt":"HDU2032 还记得中学时候学过的杨辉三角吗？具体的定义这里不再描述，你可以参考以下的图形：11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1 即元素值等于肩上的两个元素之和，每行第一个跟最后一个都为１。","text":"HDU2032 还记得中学时候学过的杨辉三角吗？具体的定义这里不再描述，你可以参考以下的图形：11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1 即元素值等于肩上的两个元素之和，每行第一个跟最后一个都为１。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//解法１、二维数组int main() &#123; int n,a[30][30]=&#123;0&#125;; while(cin&gt;&gt; n) &#123; for(int i=0;i&lt;n;i++) &#123; a[i][0]=1;a[i][i]=1; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; if(j&gt;0) a[i][j] = a[i-1][j] + a[i-1][j-1]; cout &lt;&lt; a[i][j]; if(j&lt;i) cout &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;//解法2、一维数组int main() &#123; int n; while(cin&gt;&gt;n) &#123; int a[40]=&#123;0&#125;,b[40]=&#123;0&#125;; //此处会涉及到初始化问题，故须放到while循环里面 a[1]=1;b[1]=1; for(int i=1;i&lt;=n;i++) // 此处索引从1开始 &#123; for(int j=1;j&lt;=i;j++) &#123; a[j]=b[j]+b[j-1]; &#125; for(int j=1;j&lt;=i;j++) &#123; b[j] = a[j] ; cout&lt;&lt; b[j] ; if(j&lt;i) cout &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;//解法3、多项式 杨辉三角中每一行的值为C（ｎ－１，ｍ），其中n为行数，m为列数索引int fun(int n,int m)&#123; int s1=1,j=1; for(int i=n;i&gt;n-m;i--) &#123; s1 =s1*i/j; j++; &#125; return s1;&#125;int main() &#123; int n; while(cin&gt;&gt; n) &#123; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; cout &lt;&lt; fun(i,j); if(j&lt;i)cout &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;// 解法4、递推法，发现规律int main() &#123; int n; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) &#123; int b=1; for(int j=1;j&lt;=i;j++) &#123; cout &lt;&lt; b; b = b*(i-j)/j; // 下一个元素值=上一个*(行数-列数)/列数 if(j&lt;i) cout &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 本该大一学会的，现在才学会，我干了什么？我究竟用时间换来了什么？","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"刷题","slug":"数据结构与算法/刷题","permalink":"https://sinclaircoder.top/categories/数据结构与算法/刷题/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"}]},{"title":"一个小绿锁引发的问题","slug":"2019-03-08-博客添加SSL","date":"2019-03-07T16:00:00.000Z","updated":"2019-08-03T06:04:40.966Z","comments":true,"path":"2019/03/08/2019-03-08-博客添加SSL/","link":"","permalink":"https://sinclaircoder.top/2019/03/08/2019-03-08-博客添加SSL/","excerpt":"最近在阿里云买了个域名，毕竟**.github.io有点长，买了个便宜的top。在阿里云控制台解析了之后，后来访问的时候总是显示非安全连接，身为强迫症患者，这肯定不能忍，然后就着手开始做了。 据外媒报道，从2017年1月份正式发布的Chrome 56开始，Google将把某些包含敏感内容的HTTP页面标记为“不安全”，比如含有密码或支付表单信息。Google最终目标是将所有打破了https连接的HTTP页面，用特定的红色图标给标记出来… 此举旨在唤起用户有关HTTP连接不安全、容易受到中间人攻击等危险的意识。通过HTTP连接发送的数据（比如密码和支付细节），会被通网络下别有用心的人轻易拦截。 为了这把小绿锁（安全问题），需要添加第三方的证书，这时Cloudflare提供的免费的SSL成为不二之选 收费的SSL服务总是比免费的更加周到，一般收费的SSL都会提供端到端的加密。但是价格不菲，对于个人博客来说，这是一笔不必要的开销。我只是需要看到网站地址栏有绿色的锁头，那就证明我们的网站相对安全了。此外，使用https之后，谷歌、百度等搜索排名权值（PR等）也会有相对提升。还有其他的一些，例如Cloudflare还提供免费的CDN和缓存技术，让浏览者有更好的体验~~","text":"最近在阿里云买了个域名，毕竟**.github.io有点长，买了个便宜的top。在阿里云控制台解析了之后，后来访问的时候总是显示非安全连接，身为强迫症患者，这肯定不能忍，然后就着手开始做了。 据外媒报道，从2017年1月份正式发布的Chrome 56开始，Google将把某些包含敏感内容的HTTP页面标记为“不安全”，比如含有密码或支付表单信息。Google最终目标是将所有打破了https连接的HTTP页面，用特定的红色图标给标记出来… 此举旨在唤起用户有关HTTP连接不安全、容易受到中间人攻击等危险的意识。通过HTTP连接发送的数据（比如密码和支付细节），会被通网络下别有用心的人轻易拦截。 为了这把小绿锁（安全问题），需要添加第三方的证书，这时Cloudflare提供的免费的SSL成为不二之选 收费的SSL服务总是比免费的更加周到，一般收费的SSL都会提供端到端的加密。但是价格不菲，对于个人博客来说，这是一笔不必要的开销。我只是需要看到网站地址栏有绿色的锁头，那就证明我们的网站相对安全了。此外，使用https之后，谷歌、百度等搜索排名权值（PR等）也会有相对提升。还有其他的一些，例如Cloudflare还提供免费的CDN和缓存技术，让浏览者有更好的体验~~ 下面是我参考的教程(博主尊重原创，故此下面只给出超链)：为自定义域名的GitHub Pages添加SSL 完整方案为添加了自定义域名的GitHub Pages添加SSL，启用强制HTTPS(小绿锁） 总之，博客愈发完善，每次改动都会碰见一堆高大上的专业术语，而他们却真实的来自那看起来枯燥无聊的基础知识，实战受蹩，或许看书应该能更加投入。等技术再成熟些，博客应该会更完善！ 调试完一个动态连接函数，固然值得兴奋，但真正的成功远还在无数个函数之后。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://sinclaircoder.top/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://sinclaircoder.top/tags/Blog/"}]},{"title":"HDU2018母牛的故事","slug":"2019-03-03-HDU2018母牛的故事","date":"2019-03-02T16:00:00.000Z","updated":"2019-08-03T06:08:08.230Z","comments":true,"path":"2019/03/03/2019-03-03-HDU2018母牛的故事/","link":"","permalink":"https://sinclaircoder.top/2019/03/03/2019-03-03-HDU2018母牛的故事/","excerpt":"Problem Description 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 Output 对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。","text":"Problem Description 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 Output 对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 Sample Input 2450 Sample Output 246 分析根据题目已知，列出表格 第n年 成年牛 幼牛1 幼牛2 幼牛3 总数 1 1 1 2 1 1 2 3 1 1 1 3 4 1 1 1 1 4 5 2 2 1 1 6 6 3 3 2 1 9 7 4 4 3 2 13 8 6 6 4 3 19 9 9 9 6 4 28 … … … … … … 观察表格，联想斐波那契数列，可得出以下公式： fn = fn-1 + fn-3 题解12345678910111213141516//解法1#include&lt;iostream&gt;using namespace std;int main() &#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; int a[56]; a[0] = 1;a[1] = 2;a[2] = 3;a[3] = 4; for(int i=4;i&lt;56;i++) a[i] = a[i-1] + a[i-3]; cout &lt;&lt; a[n-1] &lt;&lt; endl; &#125; return 0;&#125; 1234567891011121314151617//解法2—递归实现#include &lt;iostream&gt;using namespace std;int fun(int n)&#123; if(n&lt;5) return n; else return fun(n-1)+fun(n-3);&#125;int main() &#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; cout &lt;&lt; fun(n) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"刷题","slug":"数据结构与算法/刷题","permalink":"https://sinclaircoder.top/categories/数据结构与算法/刷题/"}],"tags":[{"name":"算法训练","slug":"算法训练","permalink":"https://sinclaircoder.top/tags/算法训练/"}]},{"title":"Python3字符串API之expandtabs()","slug":"2019-02-11-Python3字符串API之expandtabs()","date":"2019-02-10T16:00:00.000Z","updated":"2019-08-03T06:03:59.124Z","comments":true,"path":"2019/02/11/2019-02-11-Python3字符串API之expandtabs()/","link":"","permalink":"https://sinclaircoder.top/2019/02/11/2019-02-11-Python3字符串API之expandtabs()/","excerpt":"Challenges make you discover things about yourself that you never really knew.挑战能让你发现自己都不曾了解过的一面。 —–Cicely Tyson 描述123456def expandtabs(self, *args, **kwargs): # real signature unknown** &quot;&quot;&quot; Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. &quot;&quot;&quot; pass 返回字符串的一个拷贝，该拷贝中把字符串中的tab (即’\\t‘)转换为指定的tabsize数量的空格，其中若tabsize未给出则默认为8.","text":"Challenges make you discover things about yourself that you never really knew.挑战能让你发现自己都不曾了解过的一面。 —–Cicely Tyson 描述123456def expandtabs(self, *args, **kwargs): # real signature unknown** &quot;&quot;&quot; Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. &quot;&quot;&quot; pass 返回字符串的一个拷贝，该拷贝中把字符串中的tab (即’\\t‘)转换为指定的tabsize数量的空格，其中若tabsize未给出则默认为8. 语法 str.expandtabs(tabsize = 8); 实例其实还是例子更直观 123456789101112 # 代码段print(&quot;第一行为基准&quot;)print(&quot;123456789012345678901&quot;)s1 = &quot;123456\\t7890\\t123&quot;print(s1)print(s1.expandtabs(6))print(s1.expandtabs(7))print(s1.expandtabs(8))print(s1.expandtabs(9))s2 = &quot;\\t12\\t345678\\t123&quot;print(s2)print(s2.expandtabs()) 12345678910 # 结果显示第一行为基准123456789012345678901123456 7890 123123456 7890 123123456 7890 123123456 7890 123123456 7890 123 12 345678 123 12 345678 123 总结 &emsp;&emsp;expandtabs() 方法是把字符串中的’\\t’转换为空格。 &emsp;&emsp;下面首先来说说’\\t’，在Python3中 ‘\\t’ 是补4的整数倍个空格，假如’\\t’在字符串首，则会补4个空格，当在串中时要看’\\t’前面的字符，距离4的整数倍差多少补多少空格。 &emsp;&emsp;下面再说一下这个 expandtabs() 方法就是在 ‘\\t’ 处补指定长度tabsize的空格，可以自定指定，也可以使用默认的补8个空格，即看前面的字符串然后将其补到tabsize的整数倍，假如’\\t’在串首则直接补tabsize数量的空格。","categories":[{"name":"Python","slug":"Python","permalink":"https://sinclaircoder.top/categories/Python/"},{"name":"api","slug":"Python/api","permalink":"https://sinclaircoder.top/categories/Python/api/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://sinclaircoder.top/tags/Python3/"}]},{"title":"Java中关于日期的printf格式化输出","slug":"2019-02-09-Java中关于日期的printf格式化输出","date":"2019-02-08T16:00:00.000Z","updated":"2019-08-03T06:03:31.785Z","comments":true,"path":"2019/02/09/2019-02-09-Java中关于日期的printf格式化输出/","link":"","permalink":"https://sinclaircoder.top/2019/02/09/2019-02-09-Java中关于日期的printf格式化输出/","excerpt":"If you believe in yourself enough and know what you want, you’re gonna make it happen.如果你足够自信，也知道自己想要什么，就一定会实现心中所想。—–Mariah Carey, “Make It Happen” printf方法可以很轻易的格式化日期，用两个字母，以%t开头并以下面的其中一个字母结尾。转换符|说明—|—|—|—–a|日期中星期简称A|日期中星期全称b|日期中月份的简称B|日期中月份的全称C|日期中年份的前两位数y|日期中年份的后两位数Y|日期中年份的完整表示D|“年/月/日”格式F|“年-月-日”格式j|一年中的第几天m|日期中的月份，两位数字表示，不足两位补零d|日期中的日，两位数字表示，不足两位补零e|日期中月份的日，不补零T|“HH:MM:SS” 格式（24小时）r|“HH:MM:SS PM”格式（12小时）R|“HH:MM”格式（24小时） 测试123456789101112131415161718192021222324public class Sinclair_java_20190122&#123; public static void main(String[] args) &#123; Date date = new Date(); String str = String.format(Locale.US,\"英文月份简称：%tb\",date); System.out.println(str); System.out.printf(\"本地月份简称：%tb\\n\",date); str = String.format(Locale.US, \"英文月份全称：%tB\",date); System.out.println(str); System.out.printf(\"本地月份全称：%tB%n\",date); str = String.format(Locale.US, \"英文星期简称：%ta\",date); System.out.println(str); System.out.printf(\"本地星期的全称：%tA%n\",date); System.out.printf(\"本地星期的简称：%ta%n\",date); System.out.printf(\"年的前两位数字：%tC%n\",date); System.out.printf(\"年的后两位数字：%ty%n\",date); System.out.printf(\"年的完整表示：%tY%n\",date); System.out.printf(\"一年中的天数：%tj%n\",date); System.out.printf(\"%s %tY-%&lt;tm-%&lt;td%n\",\"日期的完整表示：\",date); System.out.printf(\"在本月是第几天(不补零)：%te%n\",date); System.out.printf(\"在本月是第几天(补零)：%td%n\",date); &#125;&#125;","text":"If you believe in yourself enough and know what you want, you’re gonna make it happen.如果你足够自信，也知道自己想要什么，就一定会实现心中所想。—–Mariah Carey, “Make It Happen” printf方法可以很轻易的格式化日期，用两个字母，以%t开头并以下面的其中一个字母结尾。转换符|说明—|—|—|—–a|日期中星期简称A|日期中星期全称b|日期中月份的简称B|日期中月份的全称C|日期中年份的前两位数y|日期中年份的后两位数Y|日期中年份的完整表示D|“年/月/日”格式F|“年-月-日”格式j|一年中的第几天m|日期中的月份，两位数字表示，不足两位补零d|日期中的日，两位数字表示，不足两位补零e|日期中月份的日，不补零T|“HH:MM:SS” 格式（24小时）r|“HH:MM:SS PM”格式（12小时）R|“HH:MM”格式（24小时） 测试123456789101112131415161718192021222324public class Sinclair_java_20190122&#123; public static void main(String[] args) &#123; Date date = new Date(); String str = String.format(Locale.US,\"英文月份简称：%tb\",date); System.out.println(str); System.out.printf(\"本地月份简称：%tb\\n\",date); str = String.format(Locale.US, \"英文月份全称：%tB\",date); System.out.println(str); System.out.printf(\"本地月份全称：%tB%n\",date); str = String.format(Locale.US, \"英文星期简称：%ta\",date); System.out.println(str); System.out.printf(\"本地星期的全称：%tA%n\",date); System.out.printf(\"本地星期的简称：%ta%n\",date); System.out.printf(\"年的前两位数字：%tC%n\",date); System.out.printf(\"年的后两位数字：%ty%n\",date); System.out.printf(\"年的完整表示：%tY%n\",date); System.out.printf(\"一年中的天数：%tj%n\",date); System.out.printf(\"%s %tY-%&lt;tm-%&lt;td%n\",\"日期的完整表示：\",date); System.out.printf(\"在本月是第几天(不补零)：%te%n\",date); System.out.printf(\"在本月是第几天(补零)：%td%n\",date); &#125;&#125; 测试结果1234567891011121314英文月份简称：Feb本地月份简称：2月英文月份全称：February本地月份全称：二月英文星期简称：Sat本地星期的全称：星期六本地星期的简称：周六年的前两位数字：20年的后两位数字：19年的完整表示：2019一年中的天数：040日期的完整表示： 2019-02-09在本月是第几天(不补零)：9在本月是第几天(补零)：09 大家新年好哇！","categories":[{"name":"Java","slug":"Java","permalink":"https://sinclaircoder.top/categories/Java/"},{"name":"api","slug":"Java/api","permalink":"https://sinclaircoder.top/categories/Java/api/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sinclaircoder.top/tags/Java/"}]},{"title":"欧几里得算法","slug":"2019-01-09-欧几里得算法","date":"2019-01-08T16:00:00.000Z","updated":"2019-08-03T06:07:53.378Z","comments":true,"path":"2019/01/09/2019-01-09-欧几里得算法/","link":"","permalink":"https://sinclaircoder.top/2019/01/09/2019-01-09-欧几里得算法/","excerpt":"欧几里得算法求最大公约数 Sometimes your whole life boils down to one insane move. 人这一辈子，有时就得靠一次疯狂的举动才能扭转乾坤。 ——————《阿凡达》 @[toc] 一、介绍欧几里得 &emsp;&emsp;像所有博客一样，出于尊重，介绍一下这位伟大的数学家欧几里得。 &emsp;&emsp;欧几里得，古希腊人，数学家，主要成就：数学巨著《几何原本》、欧几里得算法、完全数。 &emsp;&emsp;在柏拉图学派晚期导师普罗克洛斯（约410～485）的《几何学发展概要》中，就记载着这样一则故事，说的是数学在欧几里得的推动下，逐渐成为人们生活中的一个时髦话题(这与当今社会截然相反)，以至于当时亚里山大国王托勒密一世也想赶这一时髦，学点儿几何学。 &emsp;&emsp;虽然这位国王见多识广，但欧氏几何却令他学的很吃力。于是，他问欧几里得“学习几何学有没有什么捷径可走？”，欧几里得笑道：“抱歉，陛下!学习数学和学习一切科学一样，是没有什么捷径可走的。学习数学，人人都得独立思考，就像种庄稼一样，不耕耘是不会有收获的。在这一方面，国王和普通老百姓是一样的。” 从此,“在几何学里,没有专为国王铺设的大道。”这句话成为千古传诵的学习箴言。&emsp;&emsp;总之呢，任何事情都是这样，哪有这么多得捷径可走，天才往往都是天天积累成才。","text":"欧几里得算法求最大公约数 Sometimes your whole life boils down to one insane move. 人这一辈子，有时就得靠一次疯狂的举动才能扭转乾坤。 ——————《阿凡达》 @[toc] 一、介绍欧几里得 &emsp;&emsp;像所有博客一样，出于尊重，介绍一下这位伟大的数学家欧几里得。 &emsp;&emsp;欧几里得，古希腊人，数学家，主要成就：数学巨著《几何原本》、欧几里得算法、完全数。 &emsp;&emsp;在柏拉图学派晚期导师普罗克洛斯（约410～485）的《几何学发展概要》中，就记载着这样一则故事，说的是数学在欧几里得的推动下，逐渐成为人们生活中的一个时髦话题(这与当今社会截然相反)，以至于当时亚里山大国王托勒密一世也想赶这一时髦，学点儿几何学。 &emsp;&emsp;虽然这位国王见多识广，但欧氏几何却令他学的很吃力。于是，他问欧几里得“学习几何学有没有什么捷径可走？”，欧几里得笑道：“抱歉，陛下!学习数学和学习一切科学一样，是没有什么捷径可走的。学习数学，人人都得独立思考，就像种庄稼一样，不耕耘是不会有收获的。在这一方面，国王和普通老百姓是一样的。” 从此,“在几何学里,没有专为国王铺设的大道。”这句话成为千古传诵的学习箴言。&emsp;&emsp;总之呢，任何事情都是这样，哪有这么多得捷径可走，天才往往都是天天积累成才。 二、实现思路 定义2.1：设m和n是两个不全为0的整数，称m与n的公因子中最大的为m与n的最大公因子，或最大公约数(greatest common divisor)，记作gcd(m,n)定义2.2：设m和n是两个非零整数，称a与b最小的公倍数为m与n的最小公倍数(least common multiple)，记作lcm(m,n) 欧几里得算法又称辗转相除法 s：设两个正整数m，n且m &gt; n ; s1：令r=m%n（%代表取余）； s2：若r=0(即n整除m)运算结束，n为结果 ； s3：否则令m=n，n=r并返回s1 ； 三、核心思想 gcd(m,n)=gcd(n,mod(m,n) lcm(m,n) = ab/gcd(m,n) 证明：不妨设 m=k1d ,n=k2d , k3 = m/n (整除) 则 r=m-k3n=k1d-k2k3d=(k1- k2k3)d故r也是d的倍数，得证$\\it gcd (m,n)=gcd(n,mod(m,n)$ 四、优点 一看相比于穷举法，效率也会高很多 五、核心代码123456789101112131415161718192021222324int gcd(int m,int n)&#123; int t,r; if(m&lt;n) swap(m,n); //交换二者的值 while(n!=0) &#123; r=m%n; m=n; n=r; &#125; return n;&#125;int gcd(int m,int n) // 递归做法&#123; if(m&lt;n) swap(m,n); //交换二者的值 if(n==0) return m; return gcd(n,m%n);&#125;int lcm(int gcd,int m,int n)&#123; return m*n/gcd;&#125; 参考来源：人物简介源自百度百科 在CSDN上的第一篇文章，２０１９加油！","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"知识","slug":"数据结构与算法/知识","permalink":"https://sinclaircoder.top/categories/数据结构与算法/知识/"}],"tags":[{"name":"算法训练","slug":"算法训练","permalink":"https://sinclaircoder.top/tags/算法训练/"}],"author":"Sinclair"},{"title":"HDU2099整除的尾数","slug":"2019-01-09-HDU2099整除的尾数","date":"2019-01-08T16:00:00.000Z","updated":"2019-08-03T06:09:39.866Z","comments":true,"path":"2019/01/09/2019-01-09-HDU2099整除的尾数/","link":"","permalink":"https://sinclaircoder.top/2019/01/09/2019-01-09-HDU2099整除的尾数/","excerpt":"整除的尾数 You have to live spherically - in many directions.Never lose your childish enthusiasm and things will come your way.人要活得精彩，各个领域都要勇于尝试，永远保持童真般的热情，一切就会得偿所愿。 —-《托斯卡尼艳阳下》 Problem Description 一个整数，只知道前几位，不知道末二位，被另一个整数除尽了，那么该数的末二位该是什么呢？ Input 输入数据有若干组，每组数据包含二个整数a，b（0&lt;a&lt;10000, 10&lt;b&lt;100），若遇到0 0则处理结束。 Output 对应每组数据，将满足条件的所有尾数在一行内输出，格式见样本输出。同组数据的输出，其每个尾数之间空一格，行末没有空格。","text":"整除的尾数 You have to live spherically - in many directions.Never lose your childish enthusiasm and things will come your way.人要活得精彩，各个领域都要勇于尝试，永远保持童真般的热情，一切就会得偿所愿。 —-《托斯卡尼艳阳下》 Problem Description 一个整数，只知道前几位，不知道末二位，被另一个整数除尽了，那么该数的末二位该是什么呢？ Input 输入数据有若干组，每组数据包含二个整数a，b（0&lt;a&lt;10000, 10&lt;b&lt;100），若遇到0 0则处理结束。 Output 对应每组数据，将满足条件的所有尾数在一行内输出，格式见样本输出。同组数据的输出，其每个尾数之间空一格，行末没有空格。 Sample Input 200 401992 950 0 ##Sample Output 00 40 8015 一、思路 输入要判断是否为0，先将这个整数乘以100，然后利用0到99的穷举进行判断，输出时考虑到0的问题，用printf函数输出。 二、代码实现12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main() &#123; int a,b,count=0; while(cin&gt;&gt; a &gt;&gt; b &amp;&amp; a!=0 &amp;&amp; b!=0) &#123; a *= 100; for(int i=0;i&lt;=99;i++) &#123; if((a+i)%b == 0) &#123; count++; // 计数，用于空格的输出 if(count==1) printf(\"%02d\",i); //输出空格的问题 else printf(\" %02d\",i); &#125; &#125; cout &lt;&lt; endl; count=0; //每一组整数的后两位判断完毕之后，count需清零，然后输出换行 &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"刷题","slug":"数据结构与算法/刷题","permalink":"https://sinclaircoder.top/categories/数据结构与算法/刷题/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"}],"author":"Sinclair"},{"title":"HDU2097Sky数","slug":"2019-01-09-HDU 2097Sky数","date":"2019-01-08T16:00:00.000Z","updated":"2019-08-03T06:09:47.466Z","comments":true,"path":"2019/01/09/2019-01-09-HDU 2097Sky数/","link":"","permalink":"https://sinclaircoder.top/2019/01/09/2019-01-09-HDU 2097Sky数/","excerpt":"Sky数 My life didn’t please me, so I created my life.我的生活不曾取悦于我，所以我创造了自己的生活 ——-Coco Chanel Problem Description Sky从小喜欢奇特的东西，而且天生对数字特别敏感，一次偶然的机会，他发现了一个有趣的四位数2992，这个数它的十进制数表示，其四位数字之和为2+9+9+2=22，它的十六进制数BB0，其四位数字之和也为22，同时它的十二进制数表示1894，其四位数字之和也为22，啊哈，真是巧啊。Sky非常喜欢这种四位数，由于他的发现，所以这里我们命名其为Sky数。但是要判断这样的数还是有点麻烦啊，那么现在请你帮忙来判断任何一个十进制的四位数，是不是Sky数吧。 Input 输入含有一些四位正整数，如果为0，则输入结束。 Output 若n为Sky数，则输出“#n is a Sky Number.”，否则输出“#n is not a Sky Number.”。每个结果占一行。注意：#n表示所读入的n值。","text":"Sky数 My life didn’t please me, so I created my life.我的生活不曾取悦于我，所以我创造了自己的生活 ——-Coco Chanel Problem Description Sky从小喜欢奇特的东西，而且天生对数字特别敏感，一次偶然的机会，他发现了一个有趣的四位数2992，这个数它的十进制数表示，其四位数字之和为2+9+9+2=22，它的十六进制数BB0，其四位数字之和也为22，同时它的十二进制数表示1894，其四位数字之和也为22，啊哈，真是巧啊。Sky非常喜欢这种四位数，由于他的发现，所以这里我们命名其为Sky数。但是要判断这样的数还是有点麻烦啊，那么现在请你帮忙来判断任何一个十进制的四位数，是不是Sky数吧。 Input 输入含有一些四位正整数，如果为0，则输入结束。 Output 若n为Sky数，则输出“#n is a Sky Number.”，否则输出“#n is not a Sky Number.”。每个结果占一行。注意：#n表示所读入的n值。 Sample Input 299212340 Sample Output 2992 is a Sky Number.1234 is not a Sky Number. 思路 输入一个四位整数，需要将其进制转换，而在进制转换的过程中又可以实现四位数各位相加，看似需要将数据转换成十六进制、十二进制（输入的便是十进制），实则，只需一个进制转换求和函数就可以实现，不妨设转换为n进制，在转换的过程中便可实现求和，先对n求模，再整除n，最后判断和是否相等即可。 代码1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int DBC(int a,int n) //将数字a转化为n进制，将其每位相加求和 &#123; int sum=0; while(a) &#123; sum += a%n; a /= n; &#125; return sum; &#125;int main() &#123; int a,b,sum=0; while(cin &gt;&gt; a &amp;&amp; a!=0) &#123; b=a; //个人认为，这里只要三者相等即可，不一定为22 if((DBC(b,10)==DBC(b,16)) &amp;&amp; (DBC(b,10)==DBC(b,12))) cout&lt;&lt; a &lt;&lt; \" is a Sky Number.\" &lt;&lt; endl; else cout&lt;&lt; a &lt;&lt; \" is not a Sky Number.\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sinclaircoder.top/categories/数据结构与算法/"},{"name":"刷题","slug":"数据结构与算法/刷题","permalink":"https://sinclaircoder.top/categories/数据结构与算法/刷题/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"}],"author":"Sinclair"}]}