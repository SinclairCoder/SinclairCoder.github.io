{"meta":{"title":"SinclairのBlog","subtitle":"三寸旧城，七寸执念","description":"嚼得草根 做得大事","author":"SinclairWang","url":"https://sinclaircoder.top","root":"/"},"pages":[{"title":"about","date":"2019-08-03T00:33:24.000Z","updated":"2020-01-21T05:53:47.423Z","comments":true,"path":"about/index.html","permalink":"https://sinclaircoder.top/about/index.html","excerpt":"","text":"个人简介 00后学生党一枚 完美主义者，强迫症中期患者… 喜欢吃鱼，偶尔摸鱼，讨厌咸鱼 ~过于真实了~ 教育经历17级WIT本科SE在读 技术栈~啊，好像啥也不会~ 目前在学 JavaWeb ML 关于本站本站建于2019年8月1日，托管与Github Pages，用于积累技术、记录生活等。 Powered by: Hexo: 基础博客框架 Next: 基于 Hexo 的博客主题 Tidio: 在线聊天通信 LeanCloud: 数据云存储与后端支持 Valine: 文章评论组件 Busuanzi 数据统计分析 Algolia 站内搜索服务 Baidu Analytics: 网站监测与数据分析 Google Analytics: 网站监测与数据分析 ~足足配置两天~"},{"title":"friends","date":"2020-01-21T04:51:45.000Z","updated":"2020-01-21T04:52:57.207Z","comments":true,"path":"friends/index.html","permalink":"https://sinclaircoder.top/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-02T15:40:46.000Z","updated":"2020-01-21T05:56:32.020Z","comments":false,"path":"categories/index.html","permalink":"https://sinclaircoder.top/categories/index.html","excerpt":"","text":""},{"title":"top","date":"2019-08-03T07:03:32.000Z","updated":"2019-08-03T07:03:32.875Z","comments":true,"path":"top/index.html","permalink":"https://sinclaircoder.top/top/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-01-21T06:25:12.000Z","updated":"2020-01-21T06:25:47.181Z","comments":true,"path":"contact/index.html","permalink":"https://sinclaircoder.top/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-02T15:38:10.000Z","updated":"2020-01-21T05:53:07.081Z","comments":false,"path":"tags/index.html","permalink":"https://sinclaircoder.top/tags/index.html","excerpt":"","text":""},{"title":"动人音乐从音响缓缓流泄，洒落一地琉璃月光..","date":"2020-01-21T03:54:55.000Z","updated":"2020-01-21T04:50:10.967Z","comments":true,"path":"music/index.html","permalink":"https://sinclaircoder.top/music/index.html","excerpt":"","text":"var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"大雨降至\",\"author\":\"徐佳莹\",\"url\":\"https://music.163.com/#/song?id=29774430\",\"pic\":\"http://n.sinaimg.cn/transform/20141204/awzunex4966578.jpg\"},{\"title\":\"梦幻诛仙\",\"author\":\"张碧晨\",\"url\":\"https://music.163.com/#/song?id=438456232\",\"pic\":\"http://img5.iqilu.com/c/u/2016/1101/1477975989160.jpg\"},{\"title\":\"不再犹豫+体面\",\"author\":\"于文文\",\"url\":\"https://music.163.com/#/song?id=1407757605\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000001qYTzY2oyDyZ.jpg?max_age=2592000\"},{\"title\":\"何为永恒\",\"author\":\"胡夏\",\"url\":\"https://music.163.com/#/song?id=1348548038\",\"pic\":\"http://asset.q1xs.com/album/cover/008/yitiantulongji-2.jpg\"}]}; options.element = document.getElementById(\"aplayer-SuxzgJFH\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"}],"posts":[{"title":"PTA朋友圈(并查集)","slug":"2020-01-20-PTA朋友圈(并查集)","date":"2020-01-19T16:00:00.000Z","updated":"2020-01-22T04:35:46.061Z","comments":true,"path":"2020/01/20/2020-01-20-pta-peng-you-quan-bing-cha-ji/","link":"","permalink":"https://sinclaircoder.top/2020/01/20/2020-01-20-pta-peng-you-quan-bing-cha-ji/","excerpt":"","text":"某学校有N个学生，形成M个俱乐部。每个俱乐部里的学生有着一定相似的兴趣爱好，形成一个朋友圈。一个学生可以同时属于若干个不同的俱乐部。根据“我的朋友的朋友也是我的朋友”这个推论可以得出，如果A和B是朋友，且B和C是朋友，则A和C也是朋友。请编写程序计算最大朋友圈中有多少人。 输入格式:输入的第一行包含两个正整数N（≤30000）和M（≤1000），分别代表学校的学生总数和俱乐部的个数。后面的M行每行按以下格式给出1个俱乐部的信息，其中学生从1~N编号： 第i个俱乐部的人数Mi（空格）学生1（空格）学生2 … 学生Mi 输出格式:输出给出一个整数，表示在最大朋友圈中有多少人。 输入样例: 7 43 1 2 32 1 43 5 6 71 6 输出样例: 4 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;set&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; #define N 30005 int fa[N],num[N]; int find(int x){ if(x==fa[x]) return x; return fa[x] = find(fa[x]); } void Union(int x,int y){ int rootx = find(x),rooty = find(y); if(rootx!=rooty){ fa[rooty] = rootx; num[rootx] += num[rooty]; } } int main(){ int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;i++) { fa[i] = i;num[i]=1; } for(int i=0;i&lt;m;i++){ int cnt,root,x; cin &gt;&gt; cnt; cin &gt;&gt; root; for(int j=1;j&lt;cnt;j++) { cin &gt;&gt; x; Union(root,x); } } int res=1; for(int i=1;i&lt;=n;i++){ res = max(res,num[fa[i]]); } cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"},{"name":"并查集","slug":"并查集","permalink":"https://sinclaircoder.top/tags/并查集/"}],"author":"SinclairWang"},{"title":"PTA列出连通集(DFS+BFS)","slug":"2020-01-20-PTA列出连通集(DFS+BFS)","date":"2020-01-19T16:00:00.000Z","updated":"2020-01-22T04:38:55.987Z","comments":true,"path":"2020/01/20/2020-01-20-pta-lie-chu-lian-tong-ji-dfs-bfs/","link":"","permalink":"https://sinclaircoder.top/2020/01/20/2020-01-20-pta-lie-chu-lian-tong-ji-dfs-bfs/","excerpt":"","text":"给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。 输入格式:输入第1行给出2个整数N(0&lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。 输出格式:按照”{ v​1 v​2​​ … v​k​​ }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。 输入样例: 8 60 70 12 04 12 43 5 输出样例: { 0 1 4 2 7 }{ 3 5 }{ 6 }{ 0 1 2 7 4 }{ 3 5 }{ 6 } #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;set&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; #define N 15 int edge[N][N],vis[N]; queue&lt;int&gt; qu; void dfs(int x,int n){ vis[x] = 1; cout &lt;&lt; &quot; &quot; &lt;&lt; x; for(int i=0;i&lt;n;i++){ if(edge[x][i]&amp;&amp;!vis[i]) dfs(i,n); } } void bfs(int x,int n){ qu.push(x); vis[x] = 1; while(!qu.empty()){ int root = qu.front(); cout &lt;&lt; &quot; &quot; &lt;&lt; root; qu.pop(); for(int i=0;i&lt;n;i++){ if(edge[root][i]&amp;&amp;!vis[i]){ qu.push(i); vis[i] = 1; } } } } int main(){ int n,e,x,y; cin &gt;&gt; n &gt;&gt; e; for(int i=1;i&lt;=n;i++) { edge[i][i] = 1; } for(int i=0;i&lt;e;i++){ cin &gt;&gt; x &gt;&gt;y; edge[x][y] = 1; edge[y][x] = 1; } for(int i=0;i&lt;n;i++) { if(!vis[i]){ cout &lt;&lt; &quot;{&quot;; dfs(i,n); cout &lt;&lt; &quot; }&quot; &lt;&lt; endl; } } memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++){ if(!vis[i]) { cout &lt;&lt; &quot;{&quot;; bfs(i,n); cout &lt;&lt; &quot; }&quot; &lt;&lt; endl; } } return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"},{"name":"DFS","slug":"DFS","permalink":"https://sinclaircoder.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://sinclaircoder.top/tags/BFS/"}],"author":"SinclairWang"},{"title":"PTA汉密尔顿回路","slug":"2020-01-19-PTA汉密尔顿回路","date":"2020-01-18T16:00:00.000Z","updated":"2020-01-22T04:34:51.273Z","comments":true,"path":"2020/01/19/2020-01-19-pta-han-mi-er-dun-hui-lu/","link":"","permalink":"https://sinclaircoder.top/2020/01/19/2020-01-19-pta-han-mi-er-dun-hui-lu/","excerpt":"","text":"著名的“汉密尔顿（Hamilton）回路问题”是要找一个能遍历图中所有顶点的简单回路（即每个顶点只访问 1 次）。本题就要求你判断任一给定的回路是否汉密尔顿回路。 输入格式：首先第一行给出两个正整数：无向图中顶点数 N（2&lt;N≤200）和边数 M。随后 M 行，每行给出一条边的两个端点，格式为“顶点1 顶点2”，其中顶点从 1 到N 编号。再下一行给出一个正整数 K，是待检验的回路的条数。随后 K 行，每行给出一条待检回路，格式为：$n\\quad V_1\\quad V_2⋯ V_​n$ 其中 n 是回路中的顶点数，$V_i$是路径上的顶点编号。 输出格式：对每条待检回路，如果是汉密尔顿回路，就在一行中输出”YES”，否则输出”NO”。 输入样例： 6 106 23 41 52 53 14 11 66 31 24 567 5 1 4 3 6 2 56 5 1 4 3 6 29 6 2 1 6 3 4 5 2 64 1 2 5 17 6 1 3 4 5 2 67 6 1 2 5 4 3 1 输出样例： YESNONONOYESNO 思路：将边用数组存储起来，判断回路里两条边之前是否连通并且除出发点外其余点只出现一次。如果给定的回路里点的个数不等于n+1，直接NO #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;set&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; #define N 205 int edge[N][N]; int main(){ int n,m,x,y; cin &gt;&gt; n &gt;&gt; m; memset(edge,0,sizeof(edge)); for(int i=0;i&lt;m;i++){ cin &gt;&gt; x &gt;&gt; y; edge[x][y] = 1; edge[y][x] = 1; } int t,vis[n+1]; memset(vis,0,sizeof(vis)); cin &gt;&gt; t; while(t--){ int cnt,pre,flag=1,start; cin &gt;&gt; cnt; cin &gt;&gt; start; vis[start]=1;pre = start; for(int j=1;j&lt;cnt;j++){ cin &gt;&gt; x; if(!edge[pre][x]) flag = 0; // 判定条件要注意 if(vis[x]&amp;&amp;(j&lt;cnt-1||x!=start)) flag = 0; // if(vis[x]&amp;&amp;x!=start||!edge[pre][x]) flag = 0; vis[x]=1; pre = x; } if(cnt!=n+1) flag = 0; if(flag) cout&lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; memset(vis,0,sizeof(vis)); } return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"},{"name":"Hamilton回路","slug":"Hamilton回路","permalink":"https://sinclaircoder.top/tags/Hamilton回路/"}],"author":"SinclairWang"},{"title":"PTA哥尼斯堡的“七桥问题”（欧拉回路+并查集）","slug":"2020-01-19-PTA哥尼斯堡的“七桥问题”（欧拉回路+并查集）","date":"2020-01-18T16:00:00.000Z","updated":"2020-01-22T04:33:34.535Z","comments":true,"path":"2020/01/19/2020-01-19-pta-ge-ni-si-bao-de-qi-qiao-wen-ti-ou-la-hui-lu-bing-cha-ji/","link":"","permalink":"https://sinclaircoder.top/2020/01/19/2020-01-19-pta-ge-ni-si-bao-de-qi-qiao-wen-ti-ou-la-hui-lu-bing-cha-ji/","excerpt":"","text":"哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，可否走过这样的七座桥，而且每桥只走过一次？瑞士数学家欧拉(Leonhard Euler，1707—1783)最终解决了这个问题，并由此创立了拓扑学。这个问题如今可以描述为判断欧拉回路是否存在的问题。欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个无向图，问是否存在欧拉回路？ 输入格式:输入第一行给出两个正整数，分别是节点数N (1≤N≤1000)和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。 输出格式:若欧拉回路存在则输出1，否则输出0。 输入样例1: 6 101 22 33 14 55 66 41 41 63 43 6 输出样例1:1 输入样例2: 5 81 21 32 32 42 55 35 43 4 输出样例2: 0 思路：如果欧拉通路的起点与终点一样，则成为欧拉回路， 连通的多重图具有欧拉回路当且仅当它的每个顶点都有偶数度则欧拉回路的条件： 图是连通的，没有孤立节点 无向图的每个节点的度数都是偶数度，有向图每个节点的入度等于出度 使用并查集统计连通分量个数，使用degree数组奇偶数判断是否全为偶数。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;set&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; int fa[1005]; int father(int x){ if(fa[x]==x) return x; return fa[x] = father(fa[x]); } int main(){ int n,m,x,y; cin &gt;&gt; n &gt;&gt; m; int degree[n+1]; for(int i=1;i&lt;=n;i++) fa[i] = i; memset(degree,0,sizeof(degree)); for(int i=0;i&lt;m;i++){ cin &gt;&gt; x &gt;&gt; y; int rootx = father(x),rooty = father(y); if(rootx!=rooty){ fa[rooty] = rootx; } // fa[father(y)] = father(x); 这样写竟然会超时！！！！ // 不要问我咋知道的 degree[x]++; degree[y]++; } int exist=1,root = fa[1],connectcnt = 0; for(int i=1;i&lt;=n;i++){ if(fa[i]==i) connectcnt++; } if(connectcnt&gt;1) exist = 0; for(int i=1;i&lt;=n;i++){ if(degree[i]%2){ exist = 0;break; } } cout &lt;&lt; exist &lt;&lt; endl; return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"},{"name":"欧拉回路","slug":"欧拉回路","permalink":"https://sinclaircoder.top/tags/欧拉回路/"},{"name":"并查集","slug":"并查集","permalink":"https://sinclaircoder.top/tags/并查集/"}],"author":"SinclairWang"},{"title":"PTA小字辈（BFS）","slug":"2020-1-19-PTA小字辈（BFS）","date":"2020-01-18T16:00:00.000Z","updated":"2020-01-22T04:32:14.073Z","comments":true,"path":"2020/01/19/2020-1-19-pta-xiao-zi-bei-bfs/","link":"","permalink":"https://sinclaircoder.top/2020/01/19/2020-1-19-pta-xiao-zi-bei-bfs/","excerpt":"","text":"本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。 输入格式：输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父/母。家谱中辈分最高的老祖宗对应的父/母编号为 -1。一行中的数字间以空格分隔。 输出格式：首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。 输入样例： 92 6 5 5 -1 5 6 4 7 输出样例： 41 9 其实主要是存储的数据结构的设计。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;set&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; struct node{ int father; vector&lt;int&gt; child; }family[100005]; queue&lt;int&gt; qu; vector&lt;int&gt; level; int maxh = 1; void bfs(int root){ qu.push(root); level[root] = 1; while(qu.size()){ int index = qu.front(); qu.pop(); vector&lt;int&gt; tmp = family[index].child; for(int i=0;i&lt;tmp.size();i++){ level[tmp[i]] = level[index]+1; maxh = max(level[tmp[i]],maxh); qu.push(family[index].child[i]); } } } int main(){ int n,x,root; cin &gt;&gt; n; level.resize(n+1); for(int i=1;i&lt;=n;i++){ cin &gt;&gt; family[i].father; if(family[i].father==-1) root = i; else { family[family[i].father].child.push_back(i); } } bfs(root); cout &lt;&lt; maxh &lt;&lt; endl; int first = 1; for(int i=1;i&lt;=n;i++){ if(level[i]==maxh){ if(first) { cout &lt;&lt; i ; first = 0; } else cout &lt;&lt; &quot; &quot; &lt;&lt; i ; } } return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"},{"name":"BFS","slug":"BFS","permalink":"https://sinclaircoder.top/tags/BFS/"}],"author":"SinclairWang"},{"title":"PTA打印学生选课清单(哈希表)","slug":"2020-01-18-PTA打印学生选课清单(哈希表)","date":"2020-01-17T16:00:00.000Z","updated":"2020-01-22T04:30:51.009Z","comments":true,"path":"2020/01/18/2020-01-18-pta-da-yin-xue-sheng-xuan-ke-qing-dan-ha-xi-biao/","link":"","permalink":"https://sinclaircoder.top/2020/01/18/2020-01-18-pta-da-yin-xue-sheng-xuan-ke-qing-dan-ha-xi-biao/","excerpt":"","text":"假设全校有最多40000名学生和最多2500门课程。现给出每门课的选课学生名单，要求输出每个前来查询的学生的选课清单。 输入格式:输入的第一行是两个正整数：N（≤40000），为前来查询课表的学生总数；K（≤2500），为总课程数。此后顺序给出课程1到K的选课学生名单。格式为：对每一门课，首先在一行中输出课程编号（简单起见，课程从1到K编号）和选课学生总数（之间用空格分隔），之后在第二行给出学生名单，相邻两个学生名字用1个空格分隔。学生姓名由3个大写英文字母+1位数字组成。选课信息之后，在一行内给出了N个前来查询课表的学生的名字，相邻两个学生名字用1个空格分隔。 输出格式:对每位前来查询课表的学生，首先输出其名字，随后在同一行中输出一个正整数C，代表该生所选的课程门数，随后按递增顺序输出C个课程的编号。相邻数据用1个空格分隔，注意行末不能输出多余空格。 输入样例: 10 51 4ANN0 BOB5 JAY9 LOR62 7ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR63 1BOB54 7BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE15 9AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 输出样例: ZOE1 2 4 5ANN0 3 1 2 5BOB5 5 1 2 3 4 5JOE4 1 2JAY9 4 1 2 4 5FRA8 3 2 4 5DON2 2 4 5AMY7 1 5KAT3 3 2 4 5LOR6 4 1 2 4 5 思路：哈希表的应用，根据名字生成索引，然后将课程号记录。不过要注意，需要使用scanf输入，不能使用cin，否则会超时。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;set&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; #define N 102 int hashfun(char s[5]){ return (s[3]-&#39;0&#39;)+(s[2]-&#39;A&#39;)*10+(s[1]-&#39;A&#39;)*260+(s[0]-&#39;A&#39;)*26*260; } vector&lt;int&gt; course[26*26*26*11]; int main(){ int n,k,index,cnt; cin &gt;&gt; n &gt;&gt; k; char name[5]; for(int i=0;i&lt;k;i++){ scanf(&quot;%d%d&quot;,&amp;index,&amp;cnt); // cin &gt;&gt; index &gt;&gt; cnt; for(int j=0;j&lt;cnt;j++){ scanf(&quot;%s&quot;,name); // cin &gt;&gt; name; int h = hashfun(name); course[h].push_back(index); } } for(int i=0;i&lt;n;i++){ scanf(&quot;%s&quot;,name); // cin &gt;&gt; name; int h = hashfun(name); cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; course[h].size(); if(course[h].size()) { // 谁能想到还要排序.. sort(course[h].begin(),course[h].end()); for(int j=0;j&lt;course[h].size();j++){ cout &lt;&lt; &quot; &quot; &lt;&lt; course[h][j]; } } cout &lt;&lt; endl; } return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"},{"name":"哈希表","slug":"哈希表","permalink":"https://sinclaircoder.top/tags/哈希表/"}],"author":"SinclairWang"},{"title":"PTA列车调度","slug":"2020-01-17-PTA列车调度","date":"2020-01-16T16:00:00.000Z","updated":"2020-01-22T04:30:45.342Z","comments":true,"path":"2020/01/17/2020-01-17-pta-lie-che-diao-du/","link":"","permalink":"https://sinclaircoder.top/2020/01/17/2020-01-17-pta-lie-che-diao-du/","excerpt":"","text":"两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有N条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？ 输入格式：输入第一行给出一个整数N ($2 ≤ N ≤10^5$​​ )，下一行给出从1到N的整数序号的一个重排列。数字间以空格分隔。 输出格式：在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。 输入样例： 98 4 2 5 3 9 1 6 7 输出样例：4 样例解释：样例中的四条轨道如下：第一条：2 4 8第二条：1 3 5第三条：6 9第四条：7利用stl中的set自动排序的特性，每次查找大于当前值的数，如果有就用当前值替换，没有就插入，最后集合的大小便为结果。 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;set&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; #define N 1000002 int main(){ int n,num; cin &gt;&gt; n; set&lt;int&gt; s; set&lt;int&gt;::iterator it; for(int i=0;i&lt;n;i++){ cin &gt;&gt; num; it = s.upper_bound(num); if(it!=s.end()){ s.erase(it); } s.insert(num); } cout &lt;&lt; s.size(); return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"}],"author":"SinclairWang"},{"title":"PTA求前缀表达式的值","slug":"2020-01-16-PTA求前缀表达式的值","date":"2020-01-15T16:00:00.000Z","updated":"2020-01-22T04:30:58.324Z","comments":true,"path":"2020/01/16/2020-01-16-pta-qiu-qian-zhui-biao-da-shi-de-zhi/","link":"","permalink":"https://sinclaircoder.top/2020/01/16/2020-01-16-pta-qiu-qian-zhui-biao-da-shi-de-zhi/","excerpt":"","text":"算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3(7-4)+8/4的前缀表达式是：+ + 2 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。 输入格式:输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。 输出格式:输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。 输入样例:+ + 2 * 3 - 7 4 / 8 4 输出样例:13.0 思路一参考：【表达式转换 (25 分)】上面这篇文章写的很清楚，思路很清晰当栈为空或者栈顶运算符的优先级小于当前二元运算符的优先级时，将该二元运算符导入。倘若栈顶运算符的优先级大于或等于当前二元运算符的优先级，又分为以下两种情况，1.若栈顶运算符为（ 符号，则直接将该运算符插入即可； 2.若栈顶运算符不是（ 符号，则优先输出栈内的元素,直到碰到（ 符号或者栈为空，然后将当前二元运算符插入。 实现一#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; #define N 205 int main(){ string s; cin &gt;&gt; s; stack&lt;char&gt; st; map&lt;char,int&gt; mp; mp[&#39;+&#39;]=1;mp[&#39;-&#39;]=1; mp[&#39;*&#39;]=2;mp[&#39;/&#39;]=2; mp[&#39;(&#39;]=3;mp[&#39;)&#39;]=3; int len = s.length(),first = 1; for(int i=0;i&lt;len;i++){ if((i==0||i&amp;s[i-1]==&#39;(&#39;)&amp;&amp;(s[i]==&#39;+&#39;||s[i]==&#39;-&#39;)){ if(!first) cout &lt;&lt; &quot; &quot;; // 正负号处理 if(s[i]==&#39;-&#39;) cout &lt;&lt; &quot;-&quot;; while(i+1&lt;len&amp;&amp;s[i+1]&gt;=&#39;0&#39;&amp;&amp;s[i+1]&lt;=&#39;9&#39;||s[i+1]==&#39;.&#39;){ i++; cout &lt;&lt; s[i]; } first = 0; } else if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;){ if(!first) cout &lt;&lt; &quot; &quot;; printf(&quot;%c&quot;,s[i]); while(i+1&lt;len&amp;&amp;s[i+1]&gt;=&#39;0&#39;&amp;&amp;s[i+1]&lt;=&#39;9&#39;||s[i+1]==&#39;.&#39;){ i++; cout &lt;&lt; s[i]; } first = 0; } else if(s[i]==&#39;)&#39;) { while(!st.empty()&amp;&amp;st.top()!=&#39;(&#39;){ printf(&quot; %c&quot;,st.top()); st.pop(); } if(st.top()==&#39;(&#39;) st.pop(); } else if(st.empty()||mp[s[i]]&gt;mp[st.top()]){ st.push(s[i]); } else { while(!st.empty()&amp;&amp;st.top()!=&#39;(&#39;){ printf(&quot; %c&quot;,st.top()); st.pop(); } st.push(s[i]); } } while(!st.empty()){ printf(&quot; %c&quot;,st.top()); st.pop(); } return 0; } 思路二前缀表达式求值步骤： 从右向左扫描表达式 遇到数字压入栈中 遇到运算符，弹出栈顶两个数，并进行计算，将结果入栈 重复上述2、3步骤，直到表达式最左端，最后的值即为表达式结果 实现二#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; #define N 1000002 int main(){ string s; getline(cin,s); stack&lt;double&gt; st; int len = s.length(); double num1,num2,cnt=10; for(int i=len-1;i&gt;=0;i--){ if(s[i]==&#39; &#39;) continue; else if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;||s[i]==&#39;.&#39;){ double tmp = s[i]-&#39;0&#39;; while(i&gt;=1&amp;&amp;(s[i-1]&gt;=&#39;0&#39;&amp;&amp;s[i-1]&lt;=&#39;9&#39;||s[i-1]==&#39;.&#39;||s[i-1]==&#39;-&#39;||s[i-1]==&#39;+&#39;)){ i--; if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;){ tmp += (s[i]-&#39;0&#39;)*cnt; cnt *= 10.0; }else if(s[i]==&#39;.&#39;){ tmp /= cnt; cnt = 1; }else if(s[i]==&#39;-&#39;){ tmp = -1*tmp; } } st.push(tmp); } else { num1 = st.top();st.pop(); num2 = st.top();st.pop(); switch(s[i]){ case &#39;+&#39;: num1 += num2;break; case &#39;-&#39;: num1 -= num2;break; case &#39;*&#39;: num1 *= num2;break; case &#39;/&#39;: if(num2==0){cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl;exit(0);} else num1 /= num2;break; } st.push(num1); } } printf(&quot;%.1lf&quot;,st.top()); return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://sinclaircoder.top/tags/字符串/"},{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"},{"name":"前缀表达式","slug":"前缀表达式","permalink":"https://sinclaircoder.top/tags/前缀表达式/"}],"author":"SinclairWang"},{"title":"《大数据智能》阅读笔记","slug":"2020-01-15-《大数据智能》阅读笔记","date":"2020-01-14T16:00:00.000Z","updated":"2020-01-22T04:31:10.867Z","comments":true,"path":"2020/01/15/2020-01-15-da-shu-ju-zhi-neng-yue-du-bi-ji/","link":"","permalink":"https://sinclaircoder.top/2020/01/15/2020-01-15-da-shu-ju-zhi-neng-yue-du-bi-ji/","excerpt":"","text":"博观而约取，厚积而薄发。 ——-苏轼 尽管书的名字是《大数据智能》，实则内容则是互联网时代的机器学习和自然语言处理技术的综述。对于nlper，读一读受益匪浅。抑或是仅仅当科普读物一读，也未尝不可。 深度学习应用分类 垃圾邮件过滤 图像分类 结构分类 句法分析 情感分析 机器翻译 分类 语言模型也是一个特殊的回归任务 知识图谱构建 大规模知识库 互联网链接数据 互联网网页文本数据 多数据源的知识融合 实体融合 关系融合 实例融合 应用 理解查询 自动问答 下一代的搜索引擎能直接回大人们提出的问题 文档表示 最简单的方案：将文档表示为基于知识图谱的一个子图，即用改文档中出现或涉及的实体及其关系所构成的图表示该文档 主要技术 实体链指 将互联网网页与实体之间建立链接关系。并不局限于实体与文本之间 实体识别 从文本中发现实体 实体消歧 关系抽取 从互联网网页文本中抽取实体 知识推理 知识表示：基础技术 前景与挑战 知识的类型与表示 知识获取 知识融合 知识应用 大数据系统高性能计算技术 超级计算机 计算节点 存储节点 管理节点 并行计算的系统支持 常见并行编程组件 Pthreads OpenMP xdfc 虚拟化技术 虚拟化技术是指创建虚拟的事物，包括计算机硬件平台、操作系统、存储设备、计算机网络，是云计算的支撑技术 云计算技术 美国国家标准技术研究所认为：云计算是通过网络使得一组可配置的计算资源（网络、计算机、存储、应用程序、服务等）能够在任何地点方便地、按需地进行访问的模型，资源的提供和释放可以快速完成，管理开销低，与提供商的交互简便易行 三种服务模型 软件即服务 Software as a Service SaaS 常见的有亚马逊的AWS、微软的Azure、阿里云 平台即服务 Platform as a Service PaaS 常见的有Google App Engine（GAE）、新浪App Engine、RedHat的OpenShift等 GAE给开发者提供了包括Python、Java、Go、php等多种语言的开发和运行环境，用于编写Web应用程序，开发者只需专注于应用程序的功能实现，部署到GAE后，应用程序的性能将由平台来保证 基础架构即服务 Infrastructure as a Service IaaS 根据受众进行分类 私有云 社区云 公有云 混合云 常见的云服务 Elastic Compute Cloud（EC2）虚拟云主机服务 Simple Storage Service（S3）基于Web服务的存储 Elastic Block Store（EBS）为EC2提供的持久化块存储 DynamoDB 可扩展、可延迟的NoSQL数据库服务 Relational Database Service（RDS）关系型数据库服务 Route53 高可靠的域名系统服务（DNS）服务 CloudFront 内容分发服务 Elastic MapReduce (EMR) 在EC2和S3的基础上用Hadoop搭建的MapReduce 基于分布式计算的大数据系统 Hadoop生态系统 HDFS（Hadoop Distributed File System） 分布式文件系统，将文件按一定大小切块，然后把每个块以多个副本的形式保存在不同的数据节点上 YARN（Yet Another Resource Negotiator） Hadoop的计算资源管理和调度系统，接受任务请求，并根据请求的需要来分配资源，调度任务的执行。 MapReduce Google提出的并行程序编程模型，适合对数据进行统计、分类等处理 HBase 基于列的分布式存储，数据以表的形式组织，每个表可以有很多行，每行可以有若干列簇，每个列簇可以包含多个列 HBase可作为数据仓库存储有一定结构的海量数据，数据可以发生修改，但不要很频繁，否则会影响效率 Hive、Pig 能够让用户用较为简便的方式来查询保存在HDFS或HBase中的数据 ZooKeeper 提供了编写分布式软件所需的常用工具 Tez 比MapReduce更一般化的数据流编程框架 Storm、S4 建立在Hadoop上的流式处理引擎 Mahout Hadoop实现的机器学习算法库，包括聚类、分类、推荐以及线性代数常用的算法 新版本的Mapout主要用一种支持线性代数操作的领域特定语言（Domain Specific Language DSL）来实现 Giraph 在Hadoop上实现了类似于Google的Pregel这样的图计算引擎，用于处理Web链接关系图、社交网络等类型的数据 Sqoop 一个命令行工具，用于在Hadoop和传统的关系型数据库之间传输数据 三种安装模式 单机模式 伪分布模式 全分布模式 Spark 设计核心：一种叫做可靠分布式数据集（Resilient Distributed Dataset，RDD）的数据结构 Spark SQL Spark Streaming 提供流式处理的功能 MLlib 机器学习算法库 GraphX Spark的图计算框架 典型的大数据基础架构 GFS Cosmos SCOPE 大规模图计算 分布式图计算框架 Pregel GraphLab 高效的单机图计算框架 GraphChi X-Stream GridGraph NoSQL 分类 基于列的存储 常见的有HBase 基于文档的存储 常见的有MongoDB、CouchDB 键值对存储 单机内存型 数据持久化在磁盘上，强调单机读写性能，数据一般按照键排序 常见的有Berkeley DB、LevelDB 单机内存型 数据主要存放在内存中，一般用作数据的缓存 常见的有memcached、redis 分布式 数据经划分后存放在不同的机器上，同一项数据可以在不同的机器上存有副本 常见的有Dynamo、Riak 图数据库 数据以图的形式组织，数据项是图中的顶点，每个顶点可以带属性，数据项之间的联系用边来表示，边上也可以带属性 常见的有Neo4j 多模型 同时支持上述若干模型，例如OrientDB、ArangoDB NoSQL的理解 一开始是No SQL 后来添加了对SQL的部分支持，变为Not only SQL MongoDB 基于文档的存储，数据以文档为单位组织 存储的数据分为数据库、集合和文档三级，一个数据库可以包含若干集合，而一个集合可以包含若干个文档 文档在表达上采用JSON格式 基本操作包括文档的插入、更新、删除和查询，另外还可以单独对文档的某个属性进行修改，还可以进行增加、倍增这样的原子操作 可以单机使用也可以在分布式的环境中使用 还具有一定的数据分析能力，可以对数据进行统计 智能问答问答技术对于用户提出的问题予以理解，并找到答案回答给用户。经典案例：Siri等，人工智能的一个重要分支：专家系统问答系统的输入部分即问题更不容易被计算机理解，输出部分需要更准确，此外答案的来源更加——即知识也多种多样，既有结构化的信息也有非结构化的信息，因此问答系统的难度更大问答系统的组成 问题理解 理解问题是什么，比如北京的温度是多少和太阳的温度是多少根本不是一个领域的问题 知识检索 答案生成 文本问答系统 最基本的一类问答系统 问题理解 问题理解的内容 常见分类体系：UIUC体系、Moldovan等人的分类体系、单层的平面分类和根据垂直领域的分类 问题理解的方法 最直观的方法：模板匹配策略。优点在于逻辑清晰可见，易于理解和编写，缺点在于形式固定，对于千变万化的自然语言不容易灵活适应 灵活的技术则要从词法、句法的分析入手，做词性标注，做句法分析，找出命名实体。 问题扩展 同义词造成的多样性 在词的级别上，可以借助《同义词词林》、知网（HowNet），这样的同义词词典及词语知识图谱可以扩展我们的词库 知识检索 非结构化信息检索 非结构化的信息，通常是指没有或很少标注的整篇文章组成的集合 最直观的理解便是使用搜索引擎，提取出问题的关键词，查询索引，找出与这些关键词相关的文档，最后经过筛选和提取步骤，生成最终答案 在挑选出的多篇文档的多个段落中，也需要找出更可能包含答案的段落或局部段落，也因此要对这些文本块排序 问答系统中的经典做法是采用标准基数排序，排序指标的常见的三个因素：相同顺序的关键词数目、最远关键词间距和未命中关键词数 结构化知识检索 主要侧重于一个实体的各个属性以及他们之间的关系 结构化知识分类 百科类知识 关系类知识 答案生成 可以考虑答案与问题的相似程度，如问题的关键词和答案词之间语义联系的远近，此外，答案与问题也可能存在句式的联系 社区问答系统 一些比较著名的有国外的Quora和国内的知乎、百度知道和搜狗问问等 社区问答系统的结构 问题理解 答案生成 相似问题检索 一般的问答系统是用问题检索，而社区问答中是用问题去找问题。问题的相似性问题与问题扩展所解决的问题是类似 的，同样需要词义的扩展、句式的扩展。 问题相似性度量的几种方式 模板匹配 基于统计机器翻译 基于词典的方法 主要是基于同近义词的知识来扩展关键词，从而识别相似问句 基于信息距离 可以借助信息论中的柯尔莫哥洛夫复杂性来定义一系列语义度量，来衡量两个问题语义的相似性 答案过滤 根据答案提供者的权威性选择答案 根据答案内容本身评估质量 多媒体问答系统（Multimedia Question Answering） 问答的内容不仅仅限于纯文本内容，多媒体内容的表现力更强、更直观，易于理解 需要计算机视觉、信号处理等多媒体技术，才能分析出多媒体所表达的内容，属于比较前沿的课题 体会 对话系统比问答系统更难，问答系统涉及的技术较多，既包含语义分析，又有信息检索，还涉及到知识的挖掘与管理，若想成为全才，必须在方方面面都下功夫 自然语言处理基本任务 文档分类 文档摘要 关键词抽取","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://sinclaircoder.top/categories/阅读笔记/"}],"tags":[{"name":"前沿科普","slug":"前沿科普","permalink":"https://sinclaircoder.top/tags/前沿科普/"}],"author":"SinclairWang"},{"title":"PTA整数分解为若干项之和","slug":"2020-01-04-PTA整数分解为若干项之和","date":"2020-01-03T16:00:00.000Z","updated":"2020-01-22T04:17:19.707Z","comments":true,"path":"2020/01/04/2020-01-04-pta-zheng-shu-fen-jie-wei-ruo-gan-xiang-zhi-he/","link":"","permalink":"https://sinclaircoder.top/2020/01/04/2020-01-04-pta-zheng-shu-fen-jie-wei-ruo-gan-xiang-zhi-he/","excerpt":"","text":"Problem将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如7=6+1，7=5+2，7=5+1+1，…。编程求出正整数N的所有整数分解式子。 输入格式：每个输入包含一个测试用例，即正整数N (0&lt;N≤30)。 输出格式：按递增顺序输出N的所有整数分解式子。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。 输入样例： 7 输出样例： 7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+27=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+27=1+2+4;7=1+3+3;7=1+6;7=2+2+37=2+5;7=3+4;7=7 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;map&gt; using namespace std; #define rep(i,m,n) for(int i=m;i&lt;n;i++) #define rep1(i,m,n) for(int i=m;i&gt;=n;i--) int res[1000]; int n,pos,sum,cnt; void dfs(int x){ if(sum==n){ cnt++; cout &lt;&lt; n &lt;&lt; &quot;=&quot; &lt;&lt; res[0]; for(int i=1;i&lt;pos;i++){ if(res[i]) cout &lt;&lt; &quot;+&quot; &lt;&lt; res[i]; } // 每四个一换行，当到了最后一个也要换行，不能输出分号 if(cnt%4==0&amp;&amp;cnt||res[pos-1]==n) cout &lt;&lt; endl; else cout &lt;&lt; &quot;;&quot;; return ; } else if(sum&gt;n) return ; for(int i=x;i&lt;=n;i++){ res[pos++] = i; sum += i; dfs(i); sum -= i; pos--; } } int main(){ cin &gt;&gt; n; dfs(1); return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://sinclaircoder.top/tags/DFS/"}],"author":"SinclairWang"},{"title":"","slug":"00","date":"2019-12-31T16:00:00.000Z","updated":"2020-01-22T04:39:02.412Z","comments":true,"path":"2020/01/01/00/","link":"","permalink":"https://sinclaircoder.top/2020/01/01/00/","excerpt":"","text":"","categories":[],"tags":[],"author":"SinclairWang"},{"title":"PTA列出叶结点(BFS)","slug":"2020-01-19-PTA列出叶结点(BFS)","date":"2019-12-31T16:00:00.000Z","updated":"2020-01-22T04:30:39.298Z","comments":true,"path":"2020/01/01/2020-01-19-pta-lie-chu-xie-jie-dian-bfs/","link":"","permalink":"https://sinclaircoder.top/2020/01/01/2020-01-19-pta-lie-chu-xie-jie-dian-bfs/","excerpt":"","text":"对于给定的二叉树，本题要求你按从上到下、从左到右的顺序输出其所有叶节点。 输入格式：首先第一行给出一个正整数 N（≤10），为树中结点总数。树中的结点从 0 到 N−1 编号。随后 N 行，每行给出一个对应结点左右孩子的编号。如果某个孩子不存在，则在对应位置给出 “-“。编号间以 1 个空格分隔。 输出格式：在一行中按规定顺序输出叶节点的编号。编号间以 1 个空格分隔，行首尾不得有多余空格。 输入样例：8 1 - - - 0 - 2 7 - - - - 5 - 4 6 输出样例： 4 1 5 实现：题意理解了半天… 开个标记数组，在叶子左右孩子节点中出现过的就进行标记。剩下的那一个就是root，然后在进行BFS #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;set&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; struct node{ int leaf ; int right; }q[15]; queue&lt;int&gt; qu; int res[15],top=0; void bfs(){ while(qu.size()){ int num = qu.front(); qu.pop(); if(q[num].leaf==-1&amp;&amp;q[num].right==-1) res[top++] = num; if(q[num].leaf!=-1) qu.push(q[num].leaf); if(q[num].right!=-1) qu.push(q[num].right); } } int main(){ int n,root; cin &gt;&gt; n; getchar(); int flag[n]; char a,b; memset(q,0,sizeof(q)); memset(flag,0,sizeof(flag)); for(int i=0;i&lt;n;i++){ scanf(&quot;%c %c&quot;,&amp;a,&amp;b); getchar(); if(a==&#39;-&#39;) q[i].leaf=-1; else { q[i].leaf = a-&#39;0&#39;;flag[q[i].leaf] = 1; } if(b==&#39;-&#39;) q[i].right=-1; else { q[i].right = b-&#39;0&#39;;flag[q[i].right] = 1; } } for(int i=0;i&lt;n;i++){ if(flag[i]==0){ root = i; break; } } qu.push(root); bfs(); cout &lt;&lt; res[0]; for(int i=1;i&lt;top;i++){ cout &lt;&lt; &quot; &quot; &lt;&lt; res[i]; } return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"},{"name":"BFS","slug":"BFS","permalink":"https://sinclaircoder.top/tags/BFS/"}],"author":"SinclairWang"},{"title":"PTA切分表达式——写个tokenizer吧","slug":"2020-01-16-PTA切分表达式——写个tokenizer吧","date":"2019-12-31T16:00:00.000Z","updated":"2020-01-22T04:31:05.514Z","comments":true,"path":"2020/01/01/2020-01-16-pta-qie-fen-biao-da-shi-xie-ge-tokenizer-ba/","link":"","permalink":"https://sinclaircoder.top/2020/01/01/2020-01-16-pta-qie-fen-biao-da-shi-xie-ge-tokenizer-ba/","excerpt":"","text":"[先说点出题背景]这个题是为低年级同学、学C语言的同学准备的，因为，对这部分同学，这个题目编写起来略有一点复杂。如果是高年级、学过了正则表达式（Regular Expression）的同学或者学过了Java等OO语言的同学做这个题，应当发现这题比较简单吧。哦，对了，什么是tokenizer？请自行查询解决。反正在此处不应翻译成“令牌解析器”。 [正题]四则运算表达式由运算数（必定包含数字，可能包含正或负符号、小数点）、运算符（包括+、-、*、/）以及小括号（(和)）组成，每个运算数、运算符和括号都是一个token（标记）。现在，对于给定的一个四则运算表达式，请把她的每个token切分出来。题目保证给定的表达式是正确的，不需要做有效性检查。输入格式:在一行中给出长度不超过40个字符的表达式，其中没有空格，仅由上文中token的字符组成 输出格式:依次输出表达式中的tokens，每个token占一行。 输入样例: 32*((2-2)+5)/(-15) 输出样例:```32*((2-2)+5)/(-15) ## 实现 ```cpp #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;list&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; #define N 205 int main(){ char s[N],ch; int flag = 0; scanf(&quot;%s&quot;,s); printf(&quot;%c&quot;,s[0]); for(int i=1;i&lt;strlen(s);i++){ if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;||s[i]==&#39;.&#39;){ if(flag) cout &lt;&lt; endl; printf(&quot;%c&quot;,s[i]); flag = 0; } else { if(s[i-1]==&#39;(&#39;&amp;&amp;s[i]==&#39;-&#39;){ printf(&quot;\\n%c&quot;,s[i]); flag = 0; } else { printf(&quot;\\n%c&quot;,s[i]); flag = 1; } } } return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://sinclaircoder.top/tags/字符串/"},{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"}],"author":"SinclairWang"},{"title":"2019蓝桥杯校内选拔赛题解","slug":"2019-12-10-2019蓝桥杯校内选拔赛题解","date":"2019-12-09T16:00:00.000Z","updated":"2020-01-22T04:14:08.300Z","comments":true,"path":"2019/12/10/2019-12-10-2019-lan-qiao-bei-xiao-nei-xuan-ba-sai-ti-jie/","link":"","permalink":"https://sinclaircoder.top/2019/12/10/2019-12-10-2019-lan-qiao-bei-xiao-nei-xuan-ba-sai-ti-jie/","excerpt":"","text":"题目传送A Perfect略 B Common(Easy Version)详见Common(Easy、Middle 、Hard) C Common(Hard Version)详见Common(Easy、Middle 、Hard) D Treasure有一个 n 行 m 列的迷宫， 行数从上到下为 1 到 n, 列数从左到右为 1 到 m, 入口为 (1,1),Reverie只能向上下左右四个方向行走。迷宫中有若干个宝箱。Reverie想知道，最少需要走多少步，才能找到一个宝箱。 第一行两个正整数 n, m, 表示迷宫的行数和列数。之后 n 行，每行 m 个字符, ‘.’ 表示该位置是空地, ‘*’ 表示该位置是障碍, ‘#’ 表示该位置有一个宝箱。保证点 (1,1) 是空地，宝箱所在的格子可以通过。$1≤n,m≤1000$一行内输出一个整数表示答案，如果没有宝箱或者所有宝箱位置均不可达，输出 -1. BFS #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define mp make_pair #define pb push_back ll gcd(ll a,ll b) { return !b?a:gcd(b,a%b);} ll lcm(ll a,ll b){ return a/gcd(a,b)*b;} int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1}; int cnt = 0; int r[1000+5][1000+5]; bool visited[1000+5][1000+5]; int res[1000+5][1000+5]; bool bfs(int i,int j){ queue&lt;pair&lt;int,int &gt; &gt; q; q.push(mp(i,j));visited[i][j] = 1; pair&lt;int,int&gt; t; while(!q.empty()){ t = q.front(); i = t.first; j = t.second; q.pop(); for(int k=0;k&lt;4;k++){ int cx = i+dx[k],cy = j+dy[k]; if(r[cx][cy]&amp;&amp;!visited[cx][cy]){ cnt = res[i][j]+1; res[cx][cy] = cnt; visited[cx][cy]=1; if(r[cx][cy]==2) return true; else q.push(mp(cx,cy)); } } } return false; } int main(){ int n,m; cin &gt;&gt; n &gt;&gt; m; memset(visited,0,sizeof(visited)); memset(r,0,sizeof(r)); char c; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ cin &gt;&gt; c; if(c==&#39;.&#39;) r[i][j] = 1; else if(c==&#39;#&#39;) r[i][j] = 2; } if(bfs(1,1)) cout &lt;&lt; cnt &lt;&lt; endl; else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; return 0; } E Select$Reverie有一个长度为 n 的正整数数组 A, 她想从中挑出一些数字，$$使得这些数字的和最大，选中的任意两个数字在原数组中不能相邻。$ $第一行一个正整数 T, 代表测试的组数。$$每组测试第一行一个正整数 n 表示数组的大小，第二行 n 个正整数表示数组里的数，以空格分隔。$$1≤T≤100$$1≤n≤1000$$1≤A_i≤1000$ 状态转移方程：$dp[0]=a[0],dp[1]=max(a[0],a[1])$$dp[i]=max(dp[i-1],dp[i-2]+a[i])$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main(){ int T; cin &gt;&gt; T; while(T--){ int n; cin &gt;&gt; n; int a[n],dp[n+2]; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i]; dp[0] = a[0]; dp[1] = max(a[0],a[1]); for(int i=2;i&lt;n;i++) dp[i] = max(dp[i-2]+a[i],dp[i-1]); cout &lt;&lt; dp[n-1] &lt;&lt; endl; } return 0; } F Swap(Easy Vesion)$Reverie有一个字符串，她每次操作可以交换其中任意相邻两个字符的位置。$$Reveire想知道，把这个字符串变成字典序最小至少需要多少次操作。$$第一行一个正整数 T, 代表测试的组数。$$每组测试，一行内给出一个仅包含小写字母的字符串 s。$$1≤T≤10$$1≤∣s∣≤1000$ 最小交换次数即逆序对数下面使用两重循环暴力求解 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll res = 0 ; char a[1000005]; int main(){ int t; cin &gt;&gt; t; getchar(); while(t--){ res = 0; scanf(&quot;%s&quot;,a); int n = strlen(a); for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;i;j++){ if(a[j]&gt;a[i]){ res ++; } } } cout &lt;&lt; res &lt;&lt; endl; } return 0; } G Swap(Hard Vesion)数据范围改变$1≤T≤10$$1≤∣s∣≤100000$暴力不可行，会超时，使用归并排序求逆序对数 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; /* 归并排序求逆序对 */ ll res = 0 ; char a[1000005]; char b[1000005]; void merge(char a[],int low,int mid,int high){ int i = low,j = mid +1,k = 0; while(i&lt;=mid&amp;&amp;j&lt;=high){ if((a[i]-&#39;a&#39;)&lt;=(a[j]-&#39;a&#39;)) b[k++] = a[i++]; else { b[k++] = a[j++]; res += (mid-i+1); // 是mid-i+1 而非j-i } } while(i&lt;=mid){ b[k++] = a[i++]; } while(j&lt;=high){ b[k++] = a[j++]; } k = 0; for(i=low;i&lt;=high;i++,k++){ a[i] = b[k]; } } void merge_sort(char a[],int low, int high){ int mid; if(low &lt; high){ mid = (low+high)/2; merge_sort(a,low,mid); merge_sort(a,mid+1,high); merge(a,low,mid,high); } } int main(){ int t; cin &gt;&gt; t; getchar(); while(t--){ res = 0; scanf(&quot;%s&quot;,a); merge_sort(a,0,strlen(a)-1); cout &lt;&lt; res &lt;&lt; endl; } return 0; } H Operator$Reverie有一个长度为n的整数数组A，她想在每两个数之间填入$$‘+’ 或者 ‘-’, 使得最终运算结果尽可能接近给定的评估值 k.$ $Input$$第一行一个正整数 T, 代表测试的组数。$$每组测试，第一行两个整数 n, k 分别表示数组的大小和给定的评估值，$$第二行 n 个正整数表示数组里的数，以空格分隔。$ $1≤T≤10$$2≤n≤20$$1≤k,A_i≤10^6$ $Output$$每组测试，一行内输出一个整数表示运算结果与 k 的差值的绝对值的最小值。$ $Sample Input$ 23 73 6 94 61 2 3 4 $Sample Output$ 10 DFS即可 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll inf = 0x3f3f3f3f; const int maxn = 200; char best[maxn]; void dfs(int a[],int n,int sum,int i,char op[],int tar){ if(i==n){ if(abs(sum-tar)&lt;abs(inf-tar)){ inf = sum; for(int i=1;i&lt;n;i++) best[i] = op[i]; } return ; } sum += a[i]; op[i] = &#39;+&#39;; dfs(a,n,sum,i+1,op,tar); sum -= a[i]; sum -= a[i]; op[i] = &#39;-&#39;; dfs(a,n,sum,i+1,op,tar); sum += a[i]; } int main(){ int t; cin &gt;&gt; t; getchar(); while(t--){ int n; cin &gt;&gt; n; ll tar; cin &gt;&gt; tar; int a[n]; for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i]; char op[n]; dfs(a,n,a[0],1,op,tar); ll res = a[0]; for(int i=1;i&lt;n;i++){ if(best[i]==&#39;+&#39;) res += a[i]; else if(best[i]==&#39;-&#39;) res -= a[i]; } cout &lt;&lt; abs(res-tar) &lt;&lt; endl; inf = 0x3f3f3f3f; // 记得修改inf的值 } return 0; }","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/categories/蓝桥杯/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/tags/蓝桥杯/"}],"author":"SinclairWang"},{"title":"Common (Easy、Middle 、Hard)","slug":"2019-12-06-Common(Easy、Middle 、Hard)","date":"2019-12-05T16:00:00.000Z","updated":"2020-01-22T04:15:30.165Z","comments":true,"path":"2019/12/06/2019-12-06-common-easy-middle-hard/","link":"","permalink":"https://sinclaircoder.top/2019/12/06/2019-12-06-common-easy-middle-hard/","excerpt":"","text":"一道题 Easy Version题目描述$求区间 [l, r] 内是 a 或 b 的倍数的数的个数。$ Input$第一行一个正整数 T, 代表测试的组数。$$之后 T 行，每行四个正整数 a, b, l, r, 以空格分隔，意义如题面所述。$$1≤T≤100$$1≤a,b≤10^5$$1≤l≤r≤10^5$ Output$对于每组测试，一行内输出一个整数表示答案。$ Sample Input 32 3 1 1004 6 1 1005 10 1 100 Sample Output 673320 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int l,r,a,b; int n; cin &gt;&gt; n; while(n--){ cin &gt;&gt; a &gt;&gt; b; cin &gt;&gt; l &gt;&gt; r; int res = 0; for(int i=l;i&lt;=r;i++){ if(i%a==0||i%b==0) res ++; } cout &lt;&lt; res &lt;&lt; endl; } return 0; } Middle Version数据范围改变$1≤T≤100$$1≤a,b≤10^9$$1≤l≤r≤10^9$需要优化 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll gcd(ll a,ll b) { return !b?a:gcd(b,a%b);} ll lcm(ll a,ll b){ return a/gcd(a,b)*b;} int main(){ int n; cin &gt;&gt; n; while(n--){ ll a,b,l,r; cin &gt;&gt; a &gt;&gt; b; cin &gt;&gt; l &gt;&gt; r; ll res = 0; ll t = lcm(a,b); res += r/a+r/b-r/t-(l/a+l/b-l/t); if(l%a==0||l%b==0){ res ++; } cout &lt;&lt; res &lt;&lt; endl; } return 0; } Hard Version$区间[l,r]内, 是a或b倍数的数的和是多少?$$1≤a,b≤10^9$$1≤l≤r≤10^9$ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll gcd(ll a,ll b) { return !b?a:gcd(b,a%b);} ll lcm(ll a,ll b){ return a/gcd(a,b)*b;} int main(){ ll a,b,l,r; cin &gt;&gt; a &gt;&gt; b; cin &gt;&gt; l &gt;&gt; r; ll res = 0; ll t = lcm(a,b); ll c1 = r/a,c2 = r/b,c3 = r/t; ll c4 = (l-1)/a,c5 = (l-1)/b,c6 = (l-1)/t; res += (a+c1*a)*c1/2+(b+c2*b)*c2/2-(t+c3*t)*c3/2; res -= (a+c4*a)*c4/2+(b+c5*b)*c5/2-(t+c6*t)*c6/2; cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/categories/蓝桥杯/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://sinclaircoder.top/tags/组合数学/"},{"name":"暴力","slug":"暴力","permalink":"https://sinclaircoder.top/tags/暴力/"}],"author":"SinclairWang"},{"title":"回溯法求解幂集","slug":"2019-11-29-回溯法求解幂集","date":"2019-11-28T16:00:00.000Z","updated":"2020-01-22T04:06:50.303Z","comments":true,"path":"2019/11/29/2019-11-29-hui-su-fa-qiu-jie-mi-ji/","link":"","permalink":"https://sinclaircoder.top/2019/11/29/2019-11-29-hui-su-fa-qiu-jie-mi-ji/","excerpt":"","text":"回溯—使用解向量使用一个大小为n的数组x，来标记解向量，在每次迭代过程重要要么选择当前值，要么不选择 #include&lt;bits/stdc++.h&gt; using namespace std; void print(int a[], int x[], int n){ cout &lt;&lt; &quot;{&quot;; for(int i=0;i&lt;n;i++){ if(x[i]) printf(&quot;%d &quot;,a[i]); } cout &lt;&lt; &quot;}&quot; &lt;&lt; endl; cout &lt;&lt; endl; } void dfs(int a[], int x[], int n, int i){ if(i&gt;=n) { print(a,x,n);return ; } else{ x[i] = 0; dfs(a,x,n,i+1); x[i] = 1; dfs(a,x,n,i+1); } } int main(){ int n; cin &gt;&gt; n; int a[n]; for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i]; int x[n]; memset(x,0,sizeof(x)); dfs(a,x,n,0); return 0; } 回溯法—使用容器存放结果不去采用标准的解向量，而是用一个边长数组vector去存放解。 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i,m,n) for(int i=m;i&lt;n;i++) #define pb push_back int res = 0; void print(vector&lt;int&gt; v){ rep(i,0,v.size()){ cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void dfs(int a[], int n, int i, vector&lt;int&gt; path){ if(i&gt;=n){ print(path); res++; // 统计个数 return ; } else { dfs(a,n,i+1,path); path.pb(a[i]); dfs(a,n,i+1,path); } } int main(){ int n; cin &gt;&gt; n; int a[n]; rep(i,0,n) cin &gt;&gt; a[i]; vector&lt;int&gt; path; dfs(a,n,0,path); cout &lt;&lt; &quot;Total : &quot; &lt;&lt; res &lt;&lt; endl; return 0; } 枚举法—使用二进位对应解空间用二进制位来对应解 #include&lt;bits/stdc++.h&gt; using namespace std; #define rep(i,m,n) for(int i=m;i&lt;n;i++) #define pb push_back int res = 0; void print(int a[],int n,int x){ int j = 0; // 也可令j变为n,只是会调整输出顺序 cout &lt;&lt; &quot;{&quot;; while(x){ if(x&amp;1) { cout &lt;&lt; a[j]; if(x&gt;=2) cout &lt;&lt; &quot; &quot;; // 输出格式控制 } x &gt;&gt;= 1;j++; } cout &lt;&lt; &quot;}&quot;; cout &lt;&lt; endl; res++; } int main(){ int n; cin &gt;&gt; n; int a[n]; rep(i,0,n) cin &gt;&gt; a[i]; rep(i,0,1&lt;&lt;n){ print(a,n,i); } cout &lt;&lt; &quot;Total：&quot; &lt;&lt; res ; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"幂集问题","slug":"幂集问题","permalink":"https://sinclaircoder.top/tags/幂集问题/"},{"name":"回溯法","slug":"回溯法","permalink":"https://sinclaircoder.top/tags/回溯法/"}],"author":"SinclairWang"},{"title":"回溯算法求解数独问题(C++ 递归/非递归)","slug":"2019-11-29-回溯算法求解数独问题(C++ 递归非递归)","date":"2019-11-28T16:00:00.000Z","updated":"2020-01-22T04:05:23.457Z","comments":true,"path":"2019/11/29/2019-11-29-hui-su-suan-fa-qiu-jie-shu-du-wen-ti-c-di-gui-fei-di-gui/","link":"","permalink":"https://sinclaircoder.top/2019/11/29/2019-11-29-hui-su-suan-fa-qiu-jie-shu-du-wen-ti-c-di-gui-fei-di-gui/","excerpt":"","text":"如何使用求解上述数独? 递归实现#include&lt;bits/stdc++.h&gt; using namespace std; int sudoku[9][9]; int dx[9]= {-1,-1,-1,0,0,0,1,1,1},dy[9]={-1,0,1,-1,0,1,-1,0,1}; void print(){ for(int i=0;i&lt;9;i++){ for(int j=0;j&lt;9;j++) cout &lt;&lt; sudoku[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } } bool check(int i,int j, int num){ // (i,j)位置填入num判断是否合适 for(int k=0;k&lt;9;k++){ // 所在行和列判断 if(sudoku[i][k]==num||sudoku[k][j]==num){ return false; } } int cx = i/3*3+1, cy = j/3*3+1; for(int k=0;k&lt;9;k++){ // 九宫格 int cur_x = cx+dx[k],cur_y = cy+dy[k]; if(sudoku[cur_x][cur_y]==num) return false; } return true; } void search(int i,int j){ if(i==8&amp;&amp;j==9) { print(); return ; } if(j==9){ i++; j=0; } if(sudoku[i][j]==0){ for(int num=1;num&lt;=9;num++){ if(check(i,j,num)){ sudoku[i][j] = num; search(i,j+1); sudoku[i][j] = 0; } } } else search(i,j+1); } int main(){ for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++) cin &gt;&gt; sudoku[i][j]; search(0,0); return 0; } 非递归实现非递归回溯求解数独问题，每次在9*9的矩阵中按行优先寻找第一个不为0的位置并将该位置进栈，然后对该位置进行从num=1到9试填，并check该位置放num是否合适，如果不合适就将该点出栈，同时将值置为0，否则就放入num，然后将下一个0位置进栈… #include&lt;bits/stdc++.h&gt; using namespace std; int sudoku[9][9]; int dx[9]= {-1,-1,-1,0,0,0,1,1,1},dy[9]={-1,0,1,-1,0,1,-1,0,1}; void print(){ for(int i=0;i&lt;9;i++){ for(int j=0;j&lt;9;j++) cout &lt;&lt; sudoku[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } } bool check(int i,int j, int num){ // (i,j)位置填入num判断是否合适 for(int k=0;k&lt;9;k++){ // 所在行和列判断 if(sudoku[i][k]==num||sudoku[k][j]==num){ return false; } } int cx = i/3*3+1, cy = j/3*3+1; for(int k=0;k&lt;9;k++){ // 九宫格 int cur_x = cx+dx[k],cur_y = cy+dy[k]; if(sudoku[cur_x][cur_y]==num) return false; } return true; } int find(){ for (int i = 0;i&lt;81;i++) if (!sudoku[i/9][i%9]) return i; return -1; } bool solve(){ // 非递归回溯 stack&lt;int&gt; st; st.push(find()); int num; while(!st.empty()&amp;&amp;(st.top()&gt;=0)){ int x = st.top()/9, y = st.top()%9; for(num = sudoku[x][y]+1;num&lt;=9&amp;&amp;(!check(x,y,num));num++); if(num&gt;9){ sudoku[x][y] = 0; st.pop(); } else { sudoku[x][y] = num; st.push(find()); } } return (!st.empty()); } int main() { for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++) cin &gt;&gt; sudoku[i][j]; if(solve()){ print(); } else cout &lt;&lt; &quot;无解&quot; &lt;&lt; endl; return 0; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"回溯法","slug":"回溯法","permalink":"https://sinclaircoder.top/tags/回溯法/"},{"name":"数独","slug":"数独","permalink":"https://sinclaircoder.top/tags/数独/"}],"author":"SinclairWang"},{"title":"切面条","slug":"2019-11-22-切面条","date":"2019-11-21T16:00:00.000Z","updated":"2020-01-22T03:59:55.874Z","comments":true,"path":"2019/11/22/2019-11-22-qie-mian-tiao/","link":"","permalink":"https://sinclaircoder.top/2019/11/22/2019-11-22-qie-mian-tiao/","excerpt":"","text":"一道2014蓝桥杯省赛试题切面条 一根高筋拉面，中间切一刀，可以得到2根面条。 如果先对折1次，中间切一刀，可以得到3根面条。 如果连续对折2次，中间切一刀，可以得到5根面条。 那么，连续对折10次，中间切一刀，会得到多少面条呢？ 不切的话，一根面条原本有两个端点对折0次，中间切一刀，会产生1个端点，一共3个端点，会产生2根面条对折1次，中间切一刀，会产生2个端点，一共4个端点，会产生3根面条对折2次，中间切一刀，会产生4个端点，一共6个端点，会产生5根面条对折3次，中间切一刀，会产生8个端点，一共10个端点，会产生9根面条……假设对折n次，则中间切一刀，会产生$2^n$个端点，加上原来的两个，一共$2^n+2$个端点，会产生$2^n+2-1$根面条，也即产生的面条数等于端点数减一。即result = 2^n+1（证明略..）当n=10时，result = 1025","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/categories/蓝桥杯/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/tags/蓝桥杯/"}],"author":"SinclairWang"},{"title":"蓝桥杯集训笔记","slug":"2019-11-22-蓝桥杯集训笔记","date":"2019-11-21T16:00:00.000Z","updated":"2020-01-22T04:02:15.521Z","comments":true,"path":"2019/11/22/2019-11-22-lan-qiao-bei-ji-xun-bi-ji/","link":"","permalink":"https://sinclaircoder.top/2019/11/22/2019-11-22-lan-qiao-bei-ji-xun-bi-ji/","excerpt":"","text":"数学建模的思想几道题目 熊怪吃核桃—二进制的使用 切面条余数的使用余数运算对于加法、减法和乘法封闭，常用于循环队列等使用，也可以利用余数的性质大幅度简化编码常用场合：递推法，倒推法有很多经典的题目，比如猴子吃桃..猜字母（待补..） 统计某种运算的结果末尾0的个数统计因子中能被2和5整除的个数分别为n1,n2 result = min(n1,n2)毕达哥拉斯定理（勾股定理）可以直接利用$x^2+y^2=z^2$在正整数域构造基础解系 \\begin{cases}x=2k+1\\\\y=2k^2+2k\\\\ z = 2k^2+2k+1 \\\\ k = 1,2,3,... \\end{cases}另一种解系： \\begin{cases}x=st\\\\y=\\frac{t^2-s^2}{2}\\\\ z =\\frac{t^2+s^2}{2} \\\\ s =1,3,5,7.. \\\\ gcd(t,s)=1 \\end{cases}超长位数的处理 存储方式：字符串、整数数组（甚至采用整型数组紧缩存放，即数组中一个元素存放多位，输出的时候使用printf(“%nd”,x[i]); 存储格式：把低位放在前，高位放在后面，符号位和小数位单独处理，可使用标志变量 运算方式 C/C++使用数组模拟进行加减乘除，及时取余进位操作，小心溢出 java 中里面提供了两个类BigInteger，BigDecimal分别对应大整数、高精度小数的处理 。 tips：尽管是C/C++选手，假如遇到了大数运算的题目，又刚好是个填空题，不妨简单学下Java里面的这个两个类，甚至Date类（日期计算），求结果多快好省，何乐而不为？ 两个往年题目练习一下BigInteger，BigDecimal的使用 大数乘法 java BigInteger的使用 黄金连分数—BigDecimal的使用 RSA对应2019省赛A组题目RSA解密涉及的知识点如下 逆元 欧拉函数 快速幂 素数筛 扩展欧几里得算法 （待补..）","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/categories/蓝桥杯/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/tags/蓝桥杯/"}],"author":"SinclairWang"},{"title":"黄金连分数--BigDecimal的使用","slug":"2019-11-22-黄金连分数--BigDecimal的使用","date":"2019-11-21T16:00:00.000Z","updated":"2020-01-22T03:58:55.706Z","comments":true,"path":"2019/11/22/2019-11-22-huang-jin-lian-fen-shu-bigdecimal-de-shi-yong/","link":"","permalink":"https://sinclaircoder.top/2019/11/22/2019-11-22-huang-jin-lian-fen-shu-bigdecimal-de-shi-yong/","excerpt":"","text":"一道2013蓝桥杯省赛试题 黄金连分数 黄金分割数是0.61803是一个无理数，… 写出精确到小数点后100位精度的黄金分割数 \\frac{1}{1+\\frac{1}{1+\\frac{1}{1+\\frac{1}{1+\\frac{1}{1+\\frac{1}{1+}}}}}}当然黄金分割数是$\\frac{\\sqrt5-1}{2}$,可以直接算，但是Windows下的计算器的求解只能到小数点之后32位 思路当然这是一道填空题，只需要结果，假如你懂一点点java，又刚好知道BigDecimal这个类，那你就可以打开桌面的Eclipse轻松求解这个题目。 import java.math.BigDecimal; import java.math.BigInteger; import java.util.Scanner; public class BigDecimalLearning { public static void main(String[] args) { BigDecimal res = new BigDecimal(1); // 没有 new BigDecimal(BigDecimal.ONE); 这种构造方法 for(int i=0;i&lt;100;i++) { res = res.add(BigDecimal.ONE); res = BigDecimal.ONE.divide(res,105,BigDecimal.ROUND_HALF_UP); } String str = res.toString().substring(2, 102); System.out.println(str); // System.out.println(str.length()); } } 结果： 6180339887498948482045868343656381177203096998094118264936291294152016354093729191617385189497190563 简单介绍一下BigDecimalJava在java.math包中提供了BigDecimal类，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。常用方法如下： BigDecimal b1 = new BigDecimal(&quot;20&quot;); BigDecimal b2 = new BigDecimal(&quot;30&quot;); b1.add(b2) //加法，求两个BigDecimal类型数据的和。 b1.subtract(b2); //减法，求两个BigDecimal类型数据的差。 b1.multiply(b2); //乘法，求两个BigDecimal类型数据的积。 b1.remainder(b2); //求余数，求b1除以b2的余数。 b1.max(b2); //最大数，求两个BigDecimal类型数据的最大值 b1.min(b2); //最小数，求两个BigDecimal类型数据的最小值。 bi.abs(); //绝对值，求BigDecimal类型数据的绝对值。 b1.negate(); //相反数，求BigDecimal类型数据的相反数。","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/categories/蓝桥杯/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/tags/蓝桥杯/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://sinclaircoder.top/tags/BigDecimal/"}],"author":"SinclairWang"},{"title":"熊怪吃核桃--二进制的使用","slug":"2019-11-22-熊怪吃核桃--二进制的使用","date":"2019-11-21T16:00:00.000Z","updated":"2020-01-22T03:59:04.091Z","comments":true,"path":"2019/11/22/2019-11-22-xiong-guai-chi-he-tao-er-jin-zhi-de-shi-yong/","link":"","permalink":"https://sinclaircoder.top/2019/11/22/2019-11-22-xiong-guai-chi-he-tao-er-jin-zhi-de-shi-yong/","excerpt":"","text":"一道2015年蓝桥杯省赛试题熊怪吃核桃 森林里有一只熊怪，很爱吃核桃。 不过它有个习惯，每次都把找到的核桃分成相等的两份，吃掉一份，留一份。 如果不能等分，熊怪就会扔掉一个核桃再分。 第二天再继续这个过程，直到最后剩一个核桃了，直接丢掉。 有一天，熊怪发现了1543个核桃，请问，它在吃这些核桃的过程中，一共要丢掉多少个核桃。 思路思路就是每次判读一下是奇数还是偶数，奇数的话就减1然后除以2，偶数的话就直接除以2。用C/C++实现写起来其实很简单，其实还有一种更妙的思路，这个过程其实就是一个除2的过程，也就类似于十进制转二进制的过程，所以直接在Windows下利用计算器输入1543转成二进制，然后数一数二进制里面有几个1即可。 1543对应的二进制是110 0000 0111，里面有5个1。 顺便放一个代码实现吧 #include&lt;iostream&gt; using namespace std; int main(){ int n = 1543,cnt = 0; while(n){ if(n&amp;1){ n--;cnt++; n /= 2; } else n /= 2; } cout &lt;&lt; cnt &lt;&lt; endl; return 0; }","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/categories/蓝桥杯/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://sinclaircoder.top/tags/位运算/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/tags/蓝桥杯/"}],"author":"SinclairWang"},{"title":"大数乘法 java BigInteger的使用","slug":"2019-11-22-大数乘法 java BigInteger的使用","date":"2019-11-21T16:00:00.000Z","updated":"2020-01-22T03:58:51.898Z","comments":true,"path":"2019/11/22/2019-11-22-da-shu-cheng-fa-java-biginteger-de-shi-yong/","link":"","permalink":"https://sinclaircoder.top/2019/11/22/2019-11-22-da-shu-cheng-fa-java-biginteger-de-shi-yong/","excerpt":"","text":"找个大数乘法的题目练习一下 BigInterger的使用 当两个比较大的整数相乘时，可能会出现数据溢出的情形。为避免溢出，可以采用字符串的方法来实现两个大数之间的乘法。具体来说，首先以字符串的形式输入两个整数，每个整数的长度不会超过8位，然后把它们相乘的结果存储在另一个字符串当中（长度不会超过16位），最后把这个字符串打印出来。例如，假设用户输入为：62773417和12345678，则输出结果为：774980393241726. 输入： 62773417 12345678 输出： 774980393241726 代码实现 import java.math.BigInteger; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner input = new Scanner(System.in); String str1 = input.next(),str2 = input.next(); BigInteger num1 = new BigInteger(str1); BigInteger num2 = new BigInteger(str2); BigInteger res = num1.multiply(num2); System.out.println(res.toString()); input.close(); } } 比C/C++实现起来爽很多。一般来说BigInteger是使用String类型进行构造，传入两个个数字字符串，然后进行加减乘除。java中并没有重载运算符这种操作，只能另外实现封装成新的函数。 一些常用API请参考java基础-BigInteger的使用","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/categories/蓝桥杯/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://sinclaircoder.top/tags/蓝桥杯/"},{"name":"BigInteger","slug":"BigInteger","permalink":"https://sinclaircoder.top/tags/BigInteger/"}],"author":"SinclairWang"},{"title":"SQLServer配置管理器打开SQLServer服务&&远程过程调用失败问题","slug":"2019-11-19-SQLServer配置管理器打开SQLServer服务&&远程过程调用失败问题","date":"2019-11-18T16:00:00.000Z","updated":"2020-01-22T03:48:51.667Z","comments":true,"path":"2019/11/19/2019-11-19-sqlserver-pei-zhi-guan-li-qi-da-kai-sqlserver-fu-wu-yuan-cheng-guo-cheng-diao-yong-shi-bai-wen-ti/","link":"","permalink":"https://sinclaircoder.top/2019/11/19/2019-11-19-sqlserver-pei-zhi-guan-li-qi-da-kai-sqlserver-fu-wu-yuan-cheng-guo-cheng-diao-yong-shi-bai-wen-ti/","excerpt":"","text":"打开SQL Server配置管理器在Windows 10中，SQL Server 配置管理器不显示为一个应用程序。如果想找到配置管理器一般在下面这个路径里 C:\\Windows\\SysWOW64 里面文件很多，然后搜索SQLServerManager可能版本不一样，只要是这个就可以，然后双击打开。 远程过程调用失败问题打开服务的时候可能会遇到无法连接到 WMI 提供程序的问题 八成是因为之前装过VS，然后装上了Microsoft SQL Server 201* Express LocalDB（版本可能不一样），可以去控制面板添加或卸载程序 里面搜索Microsoft SQL Server 就可以看到，然后卸载掉应该就可以了。","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://sinclaircoder.top/categories/DataBase/"}],"tags":[{"name":"SQLServer","slug":"SQLServer","permalink":"https://sinclaircoder.top/tags/SQLServer/"}],"author":"SinclairWang"},{"title":"PTA-删除字符串中的子串","slug":"2019-11-19-PTA-删除字符串中的子串","date":"2019-11-18T16:00:00.000Z","updated":"2020-01-22T03:50:40.899Z","comments":true,"path":"2019/11/19/2019-11-19-pta-shan-chu-zi-fu-chuan-zhong-de-zi-chuan/","link":"","permalink":"https://sinclaircoder.top/2019/11/19/2019-11-19-pta-shan-chu-zi-fu-chuan-zhong-de-zi-chuan/","excerpt":"","text":"题目描述输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。 输入格式：输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。 输出格式：在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。 输入样例： Tomcat is a male ccatatcat 输出样例： Tom is a male 实现#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; #define rep(i,m,n) for(int i=m;i&lt;n;i++) #define rep1(i,m,n) for(int i=m;i&gt;=n;i--) #define pb push_back // 主要是练习一下 string里的find()函数和erase()函数的使用 int main(){ string s; getline(cin,s); string del; getline(cin,del); unsigned int n = s.find(del,0); while(n!=-1){ s.erase(n,del.length()); n = s.find(del,0); } cout &lt;&lt; s; return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"}],"author":"SinclairWang"},{"title":"PTA-说反话-加强版","slug":"2019-11-15-PTA-说反话-加强版","date":"2019-11-14T16:00:00.000Z","updated":"2020-01-22T03:45:25.580Z","comments":true,"path":"2019/11/15/2019-11-15-pta-shuo-fan-hua-jia-qiang-ban/","link":"","permalink":"https://sinclaircoder.top/2019/11/15/2019-11-15-pta-shuo-fan-hua-jia-qiang-ban/","excerpt":"","text":"给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过500 000的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用若干个空格分开。 输出格式：每个测试用例的输出占一行，输出倒序后的句子，并且保证单词间只有1个空格。 输入样例： Hello World Here I Come 输出样例： Come I Here World Hello 思路一开始用string s，while(cin &gt;&gt; s) 做的，5行代码只拿了19分，差一分，全为空格的情况没有处理。然后就只能推倒重来了，先读完在后再扫描，判断空格，每读完一个就push一个，但是最后一个会漏掉，要特判一下。更多细节看代码。 实现#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cmath&gt; using namespace std; #define rep(i,m,n) for(int i=m;i&lt;n;i++) #define rep1(i,m,n) for(int i=m;i&gt;=n;i--) #define pb push_back int main(){ string s,s1=&quot;&quot;,s2=&quot;&quot;; getline(cin,s); vector&lt;string&gt; res; rep(i,0,s.length()){ char c = s[i]; if(c!=&#39; &#39;)s1 += c; else { if(s1.length()&gt;0){ res.pb(s1);s1.clear(); } } } // 最后一个会漏掉，但是要判断一下 if(s1.length()&gt;0) res.pb(s1); if(res.size()) cout &lt;&lt; res[res.size()-1]; rep1(i,res.size()-2,0) cout &lt;&lt; &quot; &quot; &lt;&lt; res[i] ; return 0; } /* 如下代码可轻松拿下19分，不过想拿剩下的一分,代码就没有这么简洁了 int main(){ string s; vector&lt;string&gt; v; while(cin &gt;&gt; s) v.pb(s); cout &lt;&lt; v[v.size()-1]; rep1(i,v.size()-2,0) cout &lt;&lt; &quot; &quot; &lt;&lt; v[i] ; return 0; }*/","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"}],"author":"SinclairWang"},{"title":"PTA福到了","slug":"2019-11-08-福到了","date":"2019-11-07T16:00:00.000Z","updated":"2020-01-22T03:43:34.432Z","comments":true,"path":"2019/11/08/2019-11-08-fu-dao-liao/","link":"","permalink":"https://sinclaircoder.top/2019/11/08/2019-11-08-fu-dao-liao/","excerpt":"","text":"“福”字倒着贴，寓意“福到”。不论到底算不算民俗，本题且请你编写程序，把各种汉字倒过来输出。这里要处理的每个汉字是由一个 N × N 的网格组成的，网格中的元素或者为字符 @ 或者为空格。而倒过来的汉字所用的字符由裁判指定。 输入格式：输入在第一行中给出倒过来的汉字所用的字符、以及网格的规模 N （不超过100的正整数），其间以 1 个空格分隔；随后 N 行，每行给出 N 个字符，或者为 @ 或者为空格。 输出格式：输出倒置的网格，如样例所示。但是，如果这个字正过来倒过去是一样的，就先输出bu yong dao le，然后再用输入指定的字符将其输出。 输入样例 1： $ 9 @ @@@@@@@@ @@@ @ @ @@@@ @@@@@@ @@@@@@@@ @ @ @@@@ @@@@@ @ @ @ @ @ @@@@@ 输出样例 1：$$$$$ $ $ $ $ $ $$$$$ $$$ $ $ $ $$$ $$$$$ $$$ $$$ $$$ $ $ $ $$$ $$$ $$$$$ $ 输入样例 2： &amp; 3@@@ @@@@ 输出样例 2： bu yong dao le\\&amp;\\&amp;\\&amp; &amp;&amp;\\&amp;\\&amp; Tips记得getchar()坑很多.. 实现#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; #define rep(i,m,n) for(int i=m;i&lt;n;i++) #define rep1(i,m,n) for(int i=m;i&gt;=n;i--) int main() { char c; int n; cin &gt;&gt; c &gt;&gt; n; getchar(); string s[n]; rep(i,0,n) getline(cin,s[i]); bool ok = true; // 不需要倒置 for(int i=0,j=n-1;i&lt;n&amp;&amp;ok;i++,j--){ for(int k=0,t=n-1;k&lt;n;k++,t--){ if(s[i][k]!=s[j][t]) {ok = false;break;} } } if(ok) cout &lt;&lt; &quot;bu yong dao le&quot; &lt;&lt; endl; rep1(i,n-1,0){ rep1(j,n-1,0) if(s[i][j]==&#39;@&#39;) cout &lt;&lt; c ; else cout &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"}],"author":"SinclairWang"},{"title":"PTA九宫格输入法","slug":"2019-11-08-九宫格输入法","date":"2019-11-07T16:00:00.000Z","updated":"2020-01-22T03:42:03.673Z","comments":true,"path":"2019/11/08/2019-11-08-jiu-gong-ge-shu-ru-fa/","link":"","permalink":"https://sinclaircoder.top/2019/11/08/2019-11-08-jiu-gong-ge-shu-ru-fa/","excerpt":"","text":"假设有九宫格输入法键盘布局如下： [ 1,.?! ] [ 2ABC ] [ 3DEF ] [ 4GHI ] [ 5JKL ] [ 6MNO ] [ 7PQRS ] [ 8TUV ] [ 9WXYZ ] [ 0空 ] 注意：中括号[ ]仅为了表示键盘的分隔，不是输入字符。每个中括号中，位于首位的数字字符即是键盘的按键，按一下即可输入该数字字符。多次按同一个键，则输入的字符依次循环轮流，例如按两次3，则输入D；按5次7，则输入S；按6次2，则输入A。按键0的输入组合是0和空格字符，即按两次0输入空格。 你需要对于给定的按键组合，给出该组合对应的文本。 输入格式:输入在一行中给出数个字符的按键组合（例如 999 表示按3次9），每个字符的按键组合之间用空格间隔，最后一个输入法组合之后以换行结束。输入数据至少包括一个字符的按键组合，且输入总长度不超过500个字符。 输出格式:在一行中输出该按键组合对应的文本。 输入样例: 22 5555 22 666 00 88 888 7777 4444 666 44 输出样例: ALAN TURING 实现#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; #define rep(i,m,n) for(int i=m;i&lt;n;i++) #define rep1(i,m,n) for(int i=m;i&gt;=n;i--) int main() { string s[10]; s[1]=&quot;1,.?!&quot;;s[2]=&quot;2ABC&quot;;s[3]=&quot;3DEF&quot;;s[4]=&quot;4GHI&quot;;s[5]=&quot;5JKL&quot;; s[6]=&quot;6MNO&quot;;s[7]=&quot;7PQRS&quot;;s[8]=&quot;8TUV&quot;;s[9]=&quot;9WXYZ&quot;;s[0]=&quot;0 &quot;; char tmp[100]; while(cin&gt;&gt;tmp&amp;&amp;tmp[0]!=&#39;\\n&#39;){ int index = strlen(tmp)%s[tmp[0]-&#39;0&#39;].length(); if(index==0) cout &lt;&lt; s[tmp[0]-&#39;0&#39;][s[tmp[0]-&#39;0&#39;].length()-1]; else cout &lt;&lt; s[tmp[0]-&#39;0&#39;][index-1]; } return 0; }","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"}],"author":"SinclairWang"},{"title":"PTA复数四则运算","slug":"2019-11-07- 复数四则运算","date":"2019-11-06T16:00:00.000Z","updated":"2020-01-22T03:38:11.873Z","comments":true,"path":"2019/11/07/2019-11-07-fu-shu-si-ze-yun-suan/","link":"","permalink":"https://sinclaircoder.top/2019/11/07/2019-11-07-fu-shu-si-ze-yun-suan/","excerpt":"","text":"本题要求编写程序，计算2个复数的和、差、积、商。 输入格式：输入在一行中按照a1 b1 a2 b2的格式给出2个复数C1=a1+b1i和C2=a2+b2i的实部和虚部。题目保证C2不为0。 输出格式：分别在4行中按照(a1+b1i) 运算符 (a2+b2i) = 结果的格式顺序输出2个复数的和、差、积、商，数字精确到小数点后1位。如果结果的实部或者虚部为0，则不输出。如果结果为0，则输出0.0。 输入样例1： 2 3.08 -2.04 5.06 输出样例1： (2.0+3.1i) + (-2.0+5.1i) = 8.1i(2.0+3.1i) - (-2.0+5.1i) = 4.0-2.0i(2.0+3.1i) * (-2.0+5.1i) = -19.7+3.8i(2.0+3.1i) / (-2.0+5.1i) = 0.4-0.6i 输入样例2： 1 1 -1 -1.01 输出样例2： (1.0+1.0i) + (-1.0-1.0i) = 0.0(1.0+1.0i) - (-1.0-1.0i) = 2.0+2.0i(1.0+1.0i) * (-1.0-1.0i) = -2.0i(1.0+1.0i) / (-1.0-1.0i) = -1.0 注意事项我也是过早的考虑了代码复用，没有注意到格式的问题。注意题目：结果的格式顺序输出2个复数的和、差、积、商，数字精确到小数点后1位。如果结果的实部或者虚部为0，则不输出。如果结果为0，则输出0.0。等式左边输出时要保留小数点后一位，等式右边计算结果，如果实部或者虚部为0，则不输出。如果结果为0，则输出0.0。参考： 7-36 复数四则运算 code 实现#include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #include&lt;vector&gt; using namespace std; typedef long long ll; #define rep(i,m,n) for(int i=m;i&lt;n;i++) #define rep1(i,m,n) for(int i=m;i&gt;=n;i--) #define print(a1,b1,c,a2,b2) printf(&quot;(%.1lf%+.1lfi) %c (%.1lf%+.1lfi) = &quot;,a1,b1,c,a2,b2); int gcd(int a,int b){ return b==0?a:gcd(b,a%b);} void print1(double a,double b){ if(abs(a)&lt;0.05&amp;&amp;abs(b)&lt;0.05) printf(&quot;0.0&quot;); else { if(abs(a)&gt;=0.05) printf(&quot;%.1lf&quot;,a); if(abs(b)&gt;=0.05){ if(b&gt;0&amp;&amp;abs(a)&gt;=0.05) cout &lt;&lt; &quot;+&quot;; printf(&quot;%.1lfi&quot;,b); } } } int main(){ double a,b,c,d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; print(a,b,&#39;+&#39;,c,d);print1(a+c,b+d);cout &lt;&lt; endl; print(a,b,&#39;-&#39;,c,d);print1(a-c,b-d);cout &lt;&lt; endl; print(a,b,&#39;*&#39;,c,d);print1(a*c-b*d,a*d+b*c);cout &lt;&lt; endl; print(a,b,&#39;/&#39;,c,d);print1((a*c+b*d)/(c*c+d*d),(b*c-a*d)/(c*c+d*d)); return 0; } 一道题卡了多半个小时…","categories":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/categories/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"}],"author":"SinclairWang"},{"title":"LeetCodeWeeklyContest-161","slug":"2019-11-03-LeetCodeWeeklyContest-161","date":"2019-11-02T16:00:00.000Z","updated":"2020-01-22T03:26:34.952Z","comments":true,"path":"2019/11/03/2019-11-03-leetcodeweeklycontest-161/","link":"","permalink":"https://sinclaircoder.top/2019/11/03/2019-11-03-leetcodeweeklycontest-161/","excerpt":"","text":"希望你还有诗和远方。 传送门： 第 161 场周赛交换字符使得字符串相同有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。示例： 输入：s1 = “xx”, s2 = “yy”输出：1解释：交换 s1[0] 和 s2[1]，得到 s1 = “yx”，s2 = “yx”。 思路通过找规律可以发现，只有s1 = “xx”，s2 = “yy”或者s1 = “xy”, s2 = “yx”这两种情况，分别需要的交换次数为1和2，那只需要统计两个字符串里面有多少个这样的组合。 同时扫描两个字符串，如果遇到不相同的字符，就把s1[i]中的字符压入vector（当然s2[i]也可以） 然后数vector里面x和y的个数 如果x和y的个数为奇数就无法完成交换，返回-1 x/2+y/2 就是对应s1 = “xx”, s2 = “yy”组合的个数 x%2就是对应s1 = “xy”, s2 = “yx”组合的个数 result = x/2+y/2+(x%2)*2 实现#define rep(i,m,n) for(int i=m;i&lt;n;i++) #define pb push_back class Solution { public: int minimumSwap(string s1, string s2) { vector&lt;char&gt; ans; rep(i,0,s1.length()){ if(s1[i]!=s2[i]) ans.pb(s1[i]); } int x=0,y=0; rep(i,0,ans.size()){ if(ans[i]==&#39;x&#39;) x++; else if(ans[i]==&#39;y&#39;) y++; cout &lt;&lt; ans[i]; } if((x+y)%2) return -1; else return x/2+y/2+(x%2)*2; } }; 统计「优美子数组」给你一个整数数组 nums 和一个整数 k。如果某个子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。示例： 输入：nums = [1,1,2,1,1], k = 3输出：2解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。 思路暴力会超时。主要还是做一个数组，统计从第一个元素开始到现在奇数的个数。然后使用upper_bound 和 lower_bound更多解法请参考：1248. Count Number of Nice Subarrays 实现#define rep(i,m,n) for(int i=m;i&lt;n;i++) class Solution { public: int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) { int res = 0; int cnt[50005]; memset(cnt,0,sizeof(cnt)); rep(i,0,nums.size()){ if(nums[i]%2){ cnt[i+1] = cnt[i]+1; } else cnt[i+1] = cnt[i]; } rep(i,1,nums.size()+1){ res += upper_bound(cnt+1,cnt+nums.size()+1,cnt[i-1]+k) - lower_bound(cnt+1,cnt+nums.size()+1,cnt[i-1]+k); } return res; } }; 不过发现这种解法虽然运行没有问题，但是自己手动拿纸推的时候貌似样例过不去。upper_bound 找的是范围内第一个大于x的位置 lower_bound找的是范围内第一个大于等于x的位置nums = [2,2,2,1,2,2,1,2,2,2], k = 2这个样例 nums 2 2 2 1 2 2 1 2 2 2 index 0 1 2 3 4 5 6 7 8 9 dict 0 0 0 1 1 1 2 2 2 2 upper 10 10 10 10 10 10 10 10 10 10 lower 6 6 6 10 10 10 10 10 10 10 这样一算 结果等于(10-6)3=12!=16 这是为甚麽？ 移除无效的括号给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。请返回任意一个合法字符串。有效「括号字符串」应当符合以下 任意一条 要求： 空字符串或只包含小写字母的字符串 可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」 可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」思路一开始的想法是用栈来做，可是无法记录该删去的字符的下标，想用stack","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/tags/leetcode/"}],"author":"SinclairWang"},{"title":"PTA字符串转换成十进制整数","slug":"2019-11-1-PTA字符串转换成十进制整数","date":"2019-10-31T16:00:00.000Z","updated":"2020-01-22T03:33:25.386Z","comments":true,"path":"2019/11/01/2019-11-1-pta-zi-fu-chuan-zhuan-huan-cheng-shi-jin-zhi-zheng-shu/","link":"","permalink":"https://sinclaircoder.top/2019/11/01/2019-11-1-pta-zi-fu-chuan-zhuan-huan-cheng-shi-jin-zhi-zheng-shu/","excerpt":"","text":"初闻不知曲中意，再闻已是曲中人 去年此时正被这套PTA题目折磨，一年之后再写这些题目，记忆尤新，经历的酸楚自然是值得的。 题目描述输入一个以#结束的字符串，本题要求滤去所有的非十六进制字符（不分大小写），组成一个新的表示十六进制数字的字符串，然后将其转换为十进制数后输出。如果在第一个十六进制字符之前存在字符“-”，则代表该数是负数。 输入格式：输入在一行中给出一个以#结束的非空字符串。 输出格式：在一行中输出转换后的十进制数。题目保证输出在长整型范围内。 输入样例：+-P-xf4+-1!# 输出样例：-3905 思路重点在字符串的清洗上，只保留第一个负号，保留数字和十六进制字符，其余洗掉。然后进行进制转换 实现#include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;string.h&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; #define For1(i,m,n) for(int i=m;i&lt;n;i++) #define For2(i,m,n) for(int i=m;i&gt;=n;i--) // 清洗输入的字符串 vector&lt;char&gt; convert(string s){ vector&lt;char&gt; v; int cnt = 0; bool first = true; For1(i,0,s.length()){ if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;||s[i]&gt;=&#39;a&#39;&amp;&amp;s[i]&lt;=&#39;f&#39;||s[i]&gt;=&#39;A&#39;&amp;&amp;s[i]&lt;=&#39;F&#39;){ v.push_back(s[i]); } else if(s[i]==&#39;-&#39;&amp;&amp;first==true){ v.push_back(s[i]); first = false; } } return v; } // 进制转换 ll convertres(vector&lt;char&gt; v){ ll res = 0,cnt=0; For2(i,v.size()-1,0){ if(v[i]&gt;=&#39;0&#39;&amp;&amp;v[i]&lt;=&#39;9&#39;){ res += (v[i]-&#39;0&#39;)*pow(16,cnt); cnt++; }else if(v[i]&gt;=&#39;a&#39;&amp;&amp;v[i]&lt;=&#39;f&#39;){ res += (v[i]-&#39;a&#39;+10)*pow(16,cnt); cnt++; } else if(v[i]&gt;=&#39;A&#39;&amp;&amp;v[i]&lt;=&#39;F&#39;){ res += (v[i]-&#39;A&#39;+10)*pow(16,cnt); cnt++; } else ; } return res; } int main(){ bool postive = true; string s; cin &gt;&gt; s; vector&lt;char&gt; v = convert(s); if(v[0]==&#39;-&#39;) postive = false; // print // For1(i,0,v.size()){ // cout &lt;&lt; v[i]; // } // cout &lt;&lt; endl; ll res = convertres(v); if(!postive) res *= -1; cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://sinclaircoder.top/tags/PTA/"}],"author":"SinclairWang"},{"title":"LeetCodeWeeklyContest-160","slug":"2019-10-27-LeetCodeWeeklyContest-160","date":"2019-10-26T16:00:00.000Z","updated":"2020-01-22T02:48:12.575Z","comments":true,"path":"2019/10/27/2019-10-27-leetcodeweeklycontest-160/","link":"","permalink":"https://sinclaircoder.top/2019/10/27/2019-10-27-leetcodeweeklycontest-160/","excerpt":"","text":"题目传送门找出给定方程的正整数解签到题的新包装，我没有玩过的船新版本。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; c, int z) { vector&lt;vector&lt;int&gt;&gt; res; for(int i=1;i&lt;=1000;i++){ for(int j=1;j&lt;=1000;j++){ if(c.f(i,j)&lt;z) continue; else if(c.f(i,j)==z) { vector&lt;int&gt; v; v.push_back(i),v.push_back(j); res.push_back(v); } else break; } } return res; } }; 循环码排列给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,…,2^n-1) 的排列 p，并且满足： p[0] = start p[i] 和 p[i+1] 的二进制表示形式只有一位不同 p[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同 举个例子： 输入：n = 2, start = 3 输出：[3,2,0,1] 解释：这个排列的二进制表示是 (11,10,00,01) 所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2] 思路参考： [Java/C++/Python] 4-line Gray Code Gray code 其实就是格雷码。使用位运算操作 实现vector&lt;int&gt; circularPermutation(int n, int start) { vector&lt;int&gt; res; for(int i=0;i&lt; 1&lt;&lt;n;i++){ res.push_back(start^i^i&gt;&gt;1); } return res; } 比赛时找了个格雷码的板子，然后改了改，就过掉了… class Solution { public: vector&lt;int&gt; grayCode(int n){ vector&lt;int&gt; gray; if (n &lt; 1) { gray.push_back(0); return gray; } int num = pow(2,n); int graycode[n]; for (int i = 0; i &lt; num; i++) { IntToBit(graycode, i, n); BitToGray(graycode,n); gray.push_back(GrayBitToInt(graycode, n)); } return gray; } void IntToBit(int *code, int n, int bit){ int i = bit-1; while (i &gt;= 0) { code[i--] = n%2; n/=2; } } void BitToGray(int *code, int bit){ int temp[bit]; temp[0] = 0^code[0]; for (int i = 0; i &lt; bit-1; i++) { temp[i+1] = code[i]^code[i+1]; } for (int i = 0; i &lt; bit; i++) { code[i] = temp[i]; } } int GrayBitToInt(int *code, int bit){ int number = 0; for (int i = 0; i &lt; bit; i++) { if (code[i] == 1) { number += pow(2, bit-i-1); } } return number; } vector&lt;int&gt; circularPermutation(int n, int start) { vector&lt;int&gt; res,tmp; tmp = grayCode(n); int index,msize = pow(2,n); for(int i=0;i&lt;msize;i++){ if(tmp[i]==start){ index = i; break; } } for(int i=index;i&lt;msize;i++){ res.push_back(tmp[i]); } for(int i=0;i&lt;index;i++){ res.push_back(tmp[i]); } return res; } }; 串联字符串的最大长度给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。请返回所有可行解 s 中最长长度。 思路判定函数+DFS判定函数：判定一个字符串是否有重复字母，打个大小为26的表即可。 实现class Solution { public: int maxL = 0; bool pend(string s1){ int ph[26]={0}; for(int i=0;i&lt;s1.length();i++){ if(ph[s1[i]-&#39;a&#39;]==1) return false; ph[s1[i]-&#39;a&#39;]=1; } return true; } void dfs(vector&lt;string&gt; arr, int index, string str){ int len = str.length(); if(pend(str)) maxL = max(maxL,len); if(index == arr.size()||!pend(str)) return ; for(int i=index;i&lt;arr.size();i++){ dfs(arr,i+1,str+arr[i]); } } int maxLength(vector&lt;string&gt;&amp; arr) { dfs(arr,0,&quot;&quot;); return maxL; } }; 铺瓷砖你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。假设正方形瓷砖的规格不限，边长都是整数。请你帮设计师计算一下，最少需要用到多少块方形瓷砖？ 思路参考： Paper Cut into Minimum Number of Squares | Set 2 B站视频讲解 基本上还是DFS，其实这个题很像经典的贪心题目，不过那个貌似是是个正方形，而且这个题有个特殊的点，就是当n\\==11&amp;&amp;m\\==13||n\\==13&amp;&amp;m==11 这个时候的结果应该为6。剩下的就是先横切，看需要多少方形瓷砖，然后再纵切，看需要多少方形瓷砖，取横切和纵切的最小值，便是结果。 实现class Solution { public: int dp[300][300]={0}; int solve(int n,int m){ if(n==m) return 1; if(dp[n][m]) return dp[n][m]; int res = 2e8; for(int i=1;i&lt;=n/2;i++){ res = min(solve(i,m)+solve(n-i,m),res); } for(int j=1;j&lt;=m/2;j++){ res = min(solve(n,j)+solve(n,m-j),res); } dp[n][m] = res; return res; } int tilingRectangle(int n, int m) { if(n==11&amp;&amp;m==13||n==13&amp;&amp;m==11) return 6; return solve(n,m); } }; 你一人低头在路上… 多向往 多漫长","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/tags/leetcode/"}],"author":"SinclairWang"},{"title":"格雷码","slug":"2019-10-27-格雷码","date":"2019-10-26T16:00:00.000Z","updated":"2020-01-22T03:44:05.216Z","comments":true,"path":"2019/10/27/2019-10-27-ge-lei-ma/","link":"","permalink":"https://sinclaircoder.top/2019/10/27/2019-10-27-ge-lei-ma/","excerpt":"","text":"偶然间发现了一个很好的方法，详见Gray code 下面是一个生成以start开始的格雷码的板子，n为二进制位的个数。 vector&lt;int&gt; getGray(int n, int start) { vector&lt;int&gt; res; for(int i=0;i&lt; 1&lt;&lt;n;i++){ res.push_back(start^i^i&gt;&gt;1); } return res; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://sinclaircoder.top/tags/位运算/"},{"name":"格雷码","slug":"格雷码","permalink":"https://sinclaircoder.top/tags/格雷码/"}],"author":"SinclairWang"},{"title":"线性筛","slug":"2019-10-25-线性筛","date":"2019-10-24T16:00:00.000Z","updated":"2020-01-22T02:49:55.131Z","comments":true,"path":"2019/10/25/2019-10-25-xian-xing-shai/","link":"","permalink":"https://sinclaircoder.top/2019/10/25/2019-10-25-xian-xing-shai/","excerpt":"","text":"#include &lt;bits/stdc++.h&gt; using namespace std; const int MAX_N = 3e7+2; typedef long long ll; int v[MAX_N],prime[MAX_N]; void primes(int n) { memset(v,0,sizeof(v)); int m = 0; for(int i=2;i&lt;=n;i++){ if(v[i]==0){ // i 是质数 v[i] = i; prime[++m] = i; } for(int j=1;j&lt;=m;j++){ if(prime[j]&gt;v[i]||prime[j]&gt;n/i) break; // prime[j]是是合数i*prime[j]的最小质因子 v[i*prime[j]] = prime[j]; } } // 打印1到n之间的素数 // for(int i=1;i&lt;=m;i++){ // cout &lt;&lt; prime[i] &lt;&lt; endl; // } // 打印1到n每个数的最小质因子 // for(int i=0;i&lt;=n;i++){ // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; v[i] &lt;&lt; endl; // } }","categories":[{"name":"数论","slug":"数论","permalink":"https://sinclaircoder.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sinclaircoder.top/tags/数论/"}],"author":"SinclairWang"},{"title":"裴蜀定理&&扩展欧几里得算法","slug":"2019-10-22-裴蜀定理&&扩展欧几里得算法","date":"2019-10-21T16:00:00.000Z","updated":"2020-01-21T15:17:01.611Z","comments":true,"path":"2019/10/22/2019-10-22-pei-shu-ding-li-kuo-zhan-ou-ji-li-de-suan-fa/","link":"","permalink":"https://sinclaircoder.top/2019/10/22/2019-10-22-pei-shu-ding-li-kuo-zhan-ou-ji-li-de-suan-fa/","excerpt":"","text":"裴蜀定理也就是Bezout定理，对于任意整数a,b，存在一对整数x,y，满足$ax+by=gcd(a,b)$。在数论中，裴蜀定理是一个关于最大公约数（或最大公约式）的定理，裴蜀定理得名于法国数学家艾蒂安·裴蜀。裴蜀定理说明了对任何整数 a、b和它们的最大公约数 d ，关于未知数 x 和 y 的线性丢番图方程（称为裴蜀等式）。 证明： 若b=0时，此时迭代到算法的最后一步，显然存在一对整数，$x=1,y=0$ ，使得a*1+0*0 = gcd(a,0) 若b&gt;0时，则 $gcd(a,b) = gcd(b,a\\,mod\\,b)$ ，假设存在一对整数 $x_1,y_1$ ，满足 b*x_1+(a\\,mod\\,b)*y_1 = gcd(b,a\\,mod\\,b) ，因为 b*x_1+(a\\,mod\\,b)*{y_1}= b*x_1+(a-a/b*b)y_1= a*y_1 +b*(x_1-(a/b)*y_1) 证毕 裴蜀定理是按照欧几里得算法的思路被证明的，并且同时给出了整数x和y的计算方法。这种计算方法被称为扩展欧几里得算法。 联立一下 \\begin{cases} gcd=a*x+b*y \\\\ gcd = a*y_1 + b*(x_1-(a/b)*y_1) \\end{cases}可以得出 \\begin{cases} x=y_1 \\\\ y = x_1-(a/b)*y_1 \\end{cases}实现int exgcd(int a,int b,int &amp;x,int &amp;y){ if(b==0){ x = 1,y = 0; return a; } int ans = exgcd(b,a%b,x,y); int z = y; y = x - (a/b)*z,x = z; return ans; } 说明上述程序求出的是一组特解$x_0,y_0$，并返回a,b的最大公约数d。 未完，待续…","categories":[{"name":"数论","slug":"数论","permalink":"https://sinclaircoder.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sinclaircoder.top/tags/数论/"}],"author":"SinclairWang"},{"title":"费马小定理","slug":"2019-10-22-费马小定理","date":"2019-10-21T16:00:00.000Z","updated":"2020-01-21T14:06:08.926Z","comments":true,"path":"2019/10/22/2019-10-22-fei-ma-xiao-ding-li/","link":"","permalink":"https://sinclaircoder.top/2019/10/22/2019-10-22-fei-ma-xiao-ding-li/","excerpt":"","text":"若p是质数，则对于任意整数a，有$a^p \\equiv a (mod \\, p)$","categories":[{"name":"数论","slug":"数论","permalink":"https://sinclaircoder.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sinclaircoder.top/tags/数论/"}],"author":"SinclairWang"},{"title":"LeetCodeWeeklyContest-159","slug":"2019-10-21-LeetCodeWeeklyContest-159","date":"2019-10-20T16:00:00.000Z","updated":"2020-01-22T02:42:10.093Z","comments":true,"path":"2019/10/21/2019-10-21-leetcodeweeklycontest-159/","link":"","permalink":"https://sinclaircoder.top/2019/10/21/2019-10-21-leetcodeweeklycontest-159/","excerpt":"","text":"最近看了篇文章，文章里说 希望你身边能有个比你聪明五倍，但却比你还努力十倍的人。倍数虽然有些夸张，但是这个思想还是能get到的。 5230. 缀点成线在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。 请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。 思路根据前两个点构造直线，看后续的点是否在直线上。直线方程为 $ax+by+c=0$，其中：$a=y_2-y_1$ $b=x_1-x_2$ $c=-ax_1-by_1$好处是不用考虑斜率，这是个方程的一般式。如果考虑斜率，还得分斜率是否为0。 实现class Solution { public: bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) { vector&lt;int&gt; v1,v2,v3; v1 = coordinates[0]; v2 = coordinates[1]; int a = v2[1]-v1[1]; int b = v1[0]-v2[0]; int c = -1*a*v1[0]-b*v1[1]; for(int i=1;i&lt;coordinates.size();i++){ v3 = coordinates[i]; if(a*v3[0]+b*v3[1]+c!=0) return false; } return true; } }; 删除子文件夹你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 我们这样定义「子文件夹」： 如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的子文件夹。文件夹的「路径」是由一个或多个按以下格式串联形成的字符串： / 后跟一个或者多个小写英文字母。例如，/leetcode 和 /leetcode/problems 都是有效的路径，而空字符串和 / 不是。 思路 写一个判别函数来判断是否为子路径 将文件夹序列sort，此时字典序小的应该在前，长度小的也在前，故一般父路径也在前。 设置一个标记数组，初始置0，如果该文件夹路径要被删除置1。 扫描文件夹序列，两两对比，神奇的是不用二重循环就可以做到。 将标记为0的push进vector，返回。 实现class Solution { public: // a.length &lt; b.length bool isSubFolder(string a,string b) { int n1 = a.length(),n2 = b.length(); if(n1&gt;n2) return false; int i; for(i=0;i&lt;n1;i++){ if(a[i]!=b[i]) return false; } if(b[i]!=&#39;/&#39;) return false; return true; } vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) { sort(folder.begin(),folder.end()); int n = folder.size(); int pend[n]={0}; // delete 1 int j=0; for(int i=1;i&lt;n;i++){ if(isSubFolder(folder[j],folder[i])){ pend[i] = 1; } else j = i; // important } vector&lt;string&gt; res; for(int i=0;i&lt;n;i++){ if(!pend[i]) res.push_back(folder[i]); } return res; } }; 替换子串得到平衡字符串有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。给你一个这样的字符串 s，请通过「替换子串」的方式，使原字符串 s 变成一个「平衡字符串」。你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。请返回待替换子串的最小可能长度。如果原字符串自身就是一个平衡字符串，则返回 0。 思路参考： lee215 的视频讲解 [Java/C++/Python] Sliding Window 我觉得题目需要重新阅读并理解一下，题目的意思是在给出的序列中找一个子串，只需要修改这个子串的字符就可以使得这个字符串变为平衡字符串，求这个子串的最小长度。 思路是lee215 这位大牛的，上面的参考一个是他的视频讲解，另一个是他写的题解。下面写一下他的思路：首先扫描一下字符串，把W、E、R、Q这四个字符的个数记录下来，使用滑动窗口的思想，从下标0开始，扫描字符串，只考虑滑动窗口以外的字符，不考虑滑动窗口内的字符，滑动窗口外的W、E、R、Q这四个字符的个数，如果字符个数小于等于n/4，则说明改滑动窗口所在的区间越正确，也即滑动窗口内的字符是多余的并需要被修改的，然后找到这个滑动窗口长度的最小值即可。 当然这个算法是O(n)的，代码很简介，或许是全网最短，也或许最难懂。 更多题解可以参考 leetcode英文社区下关于这道题的讨论。1234. Replace the Substring for Balanced String 实现class Solution { public: int balancedString(string s) { // QWER count; int n = s.length(),m=n/4,res=n,i=0; map&lt;char,int&gt; count; for(int j=0;j&lt;n;j++) count[s[j]]++; for(int j=0;j&lt;n;j++){ count[s[j]]--; while(i&lt;n&amp;&amp;count[&#39;Q&#39;]&lt;=m&amp;&amp;count[&#39;E&#39;]&lt;=m&amp;&amp;count[&#39;R&#39;]&lt;=m&amp;&amp;count[&#39;W&#39;]&lt;=m){ res = min(res,j-i+1); count[s[i]]++; i++; } } return res; } }; 规划兼职工作你打算利用空闲时间来做兼职工作赚些零花钱。这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。注意，时间上出现重叠的 2 份工作不能同时进行。如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。 思路一参考： [Java/C++/Python] DP Solution lee215 的视频讲解 再开辟一块空间，把endTime[i],startTime[i],profit[i] 一起存放进去，按照结束时间排序。然后进行动态规划，使用map，其中dp[i]表示从0到i时间段内的收益，i为结束时间，迭代过程是在dp中找到开始时间大于每次的startTime的结束时间的前一个，也就是小于startTime的最大的endTime,然后与当前的收益相加，最后map的最后一个就是答案。（其实这里有很多细节需要仔细钻研一下，比如之前就踩过的坑，涉及到了map的存储结构等) 实现一class Solution { public: int jobScheduling(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, vector&lt;int&gt;&amp; profit) { int n = endTime.size(); vector&lt;vector&lt;int&gt; &gt; jobs; for(int i=0;i&lt;n;i++){ jobs.push_back({endTime[i],startTime[i],profit[i]}); } sort(jobs.begin(),jobs.end()); map&lt;int,int&gt; dp; dp[0] = 0; for(auto job:jobs){ int cur = prev(dp.upper_bound(job[1]))-&gt;second + job[2]; if(cur &gt; dp.rbegin()-&gt;second) dp[job[0]] = cur; } return dp.rbegin()-&gt;second; } }; 思路二参考： [C++] Sort and DP, O(NlogN)不去重新分配存储空间去存储starttime、endTime、profit，只需要新建一个索引数组，自定义排序规则，按照结束时间排序。然后还定义了一个匿名函数，返回在endTime在startTime[i]之前的索引。然后就是动态规划，dp[i]表示在i时刻及以前所获得的最大收益，cur为当前时刻可以获得的收益。dp[i] = max(dp[i-1],cur)，最后dp[n-1]便是答案。 更多题解可以参考 leetcode英文社区下关于这道题的讨论。1235. Maximum Profit in Job Scheduling 实现二class Solution { public: int jobScheduling(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, vector&lt;int&gt;&amp; profit) { int n = startTime.size(); vector&lt;vector&lt;int&gt;&gt; jobs; int index[n]; for(int i=0;i&lt;n;i++){ index[i]=i; } sort(index,index+n,[&amp;endTime](int i,int j){return endTime[i]&lt;endTime[j];}); auto lastestValidIndex = [&amp;startTime,&amp;endTime,&amp;index](int i){ // lambda int start = startTime[index[i]]; int left = 0, right = i; while(left&lt;right){ int mid = (left+right)&gt;&gt;1; if(endTime[index[mid]]&lt;=start) left = mid+1; // +1 else right = mid; } return right==0?-1:right-1; }; int dp[n]={0}; dp[0] = profit[index[0]]; for(int i=1;i&lt;n;i++){ int cur = profit[index[i]]; int last = lastestValidIndex(i); if(last!=-1) cur +=dp[last]; dp[i] = max(dp[i-1],cur); } return dp[n-1]; } }; 被DP教育4小时。为伊消得人憔悴..说实话还是leetcode英文社区那边大牛多，讨论也更多一些。 今日份荐读： 姚班学霸陈立杰：16岁保送清华，18岁拿下IOI世界冠军，现摘得FOCS 2019最佳学生论文量子位","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/tags/leetcode/"}],"author":"SinclairWang"},{"title":"统计字符","slug":"2019-10-21-统计字符","date":"2019-10-20T16:00:00.000Z","updated":"2020-01-21T14:03:58.921Z","comments":true,"path":"2019/10/21/2019-10-21-tong-ji-zi-fu/","link":"","permalink":"https://sinclaircoder.top/2019/10/21/2019-10-21-tong-ji-zi-fu/","excerpt":"","text":"输入一行字符，分别统计出其中英文字母、空格、数字和其他字符的个数。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn = 2e5; # define mod(a,b) (a)%(b) int main(){ char ch; int count[4]={0}; while(cin.get(ch)){ if(ch&gt;=&#39;a&#39;&amp;&amp;ch&lt;=&#39;z&#39;||ch&gt;=&#39;A&#39;&amp;&amp;ch&lt;=&#39;Z&#39;) count[0]++; else if(ch==&#39; &#39;) count[1]++; else if(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) count[2]++; else if(ch==&#39;\\n&#39;) break; else count[3]++; } cout &lt;&lt; count[0] &lt;&lt; &quot; &quot; &lt;&lt; count[2] &lt;&lt; &quot; &quot; &lt;&lt; count[1] &lt;&lt; &quot; &quot; &lt;&lt; count[3] ; return 0; } 题目虽然简单，注意点是统计空格需要用cin.get(ch)，输入时会在行末多输入一个回车，注意处理。","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://sinclaircoder.top/tags/字符串/"}],"author":"SinclairWang"},{"title":"最长公共子序列(LongestCommonSubsequence)","slug":"2019-10-17-最长公共子序列(LongestCommonSubsequence)","date":"2019-10-16T16:00:00.000Z","updated":"2020-01-21T13:58:19.545Z","comments":true,"path":"2019/10/17/2019-10-17-zui-chang-gong-gong-zi-xu-lie-longestcommonsubsequence/","link":"","permalink":"https://sinclaircoder.top/2019/10/17/2019-10-17-zui-chang-gong-gong-zi-xu-lie-longestcommonsubsequence/","excerpt":"","text":"问题描述求两个长度分别为m和n的字符串A、B的最长公共子序列。A：a0a1a2…am-1B：b0b1b2…bn-1 思路构造一个大小为(m+1)*(n+1)的二维数组dpdp[i][j] 表示a0a1a2…ai-1 和 b0b1b2…bj-1 两个字符串的最大公共子序列 状态转移方程dp[i][j]= \\begin{cases}0 & \\text {if i=0 or j=0} \\\\ dp[i-1][j-1]+1 & \\text{if a[i-1]=b[j-1] } \\\\ max(dp[i-1][j],dp[i][j-1]) &\\text{if a[i-1]!=b[j-1]}\\end{cases}实现int dp[MAXN][MAXN]={0}; vector&lt;char&gt; subs; vector&lt;char&gt; longestCommonSubsequence(string s1, string s2) { memset(dp,0,sizeof(dp)); int m = s1.length(),n = s2.length(); for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1]+1; else dp[i][j] = max(dp[i-1][j],dp[i][j-1]); } } int k = dp[m][n],i=m,j=n; while(k&gt;0){ if(dp[i][j]==dp[i-1][j]) i--; else if(dp[i][j]==dp[i][j-1]) j--; else { subs.push_back(s1[i-1]); i--;j--;k--; } } return subs; } 来道板子题试试：1143. 最长公共子序列","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://sinclaircoder.top/categories/动态规划/"}],"tags":[{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"https://sinclaircoder.top/tags/最长公共子序列/"}],"author":"SinclairWang"},{"title":"LeetCodeWeeklyContest-158","slug":"2019-10-13-LeetCodeWeeklyContest-158","date":"2019-10-12T16:00:00.000Z","updated":"2020-01-22T02:42:02.196Z","comments":true,"path":"2019/10/13/2019-10-13-leetcodeweeklycontest-158/","link":"","permalink":"https://sinclaircoder.top/2019/10/13/2019-10-13-leetcodeweeklycontest-158/","excerpt":"","text":"戒骄戒躁，勇往直前。 传送门：第 158 场周赛分割平衡字符串在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。返回可以通过分割得到的平衡字符串的最大数量。输入：s = “RLRRLLRLRL”输出：4解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。 思路用两个数组记录当前出现的R和L的次数，进行比对相等则cnt+1。 实现class Solution { public: int balancedStringSplit(string s) { int n = s.length(),cnt=0; int rcnt[n]={0},lcnt[n]={0}; for(int i=0;i&lt;s.length();i++){ rcnt[i]=(i==0?0:rcnt[i-1]); lcnt[i]=(i==0?0:lcnt[i-1]); if(s[i]==&#39;R&#39;) rcnt[i]++; if(s[i]==&#39;L&#39;) lcnt[i]++; if(lcnt[i]==rcnt[i]) cnt++; } return cnt; } }; 可以攻击国王的皇后在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。「黑皇后」在棋盘上的位置分布用整数坐标数组 queens 表示，「白国王」的坐标用数组 king 表示。「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。 思路第一反应想起了8皇后，基本上还是以国王为中心遍历8个方向，在一个方向碰到一个皇后，就立刻停止，push进result，然后遍历剩余的方向。注意：vector数组的初始化。 实现class Solution { public: vector&lt;vector&lt;int&gt;&gt; queensAttacktheKing(vector&lt;vector&lt;int&gt;&gt;&amp; queens, vector&lt;int&gt;&amp; king) { vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; tmp(queens[0].size()); // 要初始化 不然报 reference binding to null pointer of type ‘value_type’ vector&lt;vector&lt;int&gt; &gt;::iterator it; int dx[8]={-1,0,1,-1,1,-1,0,1}; int dy[8]={-1,-1,-1,0,0,1,1,1}; for(int i=0;i&lt;8;i++){ tmp[0]=king[0],tmp[1]=king[1]; while(1){ tmp[0] = tmp[0]+dx[i]; tmp[1] = tmp[1]+dy[i]; if(tmp[0]&gt;=0&amp;&amp;tmp[0]&lt;8&amp;&amp;tmp[1]&gt;=0&amp;&amp;tmp[1]&lt;8){ it = find(queens.begin(),queens.end(),tmp); // 最近用find老是出错 if(it!=queens.end()){ res.push_back(tmp); break; } } else break; } } return res; } }; 掷骰子模拟有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。 思路1请参考 [Chinese/C++] 1223. 【动态规划】有限制的掷骰子（详解） 实现1class Solution{ vector&lt;int&gt; rollMax ; typedef long long ll; int dp[5005][6][16]; int mod = 1e9+7; ll dfs(int num,int k,int n){ if(n==0) return 1; if(dp[n][num][k]!=-1) return dp[n][num][k]; ll ans =0; for(int i=0;i&lt;6;i++){ if(i!=num) ans += dfs(i,1,n-1); else if(k&lt;rollMax[i]) // 注意不能等于,如果等于就不能加一了。 ans += dfs(num,k+1,n-1); else ; } return dp[n][num][k]=ans%mod; } public : int dieSimulator(int n, vector&lt;int&gt;&amp; rollMax) { this-&gt;rollMax = rollMax; memset(dp,-1,sizeof(dp)); return dfs(0,0,n)%mod; } }; 思路2用一个三维数组表示的话。v[k][i][j]表示第k轮扔出i点的骰子，并且这个点数已经连续出现j次时的序列的个数。 如果下一轮的点数和这一轮最后的点数不同的时候：v[k+1][c][1] += v[k][i][j]如果下一轮的点数和这一轮最后的点数相同并且依然不超过这个点最大的可连续限制的时候：v[k+1][i][j+1] += v[k][i][j] 不过尝试实现了一下，一直显示结果为0，不清楚为什么。欢迎讨论。 class Solution { public: typedef long long ll; int dieSimulator(int n, vector&lt;int&gt;&amp; rollMax) { int mod = 1e9+7; int dp[5002][8][16]={0}; for(int i=0;i&lt;6;i++){ dp[1][i][1]=1; } for(int k=2;k&lt;=n;k++){ for(int i=0;i&lt;6;i++){ for(int j=1;j&lt;k&amp;&amp;j&lt;16;j++){ for(int c=0;c&lt;6;c++){ if(c!=i) dp[k+1][c][1] = (dp[k+1][c][1]+dp[k][i][j])%mod; else if(j&lt;=rollMax[i]) dp[k+1][i][j+1] = (dp[k+1][i][j+1]+dp[k][i][j])%mod; } } } } ll res = 0; for(int i=1;i&lt;6;i++){ for(int j=1;j&lt;n;j++){ res = (res+dp[n][i][j])%mod; } } return res; } }; 最大相等频率给出一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回其长度：从前缀中 删除一个 元素后，使得所剩下的每个数字的出现次数相同。如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。举个例子输入：nums = [2,2,1,1,5,3,3,5]输出：7解释：对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4]=5，就可以得到[2,2,1,1,3,3]，里面每个数字都出现了两次。 思路参考题解： Chinese/C++ ] 1224. 【统计】最大相等频率，详解，O(N) C++,O(n),consider for four situations 打两次表，cnt表是用来记录每种数字出现的次数，freq表记录每个次数出现的频率，其中需要考虑四种情况。 只有频率为A或B的序列，其中A=B+1，比如：[7,7,7,8,8,9,9] 其中A=3，B=2 只有频率为A或B的序列，其中A=1，B!=1 比如：[6,7,7,7,8,8,8,9,9,9] 其中A=1,B=3 每个数字只出现1次 比如：[7,8,9] 所有数字相同，比如：[7,7,7,7,7] 对于情况1，4：1+freq[maxcnt-1](maxcnt-1)==i+1 其中i为nums的当前索引，等式的意义是 从索引等于0到索引等于i之间的元素个数相等。对于情况2：1+freq[maxcnt]maxcnt ==i+1 等式意义同上。上述三种情况 所求结果即此时索引i加1（i&gt;=0&amp;&amp;i&lt;nums.size()）对于情况3：只需 maxcnt ==1，所求结果即为整个nums的长度。 实现class Solution { public: int maxEqualFreq(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; cnt(100003,0),freq(100003,0); int maxcnt = 0,ans = 0; for(int i=0;i&lt;nums.size();i++){ int num = nums[i]; cnt[num]++; freq[cnt[num]]++; maxcnt = max(maxcnt,cnt[num]); // cout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; cnt[num] &lt;&lt; &quot; &quot; &lt;&lt; freq[cnt[num]] &lt;&lt; &quot; &quot; &lt;&lt; maxcnt &lt;&lt; endl; if(1+freq[maxcnt-1]*(maxcnt-1)==i+1||1+freq[maxcnt]*maxcnt==i+1) ans = i+1; } if(maxcnt==1) ans = nums.size(); return ans; } }; 写这次的题解并没有想象中的欢快~ 所以动心忍性，曾益其所不能。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/tags/leetcode/"}],"author":"SinclairWang"},{"title":"LeetCodeWeeklyContest-157","slug":"2019-10-7-LeetCodeWeeklyContest-157","date":"2019-10-06T16:00:00.000Z","updated":"2020-01-21T13:50:54.329Z","comments":true,"path":"2019/10/07/2019-10-7-leetcodeweeklycontest-157/","link":"","permalink":"https://sinclaircoder.top/2019/10/07/2019-10-7-leetcodeweeklycontest-157/","excerpt":"","text":"秋意寂寥，国庆假期归来，”百废待兴”。路漫漫其修远兮，吾将上下而求索。 题目传送玩筹码数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：将第 i 个筹码向左或者右移动 2 个单位，代价为 0。将第 i 个筹码向左或者右移动 1 个单位，代价为 1。最开始的时候，同一位置上也可能放着两个或者更多的筹码。返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。 思路做的时候看了半天，不会写，后来发现题目理解错了，chips上存放的是筹码的位置，偶数位置跳到偶数位置代价为0，偶数位置跳到奇数位置代价为1，奇数位置跳到奇数位置代价为0，奇数位置跳到偶数位置代价为1，假设奇数位置的筹码数量为 evenN，偶数位置的筹码数量为 oldN，最小代价即为 min(evenN,oldN) 实现int minCostToMoveChips(vector&lt;int&gt;&amp; chips) { int even=0,odd=0; for(int &amp;i:chips){ if(i%2==0) odd++; else even++; } return min(even,odd); } 最长定差子序列给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。举个栗子输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2输出：4解释：最长的等差子序列是 [7,5,3,1]。 思路经典dp问题，不过我的dp确实不熟。首先打个表dp，用arr[i]作为dp的索引，dp[j]表示到j为止存在的等差子序列长度的最大值。状态转移方程如下：dp[arr[i]] = dp[arr[i]-d] + 1 实现int longestSubsequence(vector&lt;int&gt;&amp; arr, int difference) { map&lt;int,int&gt; dp; int ans=0; for(int i:arr){ dp[i] = dp[i-difference] + 1; ans = max(dp[i],ans); } return ans; } 没有冗长的代码，真的爱上了这种感觉，写起来真的既轻松又愉快。 黄金矿工你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。为了使收益最大化，矿工需要按以下规则来开采黄金：每当矿工进入一个单元，就会收集该单元格中的所有黄金。矿工每次可以从当前位置向上下左右四个方向走。每个单元格只能被开采（进入）一次。不得开采（进入）黄金数目为 0 的单元格。矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。 思路DFS，其实这里面还是有很多问题要注意一下的，比如dfs函数里的参数tmp不能传引用，而value、visit要传引用，tmp是每次的中间值，每次与value进行比较，用两者的最大值去更新value。另外，leetcode支持c++11，故此代码里用了很多新特性，比如类的属性定义时初始化，vector初始化等，如果要在Dev上跑的话，在文件首部加上下面这一行： #pragma GCC diagnostic error &quot;-std=c++11&quot; 实现class Solution { public: int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0}; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int tmp, int&amp; value, vector&lt;vector&lt;bool&gt;&gt;&amp; visit){ // tmp 不能加引用 if(grid[x][y]==0) return ; value = max(value,tmp += grid[x][y]); visit[x][y] = true; for(int i=0;i&lt;4;i++){ int tmpx = x+dx[i],tmpy = y+dy[i]; if(tmpx&lt;0||tmpx&gt;=grid.size()||tmpy&lt;0||tmpy&gt;=grid[0].size()) continue; // 注意等号 if(grid[tmpx][tmpy]==0||visit[tmpx][tmpy]) continue; dfs(grid,tmpx,tmpy,tmp,value,visit); } visit[x][y] = false; } int getMaximumGold(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m=grid.size(), n=grid[0].size(), result = 0; // bool visit[m][n]={0}; vector&lt;vector&lt;bool&gt;&gt; visit(m,vector&lt;bool&gt;(n,false)); // init for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j]!=0){ dfs(grid,i,j,0,result,visit); } } } return result; } }; 统计元音字母序列的数目给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：字符串中的每个字符都应当是小写元音字母（’a’, ‘e’, ‘i’, ‘o’, ‘u’）每个元音 ‘a’ 后面都只能跟着 ‘e’每个元音 ‘e’ 后面只能跟着 ‘a’ 或者是 ‘i’每个元音 ‘i’ 后面 不能 再跟着另一个 ‘i’每个元音 ‘o’ 后面只能跟着 ‘i’ 或者是 ‘u’每个元音 ‘u’ 后面只能跟着 ‘a’由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。 思路一其实就是一个状态转移方程？用dp来记录a,e,i,o,u开头的固定长度的字符串对应的方案个数。初始时dp[i]=1, 其中0&lt;=i&lt;5进行n次循环的ndp状态数组用来记录此时对应的方案个数最重要的是根据题目中的字符串相邻规则，找到状态转移方程。ndp[0] = dp[1];ndp[1] = (dp[0]+dp[2])%mod;ndp[2] = (dp[0]+dp[1]+dp[3]+dp[4])%mod;ndp[3] = (dp[2]+dp[4])%mod;ndp[4] = dp[0];具体实现看实现一，其中数据类型要用long long ，用int会爆掉。 实现一class Solution { public: typedef long long ll; const int mod = 1e9 + 7; int countVowelPermutation(int n) { ll dp[5]={1,1,1,1,1}; ll ndp[5]={0}; for(int i=1;i&lt;n;i++){ ndp[0] = dp[1]; ndp[1] = (dp[0]+dp[2])%mod; ndp[2] = (dp[0]+dp[1]+dp[3]+dp[4])%mod; ndp[3] = (dp[2]+dp[4])%mod; ndp[4] = dp[0]; for(int j=0;j&lt;5;j++) dp[j] = ndp[j]; } ll ans = 0; for(int i=0;i&lt;5;i++) ans += dp[i]; return ans%mod; } }; 思路二在力扣讨论区看到这样一句话 这个题数据量再大一些就应该采用 矩阵来做运算，并可以通过矩阵快速幂来加速运算 我的第一反应是根据题目中的字符串相邻规则构造一个邻接矩阵，这个时候离散数学就应该派上用场了，思考邻接矩阵的n次幂的意义为何？实际上，求长度为n的字符串实际上就是求邻接矩阵的n-1次幂，这里需要用到矩阵的幂运算，这个时候就可以使用矩阵的快速幂，网上找了个板子，改了改，没想到就过掉了。 实现二const int N=5; typedef long long ll; class Matrix{ //矩阵结构体 public: ll matrix[N][N]; }; class Solution { public: const int mod = 1e9 + 7; //初始化为单位矩阵 void init(Matrix &amp;res){ memset(res.matrix,0,sizeof(res.matrix)); for(int i=0;i&lt;N;i++) res.matrix[i][i]=1; } //矩阵乘法 Matrix multiplicative(Matrix a,Matrix b){ Matrix res; memset(res.matrix,0,sizeof(res.matrix)); for(int i = 0 ; i &lt; N ; i++){ for(int j = 0 ; j &lt; N ; j++){ for(int k = 0 ; k &lt; N ; k++){ res.matrix[i][j] += a.matrix[i][k]*b.matrix[k][j]; res.matrix[i][j] %= mod; } } } return res; } //矩阵快速幂 Matrix Pow(Matrix mx,ll m){ Matrix res,base=mx; init(res); while(m){ if(m&amp;1) res=multiplicative(res,base); base=multiplicative(base,base); m&gt;&gt;=1; } return res; } int countVowelPermutation(int n) { if(n==1) return 5; const int MOD = 1e9+7; Matrix mat; memset(mat.matrix,0,sizeof(mat.matrix)); mat.matrix[0][1]=1; mat.matrix[1][0]=1,mat.matrix[1][2]=1; mat.matrix[2][0]=1,mat.matrix[2][1]=1,mat.matrix[2][3]=1,mat.matrix[2][4]=1; mat.matrix[3][2]=1,mat.matrix[3][4]=1; mat.matrix[4][0]=1; Matrix result = Pow(mat,n-1); int ans = 0; for(int i=0;i&lt;N;i++){ for(int j=0;j&lt;N;j++){ ans += result.matrix[i][j]; ans = ans%MOD; // 这里要取一次余，不然会爆范围 // cout &lt;&lt; result.matrix[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return ans%MOD; } }; 感悟每写一次周赛题解，都会去看很多大神的代码，学到很多东西，总觉得我的coding水平好像又进步了？ 坏了，是错觉…","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/tags/leetcode/"}],"author":"SinclairWang"},{"title":"《Python数据分析与应用》复现笔记","slug":"2019-10-4-《Python数据分析与应用》复现笔记","date":"2019-10-03T16:00:00.000Z","updated":"2020-01-21T13:49:12.785Z","comments":true,"path":"2019/10/04/2019-10-4-python-shu-ju-fen-xi-yu-ying-yong-fu-xian-bi-ji/","link":"","permalink":"https://sinclaircoder.top/2019/10/04/2019-10-4-python-shu-ju-fen-xi-yu-ying-yong-fu-xian-bi-ji/","excerpt":"","text":"Numpy arr.ravel() 完成数组的展开工作 arr.flatten() 展平数组，可以选择横向（’A’）或者纵向（’F’）展开 np.hstack() 横向组合 np.vstack() 纵向组合 np.concatenate() 通过调参数axis来实现横向或者纵向组合，axis=1 为横向组合，axis=0为纵向组合 np.hsplit() 横向分割 np.vsplit() 纵向分割 np.split() 通过调参数axis来实现横向或者纵向分割，axis=1 为横向分割，axis=0为纵向分割 np.multiply(mat1,mat2) 两个矩阵点乘 mat1.T 矩阵的转置矩阵 mat1.H 共轭转置 mat1.I 矩阵的逆 mat1.A 返回自身数据的二维数组的一个视图 np.save() 以二进制格式保存数据 np.load() 从二进制的文件中读取数据 注：存储的时候可以省略扩展名，但读取的时候 np.savetxt(fname,data,fmt=”%.18e”,delimiter=’’”,newline=’\\n’,header=’’,footer=’’,comments=’#’) 将数组写到某种分隔符隔开的文本文件中 np.loadtxt(fname,data,delimiter=’’”）把一个文件加载到一个二维数组中 np.genfromtxt(fname,delimiter=””,names) 和loadtxt很相似，它面向的是结构化数组和缺失的数据 np.sort() 最常用的排序函数 arr.sort(axis=1) 沿横轴排序 arr.sort(axis=0) 沿纵轴排序 arr.argsort() 给定一个或多个键时，得到一个由整数构成的索引数组，索引值表示数据在新序列中的位置 arr.lexsort() 一次性对满足多个键的数组执行间接排序，与argsort()相似，返回索引数组 np.unique() 找出数组中的唯一值并返回已排序的结果 sorted() 可以对所有可迭代的对象进行排序操作 list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作 np.tile(A,reps) 将数组A重复reps次 np.repeat(a,repeats,axis) 将数组a 沿着特定的 轴进行重复 tile函数是对数组进行重复操作，而repeat函数对数组中的每个元素进行重复操作 np.cumsum() 计算数组累计和 np.cumprod() 计算数组累计积 Pandas pd.read_sql_table(table_name,con) 只能读取数据库的一个表格，不能实现查询的操作 pd.read_sql_query(sql,con) 只能执行查询操作，不能直接读取数据库中的某个表 pd.read_sql(sql,con) 既能读取数据库中的某一个表，也能够执行查询操作 DataFrame.to_sql(table_name,con) 将DataFrame写入数据库，同样也要依赖SQLAlchemy库的create_engine函数创建数据库连接 pd.read_csv(filepath,sep) 读取CSV文件 pd.read_table(filepath,sep) 读取文本文件 DataFrame.to_csv(path_or_buf) 对于结构化数据，可以通过pandas中的to_csv函数实现以CSV文件格式存储 pd.read_excel(filepath,sep) 读取文本文件 DataFrame.to_excel(excel_writer) 将文件存储为Excel文件 DataFrame.loc[行索引名称，列索引名称] 切片 包括最后索引 DataFrame.iloc[行索引位置，列索引位置] 切片 不包括最后索引 DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True，group_keys=True，squeeze=False) 能够根据索引或者字段对数据进行分组，by用于确定进行分组的依据，axis默认为0，默认对列进行操作，level表示标签所在的级别，as_index 表示聚合标签是否以DataFrame索引形式输出，sort是否对分组进行排序，group_keys是否显示分组标签的名称，squeeze表示是否允许对返回数据进行降维。 DataFrame.agg(func,axis=0) DataFrame.aggregate(func,axis=0) agg函数和aggregate函数都支持对每个分组应用某个函数（包括内置函数和自定义函数），这两个方法也能直接对DataFrame进行函数应用操作。 DataFrame.apply(func，axis=0) 能将函数应用于每一列，但是无法像agg一样能够对不同字段应用不同函数来获取不同结果。 DataFrame.transform(func) 能够对整个DataFrame的所有元素进行操作 pd.pivot_table(data,values=None,index=Nobe,columns=None,aggfunc=’mean’) 实现透视表，data表示创建表的数据，values用于指定要聚合的数据字段名，index表示行分组键，columns表示列分组键，aggfunc表示聚合函数 pd.crosstab(index,columns,values) 创建交叉表，主要用于计算分组频率，crosstab函数中的index，columns、values都是从DataFrame中取出的某一列","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://sinclaircoder.top/categories/数据分析/"},{"name":"Python3","slug":"数据分析/Python3","permalink":"https://sinclaircoder.top/categories/数据分析/Python3/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"https://sinclaircoder.top/tags/数据分析/"}],"author":"SinclairWang"},{"title":"修改Jupyter Notebook的默认存储路径","slug":"2019-10-2-修改Jupyter Notebook的默认存储路径","date":"2019-10-01T16:00:00.000Z","updated":"2020-01-21T13:47:35.100Z","comments":true,"path":"2019/10/02/2019-10-2-xiu-gai-jupyter-notebook-de-mo-ren-cun-chu-lu-jing/","link":"","permalink":"https://sinclaircoder.top/2019/10/02/2019-10-2-xiu-gai-jupyter-notebook-de-mo-ren-cun-chu-lu-jing/","excerpt":"","text":"最近在复现数据分析，发现JupyterNotebook默认存储路径在C盘 /user/.jupyter里面想改一下默认存储路径。 step1进入Anaconda安装路径，一般来说都是 */Anaconda3/Scripts，比如我的就是在 E:\\Python\\Anaconda\\INSTALL\\Scripts这个路径下，在cmd中将路径转到该路径下，这样替换代码如下，其中路径替换成自己的。 &gt;&gt; cd E:\\Python\\Anaconda\\INSTALL\\Scripts &gt;&gt; e: step2在cmd中输入命令： jupyter notebook --generate-config 然后就会在C盘用户路径（例如我的路径是：C:\\Users\\三寸旧城七寸执念\\.jupyter）下生成jupyter_notebook_config.py文件，使用文本编辑器（VS Code等）打开该文件。 step3定位到第246行 #c.NotebookApp.notebook_dir = &#39;&#39; 替换为 c.NotebookApp.notebook_dir = &#39;E:/CodeCache/JupyterNotebook&#39; step4右击JupyterNotebook的快捷方式点击属性，将目标那一栏里的%USERPROFILE%删掉，应该就可以了。 重启Jupyter Notebook。 另外，需要给Jupyter NoteBook 换主题，换字体，字号，以及代码自动补全可参考使用 Jupyter Themes 修改 Jupyter Notebook 的主题、字体、字号Jupyter Notebook 更换主题、设置字体(jupyterthemes的使用)、代码自动补全、变更工作目录（默认目录） 其实个人觉得貌似也没有好看的字体，传说中的Consolas字体貌似也不支持，主题换来换去其实还不如最初的默认的。其实个人觉得比较有用的还是代码补全。另外，需要注意里面的命令行是在 Anaconda Prompt输入的，而非cmd。","categories":[{"name":"Python3","slug":"Python3","permalink":"https://sinclaircoder.top/categories/Python3/"}],"tags":[{"name":"JupyterNotebook","slug":"JupyterNotebook","permalink":"https://sinclaircoder.top/tags/JupyterNotebook/"}],"author":"SinclairWang"},{"title":"LeetCodeWeeklyContest-156","slug":"2019-10-2-LeetCodeWeeklyContest-156","date":"2019-10-01T16:00:00.000Z","updated":"2020-01-21T13:45:05.272Z","comments":true,"path":"2019/10/02/2019-10-2-leetcodeweeklycontest-156/","link":"","permalink":"https://sinclaircoder.top/2019/10/02/2019-10-2-leetcodeweeklycontest-156/","excerpt":"","text":"题目传送写题解就像写博客一样真的有好处，尽管会多花点时间。 1 、独一无二的出现次数描述给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 思路统计出现次数，然后排序。有相同的为false，否则为true。 实现 bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) { int a[2001]={0}; for(int i=0;i&lt;arr.size();i++){ a[arr[i]+1000]++; } sort(a,a+2001); for(int i=0;i&lt;2000;i++){ if(a[i]==a[i+1]&amp;&amp;a[i]!=0){ return false; } } return true; } 时间复杂度：O(nlog2n) 2、尽可能使字符串相等描述给你两个长度相同的字符串，s 和 t。将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。 思路官方题解说这是本场比赛里面最好的题目了。使用滑动窗口思想。一般使用滑动窗口思想，求解一个序列中连续k个数的最值问题 下面以s=”pxezla”,t=”loewbi”,maxCost=25为例 index 0 1 2 3 4 5 string1 p x e z l a string2 l o e w b i \\ cost[i]\\ 4 9 0 3 10 8 \\ sum[i]\\ 4 13 13 16 26 34 分别使用left，right表示cost数组的左右索引。left=0,right=0只要curCost小于maxCost,就right++当出现maxCost&lt;curCost时，则需要使left—，即向右整体滑动，貌似有点改进的kmp算法的感觉。最大长度best = max(best,right-left+1);只需滑动一次，即得最大值，对应的cost数组段为[9 0 3 10] 实现一class Solution { public: int equalSubstring(string s, string t, int maxCost) { vector&lt;int&gt; c; for(int i=0;i&lt;s.size();i++){ c.push_back(abs(s[i]-t[i])); } int curCost = 0,cnt=0; for(int i=0,j=0;i&lt;s.size();i++){ curCost += c[i]; while(curCost&gt;maxCost){ curCost -= c[j]; j++; } cnt = max(cnt,i-j+1); } return cnt; } }; 实现二class Solution { public: int equalSubstring(string s, string t, int maxCost) { vector&lt;int&gt; sumArr; int ans =0; sumArr.push_back(ans); // 很关键的处理 for(int i=0;i&lt;s.size();i++){ ans += abs(s[i]-t[i]); // cout &lt;&lt; ans &lt;&lt; endl; sumArr.push_back(ans); } int curCost = 0,cnt=0; for(int i=1,j=0;i&lt;=s.size();i++){ // 注意这里的等号，仔细想想为甚麽？ for(;sumArr[i]-sumArr[j]&gt;maxCost;j++); cnt = max(cnt,i-j); } return cnt; } }; 时间复杂度：O(n) 3、删除字符串中的所有相邻重复项 II描述给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。在执行完所有删除操作后，返回最终得到的字符串。本题答案保证唯一。 思路参考官方题解，维护一个栈，栈元素类型为 pair ，其中char类型为对应的字符串的s[i]，int类型为对应的个数，由于本题保证答案唯一，题目大大简化，所以最后个数等于k的字符一定可以被删掉。扫描字符串s，使字符依次进栈，若栈顶的字母对应的个数等于k，便出栈k次。 实现class Solution { public: string removeDuplicates(string s, int k) { stack&lt;pair&lt;char,int&gt; &gt; st; for(int i=0;i&lt;s.size();i++){ if(st.empty()) st.push(make_pair(s[i],1)); else { if(st.top().first==s[i]){ st.push(make_pair(s[i],st.top().second+1)); } else st.push(make_pair(s[i],1)); } if(st.top().second==k){ for(int i=0;i&lt;k;i++){ st.pop(); } } } string result; while(st.size()){ result += st.top().first; st.pop(); } reverse(result.begin(),result.end()); return result; } }; 时间复杂度：O(n) 4、穿过迷宫的最少移动次数略","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/tags/leetcode/"}],"author":"SinclairWang"},{"title":"设计模式(一)","slug":"2019-09-24-设计模式(一)","date":"2019-09-23T16:00:00.000Z","updated":"2020-01-21T13:43:45.379Z","comments":true,"path":"2019/09/24/2019-09-24-she-ji-mo-shi-yi/","link":"","permalink":"https://sinclaircoder.top/2019/09/24/2019-09-24-she-ji-mo-shi-yi/","excerpt":"","text":"简介 软件模式 软件开发中的重复出现的问题的解决方案，可认为是设计经验，在讨论问题的解决方案时，一种可交流的词汇 设计模式 简言之，就是可重复使用的设计经验，主要还是为了达到优化设计的目的 软件开发中的几个模式 业务领域模式 分析模式 设计模式 Idioms模式 记录设计模式的四个要素 名称 问题 方案 效果 设计模式的起源 软件领域的设计模式起源于建筑学 建筑大师Alexander出版了《A pattern Language：Towns，Building，Construction》一书，将建筑领域的许多问题的最佳解决方案记录为200多种模式，其著作的思想不仅在建筑行业影响深远，很快影响到了软件设计领域 目前，被公认的在设计模式最有影响力的著作Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides的著作《Design Pattern：Elements of Reusable Object-Orient Software》(《设计模式：可复用的面向对象软件的基本原理》)，讲述了23个设计模式，四位作者的著作成为空前畅销书，被大众戏称GOF之书，学习设计模式必读著作 框架与设计模式的区别 层次不同 模式比框架更抽象，框架不是一种可重用的设计方案，是为解决某种问题的一些类的集合 范围不同 模式本质上是逻辑概念，框架是以具体的软件组织存在的 相互关系 一个框架会包含多个设计模式，一个著名的框架往往是许多设计模式的具体体现 面向对象的几个基本原则 面向抽象原则 抽象类 可以有抽象方法也可以有非抽象方法 不能用new运算符创建对象 子类必须重写父类的abstract方法 可作为上转型对象 接口 接口中只能有public权限的abstract的方法，能不能有abstract方法 接口由类来实现，必须重写接口中的abstract方法 接口回调 可以把实现接口的类的对象的引用赋给该接口声明的接口变量中，那么该接口变量就可以调用被类实现的接口中的方法 // Com.java public interface Com{ public abstract int sub(int x,int y); } // ComImp.java class ComImp implements Com{ public int sub(int x,int y){ return x-y; } } // Application.java public class Application{ public static void main(String args[]){ Com com; com = new ComImp(); int m = com.sub(8,2); system.out.println(m); } } 所谓面向抽象编程，是指设计一个类的时候，不让该类面向具体的类，而是面向抽象类或接口，即所设计类中的重要数据是抽象类或接口声明的变量，而不是具体类声明的变量 举个例子，计算一个柱体的体积。 // Geometry.java public abstract class Geometry { public abstract double getArea(); } // Pillar.java public class Pillar { private Geometry bottom; // 抽象类 private double height; Pillar(Geometry bottom,double height){ this.bottom = bottom; this.height = height; } public double getVolume(){ return bottom.getArea()*height; // bottom可以调用子类重写的getArea方法 } } // Circle.java public class Circle extends Geometry { private double r; Circle(double r){ this.r = r; } @Override public double getArea() { return Math.PI*r*r; } } // Rectangle.java public class Rectangle extends Geometry { private double a,b; public Rectangle(double a, double b) { this.a = a; this.b = b; } @Override public double getArea() { return a*b; } } // Application.java public class Application { public static void main(String[] args) { Pillar pillar; Geometry bottom; bottom = new Rectangle(12,22); pillar = new Pillar(bottom,58); System.out.println(&quot;矩形底的体积为：&quot;+pillar.getVolume()); bottom = new Circle(10); pillar = new Pillar(bottom,58); System.out.println(&quot;圆形底的体积为：&quot;+pillar.getVolume()); } } 开-闭原则 设计对扩展开放，对修改关闭,实际上这句话的本质是指当一个设计中增加新的模块时不需要修改现有模块。 多用组合少用继承原则 继承与复用 通过继承，子类与父类的关系是强耦合关系，即父类方法的行为更改时，必然导致子类发生变化 通过继承的复用也称为“白盒复用”，其缺点是父类的内部细节对于子类而言是可见的 组合与复用 也即“Has-A”,一个对象是由几个对象组合而成 组合对象来复用的方法称为“黑盒”复用 对象与所包含的对象属于弱耦合关系 可以在运行时，动态指定所包含的对象 高内聚-低耦合原则 如果类中的方法是一组相关的行为，则称该类是高内聚的，反之，则称是低内聚 所谓低耦合就是不要让一个类包含太多其他的类的实例引用，以避免修改一部分会影响到另一部分","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://sinclaircoder.top/categories/软件工程/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://sinclaircoder.top/tags/设计模式/"}],"author":"SinclairWang"},{"title":"蛮力法求解幂集问题","slug":"2019-09-23-蛮力法求解幂集问题","date":"2019-09-22T16:00:00.000Z","updated":"2020-01-21T13:38:07.352Z","comments":true,"path":"2019/09/23/2019-09-23-man-li-fa-qiu-jie-mi-ji-wen-ti/","link":"","permalink":"https://sinclaircoder.top/2019/09/23/2019-09-23-man-li-fa-qiu-jie-mi-ji-wen-ti/","excerpt":"","text":"问题描述对于给定的正整数n(n&gt;=1),求1到n构成的集合的幂集（包括全集和空集） 解法一 直接枚举法思路将二进制位与幂集对应起来，n的幂集个数为$2^n$，每一个二进制位代表一个元素。下面以n等于3为例。 集合元素 对应的二进制位 对应的十进制数 { } 000 - {1} 001 1 {2} 010 2 {1，2} 011 3 {3} 100 4 {1，3} 101 5 {2，3} 110 6 {1，2，3} 111 7 算法复杂度: $O(n*2^n)$ 实现#include&lt;bits/stdc++.h&gt; using namespace std; /* Alogorithm Design 蛮力法 1.直接枚举法求解幂集问题 */ // 将b表示的二进制加1 // b数组下表从小到大对应从低到高位 int inc(int b[],int n){ for(int i=0;i&lt;n;i++){ if(b[i]) b[i]=0; else{ b[i] = 1; break; } } } void PSet(int a[],int b[],int n){ int pw = (int)pow(2,n); printf(&quot;1到%d的幂集为：\\n&quot;,n); for(int i=0;i&lt;pw;i++){ cout &lt;&lt; &quot;{&quot;; for(int i=0;i&lt;n;i++){ if(b[i]) printf(&quot; %d &quot;,a[i]); } cout &lt;&lt; &quot;}&quot;; inc(b,n); } cout &lt;&lt; endl; } int main() { int n=3; int a[10],b[10]; for(int i=0;i&lt;n;i++){ a[i] = i+1; b[i] = 0; } PSet(a,b,n); return 0; } 解法二 枚举增量法思路从最初的空集开始，往里面加第一个元素，将得到的子幂集与原来的幂集合并，就得到了新的子幂集，然后再重复以上操作。算法复杂度: $O(2^n)$ 实现#include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;vector&lt;int&gt; &gt; PSet; // 全局变量 存放幂集 void PSetSolve(int n){ vector&lt;vector&lt;int&gt; &gt; tmp; // 子幂集 vector&lt;int&gt; v; PSet.push_back(v); vector&lt;vector&lt;int&gt; &gt;::iterator pit; vector&lt;int&gt;::iterator it; for(int i=1;i&lt;=n;i++){ tmp = PSet; for(pit=tmp.begin();pit!=tmp.end();pit++){ (*pit).push_back(i); } for(pit=tmp.begin();pit!=tmp.end();pit++){ PSet.push_back(*pit); } } } // 打印幂集 void disp(int n){ printf(&quot;1到%d的幂集为：\\n&quot;,n); for(int i=0;i&lt;pow(2,n);i++){ vector&lt;int&gt; v = PSet[i]; cout &lt;&lt; &quot;{&quot;; for(int j=0;j&lt;v.size();j++) printf(&quot; %d &quot;,v[j]); cout &lt;&lt; &quot;}&quot;; } } int main() { int n = 3; PSetSolve(n); disp(n); return 0; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"幂集问题","slug":"幂集问题","permalink":"https://sinclaircoder.top/tags/幂集问题/"}],"author":"SinclairWang"},{"title":"联想Y7000装Ubuntu双系统路上的坑","slug":"2019-09-22-联想Y7000装Ubuntu双系统路上的坑","date":"2019-09-21T16:00:00.000Z","updated":"2020-01-21T13:34:46.217Z","comments":true,"path":"2019/09/22/2019-09-22-lian-xiang-y7000-zhuang-ubuntu-shuang-xi-tong-lu-shang-de-keng/","link":"","permalink":"https://sinclaircoder.top/2019/09/22/2019-09-22-lian-xiang-y7000-zhuang-ubuntu-shuang-xi-tong-lu-shang-de-keng/","excerpt":"","text":"三言两语道不尽心酸，一句两句说不尽心酸一个Ubuntu装了2天，装的无比心酸一直报ACPI错误，后来加上nomodeset才搞定后来专门搜了一下联想Y7000装Ubuntu的教程才知道这是联想显卡的问题。而且最好装Ubuntu 16.04.5 下面是一些参考文章：关于在联想Y7000上安装ubuntu和win10双系统的卡死坑 y7000安装ubuntu和一些小tips ubuntu 添加中文拼音输入法 Ubuntu16.04系统查看已安装的python版本，及其配置 其实装上Ubuntu之后，还有很多事情要做，很多环境要配，显卡要修改，就不一一列出了，主要是前面进入开机界面太艰难了，写篇博客记录下。 2019年9月30日更新 windows休眠，没有彻底关闭Ubuntu 无法访问windows下的磁盘的解决方法Ubuntu系统打不开windows磁盘文件","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sinclaircoder.top/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://sinclaircoder.top/tags/Ubuntu/"}],"author":"SinclairWang"},{"title":"LeetCodeWeeklyContest-155","slug":"2019-09-22-LeetCodeWeeklyContest-155","date":"2019-09-21T16:00:00.000Z","updated":"2020-01-21T13:21:16.672Z","comments":true,"path":"2019/09/22/2019-09-22-leetcodeweeklycontest-155/","link":"","permalink":"https://sinclaircoder.top/2019/09/22/2019-09-22-leetcodeweeklycontest-155/","excerpt":"","text":"操千曲而晓声,观千剑而后识器 —— 《文心雕龙》 力扣的周赛自闭了，好久没写了，丢掉的改捡了。 题目传送个人博客同步更新 Problem1 最小绝对差 难度：Easy题目 给你个整数数组 arr，其中每个元素都 不相同。请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 思路 遍历，边找边push，只需一遍 貌似代码写复杂了 题解#include&lt;bits/stdc++.h&gt; using namespace std; /* LeetCode WeeklyContest-155 */ vector&lt;vector&lt;int&gt; &gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) { sort(arr.begin(),arr.end()); int n=arr.size(); vector&lt;vector&lt;int&gt; &gt; result; int min = arr[1]-arr[0]; vector&lt;int&gt; tmp; for(int i=0;i&lt;n-1;i++){ if(arr[i+1]-arr[i] &lt; min){ min = arr[i+1]-arr[i]; result.clear(); tmp.push_back(arr[i]); tmp.push_back(arr[i+1]); result.push_back(tmp); tmp.clear(); } else if(arr[i+1]-arr[i] == min){ tmp.push_back(arr[i]); tmp.push_back(arr[i+1]); result.push_back(tmp); tmp.clear(); } else ; } return result; } // 测试下 int main() { vector&lt;int&gt; v; v.push_back(-20); v.push_back(11); v.push_back(26); v.push_back(27); v.push_back(40); vector&lt;vector&lt;int&gt; &gt; result = minimumAbsDifference(v); vector&lt;vector&lt;int&gt; &gt;::iterator rIt; vector&lt;int&gt;::iterator it; for(rIt = result.begin();rIt!=result.end();rIt++){ for(it = (*rIt).begin();it!=(*rIt).end();it++){ cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return 0; } Problem 2 丑数 III题目 请你帮忙设计一个程序，用来找出第 n 个丑数。丑数是可以被 a 或 b 或 c 整除的 正整数。1 &lt;= n, a, b, c &lt;= 10^91 &lt;= a b c &lt;= 10^18本题结果在 [1, 2 * 10^9] 的范围内 难度：Medium 思路 无脑暴力$1到\\min(na,nb,n*c)$ 超时。 无脑开个数组，把 $ia、ib、i*c$ 其中$i=1…n$,然后写个sort(),直接取第n个数，内存爆掉。 以上都是不可取的**计算1~m之间有多少丑数，设为cnt，然后从n开始折半查找，判断cnt与n的关系，最后直接定位到第n个丑数。另外，如何判断1~m之间有多少丑数？公式如下： cnt = m/a + m/b + m/c - m/lcm(a,b)- m/lcm(b,c) - m/lcm(a,c) + m/lcm(lcm(a,b),c)其中$lcm(a,b)$是a、b的最小公倍数。** 题解/* LeetCode WeeklyContest-155 */ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; // 避免超范围 ，不妨都写成ll ll gcd(int x, int y){ if(x&gt;y) swap(x,y); int r = y%x; if(r==1) return 1; while(r){ y = x; x = r; r = y%x; } return x; } ll lcm(int x, int y){ return x/gcd(x,y)*y; } bool countLessN(ll m,int a,int b,int c,int n){ int cnt = m/a + m/b + m/c - m/lcm(a,b) - m/lcm(b,c) - m/lcm(a,c) + m/lcm(lcm(a,b),c); return cnt &gt;= n; } int nthUglyNumber(int n, int a, int b, int c) { ll begin =1,end=2e10+5; while(begin+1&lt;end){ // 注意是begin+1&lt;end int mid = (begin+end)/2; if(countLessN(mid,a,b,c,n)) end = mid; else begin=mid; } return end; } // 测试下 int main() { int n,a,b,c; n = 1000000000, a = 2, b = 217983653, c = 336916467; cout &lt;&lt; nthUglyNumber(n,a,b,c); return 0; } Problem3题目 给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。你可以 任意多次交换 在 pairs 中任意一对索引处的字符。返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。 难度：Medium 思路先根据索引对建立并查集，构成若干个连通分量，每个连通分量内部排序，使其排成最小字典序，然后再将排完序的连通分量复原，就可以得到最小字典序的字符串了。 题解#include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; father,sz; int find(int x){ // 并查集 查 return father[x]==x?x:father[x] = find(father[x]); } string smallestStringWithSwaps(string s,vector&lt;vector&lt;int&gt; &gt; pairs){ int n=s.size(); father.resize(n); sz.resize(n); for(int i=0;i&lt;n;i++){ // 初始化 father[i] = i; sz[i] = 1; } int n1 = pairs.size(); for(int i=0;i&lt;n1;i++){ vector&lt;int&gt; tmp = pairs[i]; int f1 = find(tmp[0]),f2=find(tmp[1]); if(f1!=f2){ if(sz[f1]&lt;sz[f2]){ father[f1] = f2; sz[f2] += sz[f1]; } else{ father[f2] = f1; sz[f1] += sz[f2]; } } } vector&lt;vector&lt;char&gt; &gt; charArr(n); vector&lt;vector&lt;int&gt; &gt; posArr(n); // 并查集发挥作用 for(int i=0;i&lt;n;i++){ charArr[find(i)].push_back(s[i]); posArr[find(i)].push_back(i); } // char数组排序 for(int i=0;i&lt;charArr.size();i++){ sort(charArr[i].begin(),charArr[i].end()); } // 把排完序的联通块，合到一起 string s1(n,&#39;\\0&#39;); for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;charArr[i].size();j++){ s1[posArr[i][j]] = charArr[i][j]; } } return s1; } // 测试下 int main() { string s=&quot;cba&quot;; vector&lt;vector&lt;int&gt; &gt; v; vector&lt;int&gt; s1,s2; s1.push_back(0); s1.push_back(1); s2.push_back(1); s2.push_back(2); v.push_back(s1),v.push_back(s2); cout &lt;&lt; smallestStringWithSwaps(s,v) &lt;&lt; endl; return 0; } Problem4 项目管理略","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://sinclaircoder.top/tags/leetcode/"}],"author":"SinclairWang"},{"title":"数学建模集训知识大纲","slug":"2019-09-16-数学建模集训知识大纲","date":"2019-09-15T16:00:00.000Z","updated":"2020-01-21T13:13:13.399Z","comments":true,"path":"2019/09/16/2019-09-16-shu-xue-jian-mo-ji-xun-zhi-shi-da-gang/","link":"","permalink":"https://sinclaircoder.top/2019/09/16/2019-09-16-shu-xue-jian-mo-ji-xun-zhi-shi-da-gang/","excerpt":"","text":"评价算法简单加权法 线性加权 非线性加权 逼近于理想解的排序法(TOPSIS算法)层次分析法主成分分析法模糊综合评价法聚类分析法秩和比法人工神经网络熵权法灰色关联度分析预测算法插值拟合 小样本内部预测 回归模型预测 大样本内部预测 灰色预测GM 小样本未来预测 时间序列 大样本的随机因素或周期特征的未来预测 神经网络 针对大样本的内部机理复杂的数据的未来预测 统计分析方差分析 分析因变量的总误差中，除开随机误差以外，是否有类别变量（自变量）造成的处理误差，有多少误差是自变量造成的 分类 单自变量 单因素方差分析 两个自变量 无重复双因素分析：只考虑主效应，不考虑交互效应 可重复双因素分析：考虑主效应，也考虑交互效应 回归分析多元统计分析 分类 聚类分析 判别分析 综合评价 主成分分析 从原来的坐标系转换到新的坐标系，第一个新坐标轴选择的是原始数据中方差最大的方向，第二个坐标轴选择的是和第一个新坐标轴正交且具有最大方差的方向。该过程一直重复，重复次数为原始数据中特征的数目。 因子分析 隐变量和某些噪声的组合 典型相关分析 偏最小二乘回归 分类问题 神经网络 逻辑回归 判别分析 最邻近方法 朴素贝叶斯 支持向量机 决策树 集成学习 ROC曲线 假设检验（非参数） 分布拟合检验 秩和检验 如果两个样本来自两个独立的但非正态或形态不清的两总体，要检验两样本之间的差异是否显著，不应运用参数检验中的t检验，而需要采用之和检验 配对检验 K-S 检验 K-S检验不仅能够检验单个总体是否服从某一理论分布，还能够检验两总体分布是否存在显著差异。其原假设是：两组独立样本来自的两总体的分布无显著差异。 Q-Q图 用变量数据分布的分位数与所指定分布的分位数之间的关系曲线来进行检验的 P-P图 根据变量的累积比例与指定分布的累积比例之间的关系所绘制的图形。通过P-P图可以检验数据是否符合指定的分布。当数据符合指定分布时，P-P图中各点近似呈一条直线。 聚类 层次聚类 划分聚类 K-means 网络聚类 聚类评价 共表型相关系数 相似性矩阵 共表矩阵 外部指标 相仪表 调整兰德系数ARI 互信息MI 自助 最优化方法常用算法 模拟退火 神经网络 遗传算法 无约束优化 基本算法 共轭梯度法 在最优化方法中占有重要地位，最速下降法的优点是工作量小，缺点是收敛慢，适用于寻优过程中前期迭代或作为间插步骤，当接近极值点时，宜选用别种收敛快的算法 牛顿法 如果f是对称正定矩阵A的二次函数，用牛顿法经过一次迭代就可到达最优点，如不是二次函数，则牛顿法不能一部达到极值点 牛顿法收敛速度虽然快，但要求Hessian矩阵可逆，要计算二阶导数和逆矩阵，就加大了计算机计算量和存储量。 拟牛顿法 修改了牛顿方向 两种算法 DFP BFGS 有约束优化 罚函数法 通过构造罚函数把约束问题转化为一系列无约束最优化问题，进而用无约束最优化方法求解，这类方法称为序列无约束最小化方法，简称SUMT法（分为SUMT外点法 其二为SUMT内点法） 近似规划法 二次规划 quadprog 一般有约束非线性规划 fmincon 计算机算法动态规划回溯搜索分治贪心分枝定界图论与网络欧拉图二分图 匈牙利算法 网络流 最小费用最大流 最短路径TSP问题 近似算法和启发式算法 二边逐次修正法 P和NP问题背包问题最小生成树 Prime算法 Kruskal算法 图的基本概念及其矩阵表示 无向图 有向图 完全图 二分图 图与网络的数据结构表示方法 邻接矩阵表示法 关联矩阵表示法 弧表表示法 邻接表表示法 星形表示法 常见的网络优化问题 最短路问题 公路连接问题 中国邮递员问题（欧拉图） 旅行商问题TSP（哈密顿图） 运输问题 图像处理基本概念 图像分类 离散图像 用一个数字序列表示的图像，0和1 连续图像 二维坐标系中具有连续变化的图像 矩阵中的元素称为像素，以256灰色等级的数字图像为例，一般由8位，即一个字节表示灰度值 灰度值量化为对应灰度等级 等间隔量化（一般采用这个） 非等间隔量化 数据类 数值数据类 double uint8 uint16 uint32 int8 int16 int32 single char 字符类（逻辑数据类） logical 图像类型 二值图像 二维矩阵由０、１构成，０为黑色，１为白色 通常用于OCR 一般二值图像是逻辑数组，只有０和１的uint8类数组，并不会认为是二值图像，需要使用logical函数 B= logical(A); 灰度图像 即人们常说的256灰度图像，0表示纯黑色，255表示纯白色 二值图像可以看成是灰度图像的一个特例 索引图像 有两个分量。即数据矩阵X和彩色映射矩阵map，矩阵map是一个大小为m*3且由范围在[0,1]之间的浮点值构成的double数组，map数组的长度同它所定义的颜色数目相等，map数组的每一行都定义单色的红绿蓝三个分量，X则是索引矩阵 真彩色RGB图像 是彩色像素的一个mn3数组，其中每一个彩色像素点，都是在特定空间位置的彩色图像相对应的红、绿、蓝三个分量 数据类之间转换 im2uint8 im2uint16 mat2gray：将输入转换为double，范围为[0,1] im2double im2bw 图像类型之间转换 ind2fray gray2ind rgb2ind ind2rgb ntec2rgb rgb2ntsc 使用imtool命令查看一个图像文件的信息 空间滤波器 线性滤波器 使用拉普拉斯滤波器增强图像 使用fspecial生成过滤器以及imfilter的使用 非线性滤波器 一个工具是ordfilt2函数，可以生成统计排序滤波器 g=ordfilt2(f,order,domain) ordfilt2函数生成图像g的方式：使用邻域的一组排序元素中的第order个元素来代替f中的每个元素，该淋雨则由domain中的非零元素指定 数字图像处理中最著名的统计排序滤波器是中值滤波器，对应第50个百分位，使用g=ordfilt2(f,median(1:m*n),ones(m,n));创建中值滤波器 工具箱提供了二维中值滤波函数g=medfilt2(f,[m,n]) 频域变换 为了有效的对图像进行处理和分析，需要将原定义的图像空间的图像以某种形式转换到频域空间，利用频域空间的特有性质方便的进行一定的加工，最后转换回图像空间 傅里叶变换 将图像从空域变换到频域 二维连续傅里叶变换 二维离散傅里叶变换（DFT） 基于离散傅里叶变换的频域滤波 离散余弦变换DCT 图像处理中常用的变换算法，通过DCT变换，可以将图像空间域上的信息变换到频率域上 两种实现 基于快速傅里叶变换FFT的算法，通过工具箱提供的dct2 另一种是DCT变换矩阵，工具箱提供了dctmtx函数来计算变换矩阵 图像保真和质量 图像处理中为了增加压缩率有时会放弃图像细节或者其他不太重要的内容，为了衡量解码图像相对于原始图像的偏离程度，这些测度一般称为保真度准则 主要准则 客观保真度准则 当所损失的信息量可用编码输入图与解码输出图的函数表示时，可以认为是基于客观保真度准则的 均方根误差 均方信噪比（SNR） 均方根误差越小，峰值信噪比越大，处理的图像质量越好 主观保真度准则 用分数代表主观评价{很差，较差，相同，稍好，较好，很好} 数字图像的水印防伪 内嵌水印的特点 透明性 鲁棒性 能够承受施加于图像的变换操作，不会因变换处理而丢失 安全性 空间域水印 将水印信息嵌入到载体图像的空间域特性上 频率域水印 将水印信息嵌入到载体图像的变换域系数等特征上 基于矩阵奇异值分解的数字水印算法 奇异值分解定理 Weyl定理 在原矩阵上加一个小小的扰动，看是否矩阵奇异值的变化是否会超过扰动矩阵的最大奇异值，从而判断稳定性 水印嵌入 水印提取 嵌入的逆过程 基于DCT变换的水印算法 DCT变换是实数域变换，对实系数处理更加方便，不会使相位信息发生变化，另外，DCT变换是有损图像压缩JPEG的核心，基于DCT变换的图像水印将兼容JPEG图像压缩 水印嵌入算法 图像加密 图像隐藏 规划问题连续优化 线性规划 LP 非线性规划 NLP 二次规划 QP 离散优化 整数线性规划 整数非线性规划 纯整数规划 混合整数规划 一般整数规划 0-1整数规划 整数规划的特殊情形，要求线性规划模型中的决策变量只能取值为0和1 模拟和仿真模拟 拟合 非线性最小二乘法 Isqcurvefit Isqnonlin 拟合与统计回归 线性回归 非线性回归 [beta,t,J]=nlinfit(x,y,’model’,beta0) 常用解法：线性最小二乘法 a=polyfit(x,y,m) 插值 一维插值 拉格朗日插值 yy=lagrange(x,y,xx) 分段插值 yy=interp1(x , y ,xx , ‘method’) - 三次样条插值 - yy=spline(x,y,xx) 二维插值 最邻近插值 分片线性插值 双线性插值 仿真 动态仿真 连续系统仿真 时间步长法 离散系统仿真 事件步长法 静态仿真 蒙特卡罗方法 随机数产生 均匀随机数 其他方法 逆变换法 舍选法 近似抽样法 指数分布 泊松分布 标准正态分布 正态分布 二项分布 排队问题 可靠性问题 蒙特卡罗方法 元胞自动机 数值计算常微分方程数值解 微分方程解析解 u=dsolve(‘Du=1+u^2’,’t’) 欧拉方法 向前欧拉公式 向后欧拉公式 梯形公式 龙格—库塔方法 matlab求解 高阶微分方程转一阶常微分方程 刚性常微分方程与非刚性常微分方程 工具箱的使用统计工具箱拟合工具箱神经网络工具箱小波工具箱并行计算工具箱优化工具箱 一元函数极小值 fminbnd 无约束极小 fminunc 为无约束优化提供了大型优化和中型优化算法 为中型优化算法的搜索方向提供了4种算法，由options中的HessUpdate控制，默认为bfgs（拟牛顿法的DFP公式） 另外，还有dfp（拟牛顿法的DFP公式），还有steepdesc（最速下降法） 为中型优化算法的步长一维搜索提供了两种算法，由options中的参数LineSearchType控制，默认是quadcubic （缺省值，混合的二次和三次插值）另外还有cubicpoly（三次多项式插值） fminsearch 线性规划 linprog 二次规划 quadprog 约束极小 fmincon 达到目标问题 fgoalattain 极小极大问题 fminimax 全局优化工具箱","categories":[{"name":"竞赛感悟","slug":"竞赛感悟","permalink":"https://sinclaircoder.top/categories/竞赛感悟/"},{"name":"数学建模","slug":"竞赛感悟/数学建模","permalink":"https://sinclaircoder.top/categories/竞赛感悟/数学建模/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"https://sinclaircoder.top/tags/数学建模/"}],"author":"SinclairWang"},{"title":"2019数学建模赛后感悟：一次灵魂与肉体的交织&&一次参赛终身收益","slug":"2019-09-16-2019数学建模赛后感悟：一次灵魂与肉体的交织&&一次参赛终身收益","date":"2019-09-15T16:00:00.000Z","updated":"2020-01-21T13:19:47.880Z","comments":true,"path":"2019/09/16/2019-09-16-2019-shu-xue-jian-mo-sai-hou-gan-wu-yi-ci-ling-hun-yu-rou-ti-de-jiao-zhi-yi-ci-can-sai-zhong-shen-shou-yi/","link":"","permalink":"https://sinclaircoder.top/2019/09/16/2019-09-16-2019-shu-xue-jian-mo-sai-hou-gan-wu-yi-ci-ling-hun-yu-rou-ti-de-jiao-zhi-yi-ci-can-sai-zhong-shen-shou-yi/","excerpt":"","text":"一年一度的全国大学生数学建模比赛（CUMCM）已接近尾声… SinclairWang 个人博客同步更新，欢迎关注相信每个参赛者都会有自己的感悟一句恰如其分的描述：一次灵魂与肉体的交织。下面是自己的一点感悟与思考。 赛前 最初听说，大概是在一年前，决定参加比赛是在今年5月份，暑假有两个选择，要么参加8月份的建模集训，要么实验室打杂，综合考虑了一下，看到培训大纲上的东西，可能对日后专业方向走向有益，遂放弃了锻炼编码能力的时间，毅然决定参加去参加集训。 集训8月1日份开始，9月5日结束，9月12日比赛开始，9月15日比赛结束。 一个多月的集训，每天上午8点半到12点，可能下午还要加课，一个老师讲一个专题3天，理学院的老师轮流来，每人一个模块，每三天一个专题，智能计算、统计分析、数值计算、图与网络、模拟仿真、分类与聚类、组合优化、图像处理、历年赛题与优秀论文讲评。 老师们每天讲课，一个上午动辄上百页PPT，所以这一个月的日常就是上午上课，下午看老师讲的PPT、理解原理和复现程序。CUMCM涉及层面广而多，虽说深度欠缺，但是对于本科生来说，掌握这些知识，也是不易。 集训的过程，也曾想过放弃，不是畏难，而是有一段时间觉得自己做的可能没有自己想象中的有意义，正如本专业同学那句话 “或许当初没有选择数学建模，这一个月的时间，可能已经足够可以在专业上走的很远了…” 我也认同，可是大家还是选择坚持了下来，一直坚持到了最后。 一场集训下来，我也学到了很多东西，虽不知不觉，却也潜移默化，老师们讲的n个专题，不敢说全部掌握了，但可以说学了个大概，而且学的知识对日后专业方向走向极其有益，虽然理论深度掌握不够，但也相当于在自己的方向相关领域，在自己的学习进程上写了一句HelloWorld，其实集训之前本来想着老师们每讲一个专题，就跟着写一篇Blog，事实上，集训时每天的知识都消化不了，更不要说写博客了，这件事仔细想想，也并非完全不能做到，只是决心不够。虽然专题博客没跟上，但是将老师讲的专题总结成思维导图，形成数学建模集训的整个知识框架，这是不难做到的，思维导图是用xmind做的，用markdown文本导出，我放到了博客上，总结了一下建模期间的博客，不算这篇的话，还有一篇关于的图像处理的,当初看图像处理的时候觉得很有意思,就没忍住写了一篇。 数学建模集训知识大纲 基于奇异值分解的图像压缩 除此之外,我也从队友身上学到了很多,我们队人员组成是2计算机专业(一个SE，一个CS)+数学专业。我从队友身上看到了高效,其实一直很想写一篇关于效率与时间管理的文章,不过时间安排上没提上日程,一个人只有把效率提上去,才能做到自己想做的。之前知乎上有篇高赞文章,是讲*人是怎么废掉的,没想到其中有一条是瞎忙,除了没方向之外,更重要的是低效率,忙了一天不知道在忙什么,忙了点啥,就好比泡图书馆学习,一泡就是一天,到了晚上应该正确评估白天的效率如何,而不应该单纯陷在因为短暂的长时间学习而产生的自我感动上,只有走出了这个误区才能有所进步。经此,我也有了新的认知。另外,我也认识到了学习方式的不足,也有专业大环境的原因,认真专注听课反倒成为了一个大难题,另外,上课认真听课,下课才能用更少的时间去复习,节省出更多的时间去做自己想做的事情。 赛中 9月12日 进驻机房,晚上6点钟放题目,一开始略卡。下载到题目之后,A、B、C任选一题。读题： A题精确计算 有一定的专业知识背景，否则题意不好理解 B题 物理题目？果断放弃 C题 开放性题目 只有大概思路，具体思路没有 估计找数据会劝退一拨人 综合评估，我的答案是选C，队友讨论了一晚上A题，但是我给不出说服他们选C题的东西。没过多久，我找到了数据。但是模型没具体思路。晚上11点半回寝室休息 第二天一早队友们想选C题，其实我内心有点欣喜~然后就开始了建模…建模全靠队友，其中有个神奇的男人，中午小憩都能想到idea，上趟厕所模型都能被改进，回来说“我知道了…应该这样做…”。太神奇了…赛期说好的写论文的队友，最后却在编程，说好了写程序的队友，比赛的时候却开始写起了论文，只有我始终打杂，凭实力打杂。 “我要的折线图你画了没？” “我需要你画个直方图。” “决策树画好了没？” “给你说个思路，你看能实现吗？#$#%#^*@#” “数据处理好了吗？” “打点的图发我了没？” “附录整理好没？” “支撑材料打包了没？” 终于我成了全队无可替代的凭实力打杂的选手！ 到了最后一天，进度有点慢，14日晚上觉得得通宵了，一夜爆肝，那一晚仿佛大家都没回去，都在通宵做模型，计算，一双双熬红的双眼，其实熬夜或许不是最难的，最难的是建不出模，算不出来。那晚的月亮格外美，格外的圆。 那晚队友们几乎都没怎么睡，我凌晨5点撑不住了，睡到了7点多。 起来，洗把脸，下楼吃了东西，队友们赶进度顾不上了… 然后就开始了最刺激压力最大的一天 题目只做了一半，四问只做了两问，晚上8点就要截止了。 到了中午重新改思路，我编程计算，队友们将思路写到论文，完善前面的部分。 高压下编程或许是最考验编程能力的… 到了下午5点半初稿还没出来,还有很多格式要调整，公式要编辑…. 晚上7点40多交了初稿… 没过多久就到8点了，就剩下最后一次交的机会了… 终于能略微喘口气了 但是，还有一次机会，不能放弃 于是，接着完善，修改摘要，修改正文… 终于9点39分交上了这最后一次… 如释重负… 三个人都笑了… 欣喜若狂~ 这一天没吃饭，没水喝，压力大，睡眠不足 但是还是撑了下来，队内也没有发生矛盾，互相理解，合作愉快。 最后一起等到了10点，把参赛作品交了上去 然后离开了机房，嘴上都说着“我再也不想听到’数学建模‘这四个字”… 虽然数学建模门槛低，有人说这不是数学建模，是面向写作和美术的建模，最终看的是论文。但是我还是觉得我参加数学建模是一个无比正确的决定，无论结果如何，它教会了很多东西，我学了很多数学知识，也掌握了很多能力，比如快速学习的能力，随便甩给你个200多页PPT，两天内就能看完，让我更加专注，变得更加有毅力和耐心去学习，比赛教给我团队协作的重要性，一个人可以走的很快，但一群人能走的更远，你终究能走多远，可能不只是跟你自己有关系，还跟你身边的人有关系，别人会影响你，会改变你。我觉得或许自己跟顶尖名校的同龄人的差距或许不只是软硬件实力配置的差距，而是身边有没有一群这样的一群人：大家有着共同的想法，热衷眼前的事情，能全身心的投入，走在一起去实现这个想法的路上。这是我思考了很久得出的结论，也是从数学建模中收获的，尽管这有些难以置信。比赛的时候，我看到一群人通宵建模，尽管很累但都还在撑着，就像何凯文说的那样，“你有多久没有认真过了？”感悟喷涌，能写出来的寥寥数语总归显得苍白无力，只要经历过的全身心投入的人总归会懂得。 赛后好好休息了一下 还了借的参考书籍 今天周一，投入到了新的学习征程中，仿佛又是个崭新的开始。 哦，对了我还写了一篇参赛感悟，正如你所看到的… 后来 2019年9月25日更被抽中答辩，心中自是欣喜万分，同样，无形的压力扑面而来。 2019年9月28日更答辩结束，无论结果如何，石头落地了，尽人事，听天命，一切终于结束了。 准备答辩的过程中，听说了一句话叫做 一次参赛，终身收益 后来才知道这是建模组委会的口号，也越发觉得这句话真的很贴切，参赛经历和比赛的魅力或许已经远远超过了奖项本身了，无论是心智，还是毅力，还是个人能力，都得到了很好的锻炼，参赛期间高压下编程、高压下写作和高压下的团队合作对每个参赛选手都是一次很好的磨练。另外，我觉得答辩期间的压力也是不亚于竞赛期间的，压力反而更大，从准备到答辩结束，需要自己重新审视自己的作品，正确认识作品的缺点，勇于承认或许这才是最重要的。另外，参加一次省级甚至是国家级别的学术答辩，无论结果如何，这都是很好的锻炼。此时，一个累的打字都快打不动了的蒟蒻，还在拖着疲惫的身躯码着自己的切身体会，一般来说，能写出来的文字总归苍白无力。用两句话结个尾吧，给2019CUMCM画上个句号。星光不负赶路人，时光不负有心人。一次参赛，终身收益。","categories":[{"name":"感悟","slug":"感悟","permalink":"https://sinclaircoder.top/categories/感悟/"}],"tags":[{"name":"竞赛感悟","slug":"竞赛感悟","permalink":"https://sinclaircoder.top/tags/竞赛感悟/"},{"name":"数学建模","slug":"数学建模","permalink":"https://sinclaircoder.top/tags/数学建模/"}],"author":"SinclairWang"},{"title":"基于奇异值分解的图像压缩","slug":"2019-09-09-基于奇异值分解的图像压缩","date":"2019-09-08T16:00:00.000Z","updated":"2020-01-21T13:05:57.120Z","comments":true,"path":"2019/09/09/2019-09-09-ji-yu-qi-yi-zhi-fen-jie-de-tu-xiang-ya-suo/","link":"","permalink":"https://sinclaircoder.top/2019/09/09/2019-09-09-ji-yu-qi-yi-zhi-fen-jie-de-tu-xiang-ya-suo/","excerpt":"","text":"理论：矩阵的奇异值分解变换是一种正交变换，它可以将矩阵对角化定理：设A是一个秩为$r$的$m*n$矩阵,则存在正交矩阵$U$和$V$,使得 U^TAV= \\begin{bmatrix} \\Sigma & 0 \\\\ 0 & 0 \\\\ \\end{bmatrix}其中$\\Sigma=diag\\{\\sigma_1,\\sigma_2,\\sigma_3,….,\\sigma_r\\}$，这里$\\sigma_1&gt;=\\sigma_2&gt;=\\sigma_3….&gt;=\\sigma_r$，$\\sigma_1^2….\\sigma_r^2$是矩阵$A^TA$对应的特征值。称A=U \\begin{bmatrix} \\Sigma & 0 \\\\ 0 & 0 \\\\ \\end{bmatrix}V^TA的奇异值分解，$\\sigma_i(i=1,…r)$称为A的奇异值 根据自己的理解，压缩的思路就是先进行奇异值分解，将前k大个特征值保留下来，其余的变为0，然后进行逆变换，起到基本替代原来奇异值矩阵的作用，从而实现图像的压缩，压缩率也会随k的变化而变化，诚然，k越大，压缩率越小。 实现步骤： 读取RGB图像 将RGB图像变为灰度图像 奇异值分解 保留前k大个特征值 逆变换 计算压缩率 打印图像（保存） 修改k的值，重复以上步骤 实现：% 通过奇异值分解 进行图像压缩 clc;clear; I = imread(&#39;figure1.jpg&#39;); % rgb图像为274KB [m,n,h] = size(I); % Igray = rgb2gray(I); % imwrite(Igray,&#39;figure1grayByrgb2gray.png&#39;,&#39;png&#39;) % 灰度图像为993KB，文件变大了好几倍 % 参考别人的博客，手写将rgb图像变成灰度图像 for i=1:m for j=1:n Igray(i,j)=0.299*I(i,j,1)+0.587*I(i,j,2)+0.114*I(i,j,3); end end imwrite(Igray,&#39;figure1grayBymyself.png&#39;,&#39;png&#39;) k = 20; Igray = double(Igray); [U,S,V] = svd(Igray); S = diag(S); % 变成列向量 Smax = max(S); Smin = min(S); S1 = S; S1(k:end)=0; %保留前ｋ个 % S1 = diag(S1); % 考虑不周到 if m&gt;=n % 对于非方图形 S1 = [diag(S1);zeros(m-n,n)]; else S1 = [diag(S1),zeros(m,n-m)]; end g = U*S1*V&#39;; % S1的奇异值分解 g = uint8(g); compressration = n^2/(k*(2*n+1)); subplot(1,2,1),imshow(mat2gray(Igray)),title(&#39;soure&#39;); subplot(1,2,2),imshow(g),title([&#39;k =&#39;,num2str(k),&#39; compress ratio =&#39;,num2str(compressration)]); imwrite(g,&#39;figure1Compress20.png&#39;,&#39;png&#39;) figure,plot(S,&#39;.&#39;,&#39;Color&#39;,&#39;k&#39;); % 画出奇异值对应的点 原RGB图像： 灰度图像 特征值分布 K=20时的压缩率 可以调节k的值得到不同的压缩率 参考博客：RGB图像转为灰度图像原理RGB转灰度的几种算法图像压缩（SVD方法）","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://sinclaircoder.top/categories/图像处理/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://sinclaircoder.top/tags/图像处理/"}],"author":"SinclairWang"},{"title":"软件体系结构笔记","slug":"2019-09-02-软件体系结构笔记","date":"2019-09-01T16:00:00.000Z","updated":"2020-01-21T13:22:30.302Z","comments":true,"path":"2019/09/02/2019-09-02-ruan-jian-ti-xi-jie-gou-bi-ji/","link":"","permalink":"https://sinclaircoder.top/2019/09/02/2019-09-02-ruan-jian-ti-xi-jie-gou-bi-ji/","excerpt":"","text":"传说中的软件体系结构与设计模式课程中的软件体系结构部分就结束了，好短，6个学时，匆匆掠过，走马观花，根据老师讲的内容写了份笔记，日后慢慢补充… 概念 具有一定形式的结构化元素，即构件的集合 处理构件：处理函数 数据构件：存储数据 （JavaBean） 连接构件 软件设计过程中的一个层次 为软件系统提供了一个结构行为和属性的高级抽象 代码重用构件 语义完整、语法正确和有重用价值的单位软件，是重用过程中可以明确辨识的系统，结构上是语义的描述、通讯接口和实现代码的复合体 粒度 大概就是所容纳的逻辑，逻辑越多为粗粒度，逻辑越少为细粒度，逻辑多少是相对而言的。比方说，对用户暴露了太多细节相对来说就是细粒度的，例如提供Getter和Setter方法，相反，如果提供getData()和setData()方法，就可以认为是粗粒度 ”4+1“模型 逻辑视图 描述系统的功能需求，即系统提供给最终用户的服务 开发视图 描述软件模块的组织与管理，服务于软件编程人员 进程视图 侧重系统的运行特性，关注非功能的需求，服务于系统集成人员 物理视图 描述硬件配置，服务于系统工程人员 场景 用于刻画构件之间的相互关系 元模型 元模型是关于模型的模型 四层元模型 四层元模型是OMG组织指定的UML的语言体系结构 体系结构 信息层 information layer 由我们希望的数据组成，通常是一些用户数据 模型层 model layer 由元数据组成，元数据是描述信息层的数据 元模型层 metamodel layer 是为了描述模型层而定义的一种“抽象语言”，是对模型层的进一步抽象。 元元模型层 meta-metamodel layer 是为了描述元模型而定义的一种“抽象语言”。元元模型的定义要比元模型更加抽象、简洁。一个元元模型可以定义多个元模型，而每个元模型也可以与多个元元模型相关联。 经典体系结构风格 数据流风格：批处理序列；管道过滤器 管道／过滤器 在该体系结构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流，这里的构件被称为过滤器，而连接件称为管道 优点 具有良好的隐蔽性、高内聚、低耦合 缺点 通常导致进程成为批处理的结构 不适合处理交互应用 举例：UNIX下的Shell编程 调用／返回风格：主程序／子程序 面向对象风格：层次结构 分层系统 独立构件风格：进程通讯 事件系统 虚拟机风格：解释器，基于规则的系统 仓库系统：数据库系统 超文本系统 黑板系统 目前流行的体系结构 客户/服务器 Client/Server 任务分配 服务器 数据库安全性的要求 数据库访问并发性的控制 数据库的备份与恢复 客户端 用户与数据库交互的界面 向数据库提交用户请求，接收来自服务器的信息 业务逻辑处理 评价 优点 客户应用程序和服务器构件分别运行在不同的计算机上 缺点 软件维护和升级困难 三层C/S结构 结构 数据库服务器 应用服务器 客户端 优点 应用的各层可以并行开发 功能层有效的隔开了数据层和表示层，更安全 浏览器/服务器模式 Browser/Server 即上述三层C/S结构的一种实现，浏览器/Web服务器/服务器 优点：系统安装、修改、维护全在服务端解决 缺点：缺乏对动态页面的支持，系统扩展能力差，在数据查询等响应速度要远远低于C/S 公共对象请求代理结构 Common ObjectRequest Broker Architecture（CORBA） 由OMG组织制订的一种标准的面向对象应用程序体系规范。或者说 CORBA体系结构是对象管理组织（OMG）为解决分布式处理环境(DCE)中，硬件和软件系统的互连而提出的一种解决方案 异构结构 反射体系结构 功能 动态获取到类或对象的属性或函数，修改对象的行为 把应用程序分成两层：基础层（定义应用程序的逻辑）和元层 消息的截取 Open C++ 反射 Reflect 处理从元级转化到基本级 具体化 Reify 从基本级转化到元级 元对象协议 Meta object Protocol 软件框架 定义：在给定的问题领域范围内建立起可重用解决设计方案问题而相互访问协作的一组类的集合 类库与框架区别 行为相对于协议 类库是行为的结合，而框架除了是行为的集合，而且还是与支配行为的一组规则或协议 ‘’不是访问我们，而是我们访问你‘’ 这里出现了一个控制的翻转，框架调用开发者写的程序代码，而开发者的程序是要去调用类库来实现某种功能 实现相对于设计 类库重用实现，框架重用设计 几个重要概念 Frozen Spots 冷冻部分 框架本身 Hot Spots 热点 可变部分 Hooks 直译过来就是 钩子，即通常理解的回调函数","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://sinclaircoder.top/categories/软件工程/"}],"tags":[{"name":"软件体系结构","slug":"软件体系结构","permalink":"https://sinclaircoder.top/tags/软件体系结构/"}],"author":"SinclairWang"},{"title":"机器学习之线性回归","slug":"2019-08-17-机器学习之线性回归","date":"2019-08-16T16:00:00.000Z","updated":"2020-01-21T13:39:29.659Z","comments":true,"path":"2019/08/17/2019-08-17-ji-qi-xue-xi-zhi-xian-xing-hui-gui/","link":"","permalink":"https://sinclaircoder.top/2019/08/17/2019-08-17-ji-qi-xue-xi-zhi-xian-xing-hui-gui/","excerpt":"","text":"简单的线性回归以某产品的温度和产率关系为例，其中产率(y)是温度(x)的函数。请构建模型预测产品产率。 温度 产率 100 45 110 51 120 54 130 61 140 66 150 70 160 74 170 78 180 85 190 89 首先，我们可以先把数据可视化，画个散点图出来。根据散点图可知，数据基本上都在一条直线上，我们可以用一条直线去拟合。 正规方程求解\\theta=(X^TX)^{-1}X^TYfunction [ theta ] = linearReg( ) % 线性回归正规方程求解 % 用130、190作为测试集 train = 8; X = [1 100;1 110;1 120;1 140;1 150;1 160;1 170;1 180;] Y = [45; 51 ;54 ;66; 70; 74 ;78; 85]; A = inv(X&#39;*X); theta = A*X&#39;*Y; end 解得： \\theta=\\begin{pmatrix} -3.1507 \\\\ 0.4851 \\end{pmatrix}散点图拟合情况如下： 看起来拟合效果还不错 梯度下降求解假设函数：h_\\theta(x)=\\theta_0+\\theta_1x代价函数： J(\\theta_0 ,\\theta_1)= \\frac{1} {2m}\\sum_{i=1}^m(h_\\theta(x^{(i)})-y^{(i)})^2梯度下降：(同步更新) temp_0 = \\theta_0- \\alpha \\frac{\\partial} {\\partial \\theta_0}J(\\theta_0 ,\\theta_1)temp_1 = \\theta_1- \\alpha \\frac{\\partial} {\\partial \\theta_1}J(\\theta_0 ,\\theta_1)\\theta_0 = temp_0\\theta_1 = temp_1假设函数 function [ res ] = h_func(inputx,theta ) % 预测函数 res = theta(1)+theta(2)*inputx; end 代价函数 function [ jVal,gradient ] = costFunction2( theta ) % jVal 为 代价值 gradient为梯度 % cost function % 用130、190作为测试集 x = [100 110 120 140 150 160 170 180] y = [45 51 54 66 70 74 78 85]; m = size(x,1); % size(x) = [1 8] size(x,1) 表示获取x的行 hypothesis = h_func(x,theta); delta = hypothesis - y; % 预测误差 向量 jVal= sum(delta.^2); % 损失函数 gradient(1) = sum(delta)/m; gradient(2) = sum(delta.*x)/m; end 梯度下降 function [ optTheta,functionVal,exitFlag ] = Gradient_descent() % 梯度下降 % fminunc 非线性优化 % 找到min f(x) 的 x f(x)是一个返回值为标量的函数，x是一个向量或矩阵 % options 配置选项，&#39;GradObj&#39; &#39;on&#39; 表示使用自定义的梯度下降函数，&#39;MaxIter&#39;,1000 表示最大迭代次数 options = optimset(&#39;GradObj&#39;,&#39;on&#39;,&#39;MaxIter&#39;,1000); % 需要返回的参数， 需要初始化 initialTheta = zeros(2,1); [optTheta,functionVal,exitFlag] = fminunc(@costFunction2,initialTheta,options); end 运行结果： optTheta = \\begin{pmatrix} -3.1507 \\\\0.4851 \\end{pmatrix}functionVal = 6.1996可见利用正规方程和梯度下降求解出来的参数一样未完，待续…","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://sinclaircoder.top/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://sinclaircoder.top/tags/机器学习/"}],"author":"SinclairWang"},{"title":"0/1背包入门","slug":"2019-08-12-背包入门","date":"2019-08-11T16:00:00.000Z","updated":"2020-01-22T02:40:40.570Z","comments":true,"path":"2019/08/12/2019-08-12-bei-bao-ru-men/","link":"","permalink":"https://sinclaircoder.top/2019/08/12/2019-08-12-bei-bao-ru-men/","excerpt":"","text":"问题描述有n个重量分别为w1 、 w2 、w3、w4···wn的物品，编号1~n，它们的价值为v1 、 v2 、v3、v4···vn。现有一容量为W的背包，求尽可能的把背包装满并使价值最大 下面不妨以ｎ＝４ Ｗ＝６为例 物品编号 重量 价值 1 5 4 2 3 4 3 2 3 4 1 1 蛮力法—求幂集搜索 思路大概是用蛮力法找出n的所有幂集,然后遍历一遍,找到最优解 复杂度为O(2n) #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stdio.h&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; /** 求解简单0/1背包问题 2019-8-12 */ vector&lt;vector&lt;int&gt; &gt; ps; void PSet(int n) // 求1-n的幂集 { vector&lt;vector&lt;int&gt; &gt; ps1; // 子幂集 vector&lt;vector&lt;int&gt; &gt;::iterator it; vector&lt;int&gt; s; ps.push_back(s); // 添加空集合元素 for(int i=1;i&lt;=n;i++) { ps1 = ps; for(it=ps1.begin();it!=ps1.end();it++) (*it).push_back(i); for(it=ps1.begin();it!=ps1.end();it++) ps.push_back(*it); } } void Knap(int w[],int v[], int W) { int count = 0; int sumw,sumv; int maxi,maxsumw=0,maxsumv=0; vector&lt;vector&lt;int&gt; &gt;::iterator it; vector&lt;int&gt;::iterator sit; printf(&quot; 序号 选中物品 总重量 总价值 能否装入\\n&quot;); for(it=ps.begin();it!=ps.end();it++) { printf(&quot; %d\\t&quot;,count++); sumw=sumv=0; printf(&quot; {&quot;); for(sit=(*it).begin();sit!=(*it).end();sit++) { printf(&quot;%d &quot;,*sit); sumw += w[*sit-1]; sumv += v[*sit-1]; } printf(&quot;}\\t\\t%d\\t%d &quot;,sumw,sumv); if(sumw&lt;=W) { printf(&quot;能\\n&quot;); if(sumv&gt;maxsumv) { maxsumw = sumw; maxsumv = sumv; maxi = count-1; } } else cout &lt;&lt; &quot;否\\n&quot;; // count++; } printf(&quot;最佳方案为：&quot;); printf(&quot;选中物品&quot;); printf(&quot;{ &quot;); for(sit=ps[maxi].begin();sit!=ps[maxi].end();sit++) printf(&quot;%d &quot;,*sit); printf(&quot;},&quot;); printf(&quot;总重量：%d,总价值：%d\\n&quot;,maxsumw,maxsumv); } int main() { int n = 4, W = 6; int w[] = {5,3,2,1}; int v[] = {4,4,3,1}; PSet(n); printf(&quot;0/1背包解决方案\\n&quot;,n); Knap(w,v,W); return 0; } 队列式分支界限法#include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; #define MAXV 20 int maxv = -9999; int bestx[20]; // 存放最优解，全局变量 int total = 1; struct NodeType{ int num; // 结点编号 int i; // 当前结点在搜索空间中的层次 int w; // 当前结点的总权重 int v; // 当前结点的总价值 int x[MAXV]; // 当前结点包含的解向量 double ub; // 上界 }; int n =5,W = 6; int w[] = {0,5,3,2,1}; int v[] = {0,4,4,3,1}; void bound(NodeType &amp;e){ // 计算分支结点e的上界 int i=e.i+1; int sumw = e.w; double sumv = e.v; while((sumw+w[i]&lt;=W)&amp;&amp; i&lt;=n){ sumw += w[i]; sumv += v[i]; i++; } if(i&lt;=n) e.ub = sumv+(W-sumw)*v[i]/w[i]; else e.ub = sumv; } void EnQueue(NodeType e,queue&lt;NodeType&gt; &amp;qu) { if(e.i==n) { if(e.v&gt;maxv) { maxv = e.v; for(int j=1;j&lt;=n;j++) bestx[j] = e.x[j]; } } else qu.push(e); } void bfs() { int j; NodeType e,e1,e2; queue&lt;NodeType&gt; qu; e.i = 0; e.w = 0; e.v = 0; e.num = total++; for(j=1;j&lt;=n;j++) e.x[j] = 0; bound(e); qu.push(e); while(!qu.empty()) { e = qu.front(); qu.pop(); if(e.w+w[e.i+1]&lt;=W) // 剪枝：检查左孩子结点 { e1.num = total++; e1.i = e.i+1; e1.w = e.w+w[e1.i]; e1.v = e.v+v[e1.i]; for(j=1;j&lt;=n;j++) e1.x[j] = e.x[j]; e1.x[e1.i] = 1; bound(e1); EnQueue(e1,qu); } e2.num = total++; e2.i = e.i+1; e2.w = e.w; e2.v = e.v; for(j=2;j&lt;=n;j++) e2.x[j] = e.x[j]; e2.x[e2.i]= 0; bound(e2); if(e2.ub&gt;maxv) EnQueue(e2,qu); } } int main() { bfs(); printf(&quot;分支界限法求解0/1背包问题：\\n X=[&quot;); for(int i=1;i&lt;=n;i++) printf(&quot;%2d&quot;,bestx[i]); printf(&quot;],装入总价值为%d\\n&quot;,maxv); return 0; } 未完待续~~ 参考: 李春葆 .算法设计与分析(第二版)","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://sinclaircoder.top/categories/动态规划/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sinclaircoder.top/tags/动态规划/"},{"name":"0/1背包","slug":"0-1背包","permalink":"https://sinclaircoder.top/tags/0-1背包/"}],"author":"SinclairWang"},{"title":"一线爬虫爬虫工程师纪实","slug":"2019-07-17-一线爬虫工程师纪实","date":"2019-07-16T16:00:00.000Z","updated":"2020-01-21T12:29:47.630Z","comments":true,"path":"2019/07/17/2019-07-17-yi-xian-pa-chong-gong-cheng-shi-ji-shi/","link":"","permalink":"https://sinclaircoder.top/2019/07/17/2019-07-17-yi-xian-pa-chong-gong-cheng-shi-ji-shi/","excerpt":"最近遇到了反爬虫","text":"最近遇到了反爬虫 在CSDN上逛到了一篇很不错的博文Java 那些你不知道的爬虫反爬虫套路 一篇一线爬虫工程师的纪实~ ==注：侵删==","categories":[{"name":"工程项目","slug":"工程项目","permalink":"https://sinclaircoder.top/categories/工程项目/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://sinclaircoder.top/tags/爬虫/"}]},{"title":"Tomcat 8080端口被占用","slug":"2019-07-14-Tomcat 8080端口被占用","date":"2019-07-13T16:00:00.000Z","updated":"2020-01-21T12:46:42.551Z","comments":true,"path":"2019/07/14/2019-07-14-tomcat-8080-duan-kou-bei-zhan-yong/","link":"","permalink":"https://sinclaircoder.top/2019/07/14/2019-07-14-tomcat-8080-duan-kou-bei-zhan-yong/","excerpt":"最近在学习Spring Boot ，新建项目运行的时候出现了Tomcat 8080端口被占用的问题","text":"最近在学习Spring Boot ，新建项目运行的时候出现了Tomcat 8080端口被占用的问题描述如下： 解决方法1.管理员身份打开cmd窗口2.使用命令 netstat -ano 查看当前端口信息 3.找到对应端口PID ，输入指令找到对应进程杀掉 4.重新运行程序","categories":[],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://sinclaircoder.top/tags/Tomcat/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://sinclaircoder.top/tags/SpringBoot/"}]},{"title":"JavaScript的prototype属性","slug":"2019-06-24-JavaScript的prototype属性","date":"2019-06-23T16:00:00.000Z","updated":"2020-01-21T12:46:38.382Z","comments":true,"path":"2019/06/24/2019-06-24-javascript-de-prototype-shu-xing/","link":"","permalink":"https://sinclaircoder.top/2019/06/24/2019-06-24-javascript-de-prototype-shu-xing/","excerpt":"今天写js代码的时候，看别的用prototype看的我云里雾里的，了解了一下： prototype 是函数的属性，它的本质是函数的原型对象 可以以此执行一下如下代码，体会一下。","text":"今天写js代码的时候，看别的用prototype看的我云里雾里的，了解了一下： prototype 是函数的属性，它的本质是函数的原型对象 可以以此执行一下如下代码，体会一下。 &lt;script&gt; var ob = { };//超级简单的空对象 alert(JSON.stringify(ob.prototype)); function func(){ } alert(func.prototype); &lt;/script&gt; &lt;script&gt; function func(){ } alert(JSON.stringify(func.prototype)); &lt;/script&gt; &lt;script&gt; function func(){ } func.prototype.name =&#39;prototype是函数的的属性，本质是函数的原型对象&#39;; alert(JSON.stringify(func.prototype)) &lt;/script&gt; &lt;script&gt; function func(){ } //给函数的属性prototype赋予一个方法get func.prototype.get=function(value){ return value; } var ob1 = new func; //用func实例化出来的对象来调用get属性函数 alert(ob1.get(&#39;hello,prototype原型对象&#39;)); var ob2 = new func; //用func实例化出来的对象来调用get属性方法 alert(ob2.get(&#39;我依然是func实例化出来的对象&#39;)); &lt;/script&gt; 详情请见==&gt;简单理解js的prototype属性","categories":[{"name":"javascript","slug":"javascript","permalink":"https://sinclaircoder.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sinclaircoder.top/tags/javascript/"}]},{"title":"数据结构-图-深度优先搜索的应用","slug":"2019-06-17-数据结构-图-深度优先搜索的应用","date":"2019-06-16T16:00:00.000Z","updated":"2020-01-22T03:40:36.361Z","comments":true,"path":"2019/06/17/2019-06-17-shu-ju-jie-gou-tu-shen-du-you-xian-sou-suo-de-ying-yong/","link":"","permalink":"https://sinclaircoder.top/2019/06/17/2019-06-17-shu-ju-jie-gou-tu-shen-du-you-xian-sou-suo-de-ying-yong/","excerpt":"@[toc]之前还写过一篇关于DFS的题解入门学习文章，详情见DFS入门学习 深度优先搜索的应用头文件声明即图的基本运算，详情见数据结构-图-基本运算 #include&quot;Graph.cpp&quot; 顶点u到顶点v是否有简单路径","text":"@[toc]之前还写过一篇关于DFS的题解入门学习文章，详情见DFS入门学习 深度优先搜索的应用头文件声明即图的基本运算，详情见数据结构-图-基本运算 #include&quot;Graph.cpp&quot; 顶点u到顶点v是否有简单路径 /* 顶点u到顶点v是否有简单路径，has表示是否存在 典型的DFS */ void ExistPath(AdjGraph *G,int u, int v, bool &amp;has) { int w; ArcNode *p; visited[u] = 1; if(u == v) // 出口 { has = true; return ; } p = G-&gt;adjlist[u].firstarc; while(p!=NULL) { w = p-&gt;adjvex; if(visited[w] == 0) ExistPath(G,w,v,has); p = p-&gt;nextarc; } } 输出图G中从定点u到v的一条简单路径/* 输出图G中从定点u到v的一条简单路径 典型的DFS */ void FindPath(AdjGraph *G, int u, int v,int path[], int d) { // d 为路径长度 初始为-1 int w; ArcNode *p; visited[u] = 1; d++; path[d] = u; if(u==v) // 出口 { for(int i=0;i&lt;=d;i++) printf(&quot;%2d&quot;,path[i]); cout &lt;&lt; endl; return ; } p = G-&gt;adjlist[u].firstarc; while(p!=NULL) { w = p-&gt;adjvex; if(visited[w]==0) FindPath(G,w,v,path,d); p = p-&gt;nextarc; } } 输出图G中从定点u到v的所有简单路径/* 输出图G中从定点u到v的所有简单路径 典型的DFS 需要额外写一个恢复 */ void FindAllPath(AdjGraph *G, int u, int v,int path[], int d) { int w; ArcNode *p; visited[u] = 1; d++; path[d] = u; if(u == v &amp;&amp; d&gt;=0) // 出口 { for(int i=0;i&lt;=d;i++) printf(&quot;%2d&quot;,path[i]); cout &lt;&lt; endl; } p = G-&gt;adjlist[u].firstarc; while(p!=NULL) { w = p-&gt;adjvex; if(visited[w]==0) FindAllPath(G,w,v,path,d); p = p-&gt;nextarc; } visited[u] = 0; // 恢复，该顶点可重复使用 } 求图G中所有从顶点u到v的长度为l的简单路径/* 求图G中所有从顶点u到v的长度为l的简单路径 典型DFS */ void PathlenAll(AdjGraph *G, int u, int v, int l, int path[], int d) { int w; ArcNode *p; visited[u] = 1; d++; path[d] = u; if(u == v&amp;&amp; d==l) { printf(&quot; &quot;); for(int i=0;i&lt;=d;i++) printf(&quot;%2d&quot;,path[i]); cout &lt;&lt; endl; } p = G-&gt;adjlist[u].firstarc; while(p!=NULL) { w = p-&gt;adjvex; if(visited[w]==0) PathlenAll(G,w,v,l,path,d); p = p-&gt;nextarc; } visited[u] = 0; // 恢复 } 主函数测试int main() { int path[MAXV]; int u=1,v=4,l=3; int n=5,e =8; int A[MAXV][MAXV]={{0,1,0,1,1},{1,0,1,1,0},{0,1,0,1,1},{1,1,1,0,1},{1,0,1,1,0}}; AdjGraph *G; CreateAdj(G,A,n,e); for(int i=0;i&lt;n;i++) visited[i] = 0; cout &lt;&lt; &quot;图G的邻接表：&quot;; DispAdj(G); cout &lt;&lt; &quot;顶点1到4之间是否有简单路径：&quot;; bool has; ExistPath(G,1,4,has); cout &lt;&lt; has &lt;&lt; endl; memset(visited,0,sizeof(visited)); cout &lt;&lt; &quot;输出一条顶点1到4之间的简单路径：&quot;; FindPath(G,1,4,path,-1); cout &lt;&lt; endl; memset(visited,0,sizeof(visited)); cout &lt;&lt; &quot;输出所有顶点1到4之间的简单路径：&quot; &lt;&lt; endl; memset(path,-1,sizeof(path)); FindAllPath(G,1,4,path,-1); cout &lt;&lt; &quot;输出所有顶点1到4之间长度为4的简单路径：&quot; &lt;&lt; endl; memset(visited,0,sizeof(visited)); memset(path,-1,sizeof(path)); PathlenAll(G,1,4,4,path,-1); cout &lt;&lt; &quot;输出所有顶点1到4之间长度为3的简单路径：&quot; &lt;&lt; endl; memset(visited,0,sizeof(visited)); memset(path,-1,sizeof(path)); PathlenAll(G,1,4,3,path,-1); return 0; } 结果 写于2019/6/17 00:37 坚持很酷~","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"},{"name":"图算法","slug":"图算法","permalink":"https://sinclaircoder.top/tags/图算法/"}]},{"title":"数据结构-图-基本运算","slug":"2019-06-16-数据结构-图-基本运算","date":"2019-06-15T16:00:00.000Z","updated":"2020-01-22T03:40:24.486Z","comments":true,"path":"2019/06/16/2019-06-16-shu-ju-jie-gou-tu-ji-ben-yun-suan/","link":"","permalink":"https://sinclaircoder.top/2019/06/16/2019-06-16-shu-ju-jie-gou-tu-ji-ben-yun-suan/","excerpt":"定义 图G由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有限集合，记为V(G), E是连接V中两个不同顶点（顶点对）的边的有限集合，记为E(G)","text":"定义 图G由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有限集合，记为V(G), E是连接V中两个不同顶点（顶点对）的边的有限集合，记为E(G) 存储结构 邻接矩阵 邻接表 十字链表 邻接多重表 结构体定义#include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;deque&gt; using namespace std; #define MAXV 100 #define INF 32767 typedef struct { int num; // 序号 int data; }VertexType; // 顶点类型 typedef struct { int edges[MAXV][MAXV]; // 邻接矩阵数组 int n,e; // 顶点数，边数 VertexType vertex[MAXV]; // 顶点 }MatGraph; // 图的邻接表表示 typedef struct ANode { //边结点类型 int adjvex; //该边邻接点编号 struct ANode *nextarc; int weight; }ArcNode; typedef struct Vnode{ // 头结点类型 VertexType data; // 顶点信息 int count; // 增加数据域：存放顶点入度 ArcNode *firstarc; }VNode; typedef struct { VNode adjlist[MAXV]; int n; int e; }AdjGraph; // 用一个头节点数组构造的图 邻接表创建图// 用邻接表创建图 void CreateAdj(AdjGraph *&amp;G,int A[MAXV][MAXV], int n, int e) { int i,j; ArcNode* p; G = (AdjGraph*)malloc(sizeof(AdjGraph)); for(i=0;i&lt;n;i++) G-&gt;adjlist[i].firstarc = NULL; for(i=0;i&lt;n;i++) for(j=n-1;j&gt;=0;j--) { if(A[i][j] !=0&amp;&amp;A[i][j]!=INF) { p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;weight = A[i][j]; p-&gt;nextarc = G-&gt;adjlist[i].firstarc; G-&gt;adjlist[i].firstarc = p; } } G-&gt;n = n , G-&gt;e = e; } 输出图G// 输出图G void DispAdj(AdjGraph *G) { int i; ArcNode *p; for(i=0;i&lt;G-&gt;n;i++) { p = G-&gt;adjlist[i].firstarc; printf(&quot;%3d:&quot;,i); while(p!=NULL) { printf(&quot;%3d[%d]-&gt;&quot;,p-&gt;adjvex,p-&gt;weight); p = p-&gt;nextarc; } cout &lt;&lt; &quot;^\\n&quot;; } } 销毁图// 销毁图 void DestroyAdj(AdjGraph *&amp;G) { int i; ArcNode *pre, *p; for(i=0;i&lt;G-&gt;n;i++) { pre = G-&gt;adjlist[i].firstarc; if(pre!=NULL) { p = pre-&gt;nextarc; while(p!=NULL) { free(pre); pre = p; p = p-&gt;nextarc; } free(pre); } } free(G); } 邻接矩阵与邻接表的相互转化// 邻接矩阵转邻接表 复杂度：O(n^2) void MatToList(MatGraph g, AdjGraph *&amp;G) { int i,j; ArcNode *p; G = (AdjGraph*)malloc(sizeof(AdjGraph)); for(i=0;i&lt;G-&gt;n;i++) G-&gt;adjlist[i].firstarc = NULL; for(i=0;i&lt;g.n;i++) for(j=g.n-1;j&gt;=0;j--) if(g.edges[i][j]!=0&amp;&amp;g.edges[i][j]!=INF) { p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;weight = g.edges[i][j]; p-&gt;nextarc = G-&gt;adjlist[i].firstarc; G-&gt;adjlist[i].firstarc = p; } G-&gt;n = g.n; G-&gt;e = g.e; } // 邻接表转邻接矩阵 复杂度 O(n+e) void ListToMat(AdjGraph *G, MatGraph &amp;g) { int i; ArcNode *p; for(i=0;i&lt;G-&gt;n;i++) { p = G-&gt;adjlist[i].firstarc; while(p!=NULL) { g.edges[i][p-&gt;adjvex] = p-&gt;weight; p = p-&gt;nextarc; } } g.n = G-&gt;n; g.e = G-&gt;e; } 图的遍历深度优先搜索 int visited[MAXV]={0}; // 深度优先搜索 DFS O(n+e) void DFS(AdjGraph *G,int v) // 遍历连通图 { ArcNode *p; visited[v] = 1; printf(&quot;%2d&quot;,v); p = G-&gt;adjlist[v].firstarc; while(p!=NULL) { if(visited[p-&gt;adjvex] == 0) DFS(G,p-&gt;adjvex); p = p-&gt;nextarc; } } void DFS1(AdjGraph *G) // 遍历非连通图 { for(int i=0;i&lt;G-&gt;n;i++) if(visited[i]==0) DFS(G,i); } 广度优先搜索 // 广度优先搜索 O(n^2) void BFS(AdjGraph *&amp;G, int v) // 遍历连通图 { int w; ArcNode *p; int visited[MAXV] ={0}; visited[v] = 1; printf(&quot;%2d&quot;,v); deque&lt;int&gt; de; de.push_back(v); while(!de.empty()) { w = *de.begin(); de.pop_front(); p = G-&gt;adjlist[w].firstarc; while(p!=NULL){ if(visited[p-&gt;adjvex] == 0) { printf(&quot;%2d&quot;,p-&gt;adjvex); visited[p-&gt;adjvex] = 1; de.push_back(p-&gt;adjvex); } p = p-&gt;nextarc; } } cout &lt;&lt; endl; } void BFS1(AdjGraph *G) // 遍历非连通图 { for(int i=0;i&lt;G-&gt;n;i++) if(visited[i]==0) BFS(G,i); } 判断图是否连通bool Connect(AdjGraph *G) { int i; bool flag = true; for(int i=0;i&lt;G-&gt;n;i++) visited[i] = 0; DFS(G,0); for(int i=0;i&lt;G-&gt;n;i++) if(visited[i]==0) { flag = false; break; } return flag; } 主函数调用测试int main() { int A[MAXV][MAXV] = { {0,28,INF,INF,INF,10,INF}, {26,0,16,INF,INF,INF,14}, {INF,16,0,12,INF,INF,INF}, {INF,INF,12,0,22,INF,18}, {INF,INF,INF,22,0,25,24}, {10,INF,INF,INF,25,0,INF}, {INF,14,INF,18,24,INF,0} }; AdjGraph *G; int n = 7,e = 18; CreateAdj(G,A,n,e); DispAdj(G); cout &lt;&lt; &quot;广度优先搜索产生的序列为： &quot;; BFS(G,0); cout &lt;&lt; &quot;深度优先搜索产生的序列为： &quot;; DFS(G,0); cout &lt;&lt; endl; //cout &lt;&lt; &quot;图G是否连通： &quot;; //printf(&quot; %d&quot;,Connect(G)); DestroyAdj(G); return 0; } 结果 P.S：马上考试了，我还在写博客，但我觉得这才是正确的复习方式，hahahha太真实了…….","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"},{"name":"图算法","slug":"图算法","permalink":"https://sinclaircoder.top/tags/图算法/"}]},{"title":"数据结构-查找-二叉搜索树","slug":"2019-06-12-数据结构-查找-二叉搜索树","date":"2019-06-11T16:00:00.000Z","updated":"2020-01-22T03:40:41.337Z","comments":true,"path":"2019/06/12/2019-06-12-shu-ju-jie-gou-cha-zhao-er-cha-sou-suo-shu/","link":"","permalink":"https://sinclaircoder.top/2019/06/12/2019-06-12-shu-ju-jie-gou-cha-zhao-er-cha-sou-suo-shu/","excerpt":"二叉排序树（Binary Search Tree ，BST）又称二叉排序树，其定义为二叉排序树，或空树，或者是满足以下性质的二叉树： 1.若根节点的左子树非空，则左子树上所有节点关键字小于根节点关键字；2.若根节点的右子树非空，则右子树上所有节点关键字大于根节点关键字；3.根节点的左右子树本身又是一棵二叉排序树。 即在二叉树的基础上添加了结点值的约束。 以下是二叉搜索树的实现。","text":"二叉排序树（Binary Search Tree ，BST）又称二叉排序树，其定义为二叉排序树，或空树，或者是满足以下性质的二叉树： 1.若根节点的左子树非空，则左子树上所有节点关键字小于根节点关键字；2.若根节点的右子树非空，则右子树上所有节点关键字大于根节点关键字；3.根节点的左右子树本身又是一棵二叉排序树。 即在二叉树的基础上添加了结点值的约束。 以下是二叉搜索树的实现。 /* @author:Sinclair @time:2019-06-12 Binary Search Tree 数据结构之二叉搜索（排序）树 */ typedef int KeyType; typedef struct tree{ KeyType key; // other struct tree *lchild,*rchild; }BST; // 插入关键字为k的结点 bool Insert(BST *&amp;bt, KeyType k) { if(bt==NULL) { bt = (BST *)malloc(sizeof(BST)); bt-&gt;key = k; bt-&gt;lchild = bt-&gt;rchild = NULL; return true; } else if(k == bt-&gt;key){ return false; } else if(k &lt; bt-&gt;key){ return Insert(bt-&gt;lchild,k); } else{ return Insert(bt-&gt;rchild,k); } } // 创建二叉排序树 BST* Create(KeyType A[],int n) { BST *bt = NULL; int i=0; while(i&lt;n) { Insert(bt,A[i]); i++; } return bt; } // 查找关键字为k的结点 返回地址 BST* Search(BST *bt, KeyType k) { if(bt == NULL || bt-&gt;key == k) { return bt; } if(k&lt;bt-&gt;key){ return Search(bt-&gt;lchild, k); } else{ return Search(bt-&gt;rchild,k); } } // 查找关键字为k的结点并且还要查找其双亲结点 BST* SearchParents(BST *bt,KeyType k,BST *temp, BST *&amp;father) { if(bt == NULL) { father = NULL; return bt; } else if(bt-&gt;key == k) { father = temp; return bt; } if(k&lt;bt-&gt;key){ return SearchParents(bt-&gt;lchild,k,bt,father); } else{ return SearchParents(bt-&gt;rchild, k, bt, father); } } // 找出树中k最大的和最小的结点 KeyType FindMaxNode( BST *p) { while(p-&gt;rchild !=NULL){ p = p-&gt;rchild; } return p-&gt;key; } KeyType FindMinNode( BST *p) { while(p-&gt;lchild !=NULL){ p = p-&gt;rchild; } return p-&gt;key; } void FindMaxMinNode(BST *p) { if(p!=NULL) { if(p-&gt;lchild !=NULL) printf(&quot;左子树的最大结点为:%d\\n&quot;,FindMaxNode(p-&gt;lchild)); if(p-&gt;rchild !=NULL) printf(&quot;右子树的最大结点为:%d\\n&quot;,FindMinNode(p-&gt;rchild)); } } void Delete1(BST *p,BST *&amp; r) { BST *q; if(r-&gt;rchild!=NULL){ Delete1(p,p-&gt;rchild); } else{ p-&gt;key = r-&gt;key; q = r; r = r-&gt;lchild; free(q); } } // 删除树中关键字为k的结点 void Delete(BST *&amp;bt, KeyType k) { BST *p = Search(bt,k); BST *q; if(p-&gt;rchild==NULL) // 右子树为空，左子树结点代替 { q = p; p = p-&gt;lchild; free(q); } else if(p-&gt;lchild ==NULL){ // 左子树为空，右子树结点代替 q = p; p = p-&gt;rchild; free(q); } else Delete1(p, p-&gt;lchild); // 结点p既有左子树又有右子树 } void DisplayBST(BST* bt) { if(bt != NULL) { cout &lt;&lt; bt-&gt;key; if(bt-&gt;lchild != NULL ||bt-&gt;rchild !=NULL) { cout &lt;&lt; &quot;(&quot;; DisplayBST(bt-&gt;lchild); if(bt-&gt;rchild != NULL){ cout &lt;&lt; &quot;,&quot;; } DisplayBST(bt-&gt;rchild); cout &lt;&lt; &quot;)&quot;; } } } 测试下int main() { KeyType a[] ={25,18,46,2,53,39,32,4,74,67,60,11}; BST *bt; bt = Create(a,12); FindMaxMinNode(bt); DisplayBST(bt); cout &lt;&lt; endl; cout &lt;&lt; &quot;删除关键字为25的节点后树形结构如下：&quot; &lt;&lt; endl; Delete(bt,25); DisplayBST(bt); cout &lt;&lt; endl; return 0; } 结果截图 注：其实一直想将树可视化一下，暂时还没实现出来，先占个坑，稍后补上。","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"},{"name":"图算法","slug":"图算法","permalink":"https://sinclaircoder.top/tags/图算法/"}]},{"title":"2019第十届蓝桥杯CB组国赛心得","slug":"2019-05-28-2019第十届蓝桥杯CB组国赛心得","date":"2019-05-27T16:00:00.000Z","updated":"2020-01-21T12:28:32.994Z","comments":true,"path":"2019/05/28/2019-05-28-2019-di-shi-jie-lan-qiao-bei-cb-zu-guo-sai-xin-de/","link":"","permalink":"https://sinclaircoder.top/2019/05/28/2019-05-28-2019-di-shi-jie-lan-qiao-bei-cb-zu-guo-sai-xin-de/","excerpt":"一年一度的传说中的“暴力”杯又过去了，今年是第一次参加蓝桥杯省赛跟国赛，今天刚从北京回来，觉得应该写点东西，觉得不能再叫蓝桥杯暴力杯了当然大佬觉得还是暴力还请忽略，要改名了，今年难度有点大，首先题目数量变成了 10个，分值设置相对均匀5~25分的样子，之前分数梯度很大，然后难度也加了些，具体多少我也不是很清楚，我做去年第九届跟前年第十届的题目的时候也是很多也都不会做，有人下午比赛比了一半就溜出来了，觉得比CCPC还难，好吧，我还没参加过。我是C/C++B组，当时大概开始2小时左右我也想溜了，题目看到结尾了，好几个不会做的，看别人吃起了面包，觉得可能会分心，就没吃只是喝了口水，然后开始继续写，坚持到了最后，最后还是空了3个题目，大概两个大题，一个填空题，考完心凉了一半，下午6点考完，出来合了个影，既然比赛不顺利，那就玩耍的愉快吧，然后就开始了流浪北京，北京印象的日子。欢迎大家收看一年一集的《北京印象》，总共三集，当前是第一集。","text":"一年一度的传说中的“暴力”杯又过去了，今年是第一次参加蓝桥杯省赛跟国赛，今天刚从北京回来，觉得应该写点东西，觉得不能再叫蓝桥杯暴力杯了当然大佬觉得还是暴力还请忽略，要改名了，今年难度有点大，首先题目数量变成了 10个，分值设置相对均匀5~25分的样子，之前分数梯度很大，然后难度也加了些，具体多少我也不是很清楚，我做去年第九届跟前年第十届的题目的时候也是很多也都不会做，有人下午比赛比了一半就溜出来了，觉得比CCPC还难，好吧，我还没参加过。我是C/C++B组，当时大概开始2小时左右我也想溜了，题目看到结尾了，好几个不会做的，看别人吃起了面包，觉得可能会分心，就没吃只是喝了口水，然后开始继续写，坚持到了最后，最后还是空了3个题目，大概两个大题，一个填空题，考完心凉了一半，下午6点考完，出来合了个影，既然比赛不顺利，那就玩耍的愉快吧，然后就开始了流浪北京，北京印象的日子。欢迎大家收看一年一集的《北京印象》，总共三集，当前是第一集。比赛那天是周六，周六晚上在首都经贸吃了顿饭（考点在首都经贸）然后去奥体公园看了看，看了下鸟巢，水立方，逛了逛然后就回去了。周日早上下雨其实周六武汉淹了，真遗憾错过了，到了11点觉得待在酒店有点奢侈，有点浪费大好时光，然后冒雨出去逛故宫，逛之前吃了顿烤鸭，真难忘，逛完故宫，骑车观光北京，逛了几个北京的高校，感慨颇多，还是要努力学习，觉得自己的危机意识还是不强，周一中午就踏上了回学校的路。 周日上午大概10点左右在隔壁蓝桥备考群有人上传了获奖名单，翻了半天找到了自己，国二，属于国二下游那种，大概是矬子里拔将军，轮到了我，不过还是听惊喜的，拿了个奖， 下面简单写下题目情况，等到题目放出来更新题解。1.填空题求满足2019 &lt; x &lt; y且20192，x2，y2构成等差数列的x,y，使得x+y最小，输出最小的x+y。 2x2=20192+y2,写个循环找一下，结果是7020 2.填空题把2019分解成若干个两个质数之和，例如2017和2 与 2 和2017是一种情况，求有多少种。 比赛时，这个题目读题不仔细，看成了两个质数之和，暴力搜了一遍发现只有一种，反复核对还是一种，然后半信半疑的写了个1，就提交了。这个题目需要用DP ３.填空题给的是3x3的九个格子，然后如何分割，进行旋转，能完美拼接在一起，好像是问7*7的格子有多少种分案？ 这个题目真的跪了，一开始还能想象到是如何旋转的，后来怎末想都转不过去了，罢了罢了，是在下输了还是太菜 4.填空题大概是求有100个约数的最小整数（比如6有4个约数，1，2，3，6） 暴力枚举搜一下，搜到有100个约数的数就直接break 5.填空题6*6的方格里面从左上角顶点出发，问有多少条有向回路（尽管路径相同，但方向不同也是不同）路线不能出现交叉情况，路径长度不大于12 明显是个深搜题目，比赛之前准备了深搜，地图迷宫类没怎末准备，果然*，应该还是对深搜的理解不够深入，比赛之前敲了个DFS全排列的板子，在这上面改，当时改了半天，觉得很浪费时间，熟练度不够，然后就果断放弃，做后面的题目，唉，惋惜~ 6.编程大题字符串题目，给一个长串s1，一个短串s2，然后在s2中找s1的子序列，然后问最少需要修改s2的几个字符才能实现s2是s1的子序列 每次都被字符串教育，一看根本就不是板子题目，然后需要在板子的基础上稍加处理，当时先机智的跳过了，后来转过头来，写的时候硬着头皮写了个解法，当字符串中出现相同字符的时候的测试数据就过不去，罢了罢了能过几个过几个吧，因为最后回过头来写的时候，时间也不多了。 7.编程大题单调序列，如果三个数a,b,c，如果b&gt;a并且b&gt;c，或者b&lt;a并且b&lt;c则称b点为1个转折点（大概是这个意思）然后就会有1+1个严格单调区间，然后求1~n之间的数，全排列有多少个严格单调区间？ 用next_permutation全排列函数，或者用dfs深搜实现全排列，后来发现这样最多只能实现1~10之间的求解（20%的数据测试），n稍微一大，就一时半会出不来了，优化当时没想出来，反正20分的大题只能拿20%的分数，凉了 ~ 比赛完了，有个学长说这是个找规律的题目，是道数学题 ~ 果然，不加思索直接上去写，真的暴力 ~ 8.编程大题解密 题目记不太清了，当时直接跳了 9.编程大题求第八大奇迹，大致是一边输入数据一边查询第八大奇迹，第k大的问题？？然后奇迹值x会更新，每个查询求区间[l,r]之间的第八大奇迹。简化下：长度为n的序列A，初始值均为0。有m次操作，分为以下两种：1、C p x：把A[p]的值改为x.2、Q l r： 询问区间[l,r] 的第8大的数，不存在输出0。 当时写了好久这个题目，最后用了一个结构体，来保存查询信息，即Q，然后C就直接用数组即a[p] = x 然后拷贝出区间数据，然后进行排序，查询，觉得应该能过大部分数据，比赛完我看群里说要用线段树~ 还没学到~ 10.编程大题他们说是数学题，概率DP？？？当时直接跳了~ 所以算下来大概就是2道填空题，2道能过10%~20%数据的大题，还有一道能过70%或者80%数据的题目，国二下游，还是要努力，明年再见 ~ 哦 ~ 今年发了件T恤，蓝桥十周年，考场面包带回去给室友吃了、牛奶、矿泉水还可以，还有只印有蓝桥的圆珠笔。","categories":[{"name":"感悟","slug":"感悟","permalink":"https://sinclaircoder.top/categories/感悟/"}],"tags":[{"name":"竞赛感悟","slug":"竞赛感悟","permalink":"https://sinclaircoder.top/tags/竞赛感悟/"}]},{"title":"最妙不过位运算","slug":"2019-05-23-最妙不过位运算","date":"2019-05-22T16:00:00.000Z","updated":"2020-01-21T12:28:09.286Z","comments":true,"path":"2019/05/23/2019-05-23-zui-miao-bu-guo-wei-yun-suan/","link":"","permalink":"https://sinclaircoder.top/2019/05/23/2019-05-23-zui-miao-bu-guo-wei-yun-suan/","excerpt":"先来占个坑，以后慢慢补充。 一道蓝桥杯2018B组国赛题目 格雷码补全代码的题目格雷码是以n位的二进制来表示数。 与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。 首尾两个数字也要求只有1位之差。有很多算法来生成格雷码。以下是较常见的一种： 从编码全0开始生成。 当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0） 当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。 用这个规则产生的4位格雷码序列","text":"先来占个坑，以后慢慢补充。 一道蓝桥杯2018B组国赛题目 格雷码补全代码的题目格雷码是以n位的二进制来表示数。 与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。 首尾两个数字也要求只有1位之差。有很多算法来生成格雷码。以下是较常见的一种： 从编码全0开始生成。 当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0） 当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。 用这个规则产生的4位格雷码序列思路：偶数时直接异或1；奇数时找到最低位的1，然后将其左移一位，在于原来的值进行异或。试问，如何找到最低位的1？直接x&amp;(-x)即可！ #include &lt;stdio.h&gt; void show(int a,int n) { int i; int msk = 1; for(i=0; i&lt;n-1; i++) msk = msk &lt;&lt; 1; for(i=0; i&lt;n; i++){ printf((a &amp; msk)? &quot;1&quot; : &quot;0&quot;); msk = msk &gt;&gt; 1; } printf(&quot;\\n&quot;); } void f(int n) { int i; int num = 1; for(i=0; i&lt;n; i++) num = num&lt;&lt;1; int a = 0; for(i=0; i&lt;num; i++){ show(a,n); if(i%2==0){ a = a ^ 1; } else{ a = a^( (a&amp;(-a))&lt;&lt;1 ) ; //填空 } } } int main() { f(4); return 0; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"},{"name":"位运算","slug":"位运算","permalink":"https://sinclaircoder.top/tags/位运算/"}]},{"title":"DFS入门学习","slug":"2019-05-22-DFS入门学习","date":"2019-05-21T16:00:00.000Z","updated":"2020-01-21T12:27:25.859Z","comments":true,"path":"2019/05/22/2019-05-22-dfs-ru-men-xue-xi/","link":"","permalink":"https://sinclaircoder.top/2019/05/22/2019-05-22-dfs-ru-men-xue-xi/","excerpt":"学习DFS看了很多篇博客慢慢入门，感谢我看过的所有博客，我把其中做过的题目汇总起来，里面有很多是大神的代码，与大家分享。","text":"学习DFS看了很多篇博客慢慢入门，感谢我看过的所有博客，我把其中做过的题目汇总起来，里面有很多是大神的代码，与大家分享。@[toc] 计蒜客A1601全排列 计蒜客A1601全排列找的是全排列中，排列结果互不相同的个数 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N=1e3; char str[N], buf[N];//buffer int vis[N], total, len; void arrange(int num) { if (num == len){ printf(&quot;%s\\n&quot;, buf); total++; return; } for (int i = 0; i &lt; len; ++i) { if (!vis[i]) { int j; for (j = i + 1; j &lt; len; ++j) { if (vis[j]&amp;&amp;str[i] == str[j]) { break; } } if (j == len) { vis[i] = 1; buf[num] = str[i]; arrange(num + 1); vis[i] = 0; } } } } int main() { while (~scanf(&quot;%s&quot;,str)) { len = strlen(str); sort(str, str + len); total = 0; buf[len] = &#39;\\0&#39;; arrange(0); printf(&quot;Total %d\\n&quot;, total); } return 0; } 计蒜客A1636素数个数 计蒜客A1636素数个数 题目大致是求0~7的全排列组成的数字（首位不为0）中素数的个数，该题可理解为在全排列的基础上进行了条件限制 DFS+判断 答案：2668#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdlib&gt; using namespace std; typedef unsigned long long ll; int isPrime1(ll s) { if(s==2||s==3) return 1; if(s%6!=1&amp;&amp;s%6!=5) return 0; int t = sqrt(s); for(int i=5;i&lt;=t;i++) { if(s%i==0||s%(i+2)==0) return 0; } return 1; } int isPrime2(ll s) { for(int i=2;i*i&lt;=s;i++) { if(s%i==0) return 0 ; } return 1; } int a[8]= {0}; int vis[8] ={false}; int n; int cnt; void dfs(int x) { if(x == n) { int s = 0; for(int i=0;i&lt;n;i++) s += (a[i]*pow(10,x-1-i)); if(isPrime1(s)) { //cout &lt;&lt; s &lt;&lt; endl; cnt++; } return ; } for(int i=0;i&lt;n;i++) { if(i==0&amp;&amp;a[i]==0) continue; if(vis[i] ==false) { a[x] = i; vis[i] = true; dfs(x+1); vis[i] = false; } } } int main() { //cin &gt;&gt; n; n = 8; cnt = 0; dfs(0); //从0开始搜 cout &lt;&lt; cnt; return 0; } 2.调用现成的排列函数next_permutation(a,a+8)P.S：其实一开始把它给忘了，一直在想怎末用DFS来实现\\捂脸=_=，记得这个函数如果n较大会很耗时间，但是用这个函数可以减少代码量，刚好这个题是填空题 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt; using namespace std; typedef unsigned long long ll; int isPrime1(ll s) { if(s==2||s==3) return 1; if(s%6!=1&amp;&amp;s%6!=5) return 0; int t = sqrt(s); for(int i=5;i&lt;=t;i++) { if(s%i==0||s%(i+2)==0) return 0; } return 1; } int isPrime2(ll s) { for(int i=2;i*i&lt;=s;i++) { if(s%i==0) return 0 ; } return 1; } int a[8]; int main() { int t=0; int a[8]={0,1,2,3,4,5,6,7}; do{ if(a[0]==0) continue; else { int b=0; b=a[0]*10000000+a[1]*1000000+a[2]*100000+a[3]*10000+a[4]*1000+a[5]*100+a[6]*10+a[7]*1; if(isPrime1(b)) t++; } }while(next_permutation(a,a+8));//C++中的全排列函数 cout&lt;&lt;t; return 0; } 计蒜客A1146补全等式计蒜客A1146补全等式1.暴力解法：全排列+判断 时间稍长预计需要172.4s 答案：122368 // #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { int a[13]; for(int i=0;i&lt;13;i++) { a[i] = i+1; } int cnt =0; do{ if(a[0]*a[1]+a[2]*a[3] == a[4]*a[5]&amp;&amp; a[6]*a[7]-a[8]*a[9] == a[10]*a[11]) cnt ++; }while(next_permutation(a,a+13)); cout &lt;&lt; cnt; return 0; } DFS+剪枝 0.88s```java include include include using namespace std;int vis[15], a[15];int ans;void dfs(int cur){ if(cur == 6) { if(a[0]a[1] + a[2]a[3] != a[4]a[5]) return; } if(cur == 12) { if(a[6]a[7] + a[8]a[9] == a[10]a[11]) ans++; return; } for(int i = 1; i &lt;= 13; ++i) { if(!vis[i]) { vis[i] = 1; a[cur] = i; dfs(cur+1); vis[i] = 0; } }} int main() { ans = 0; memset(vis, 0, sizeof(vis)); dfs(0); cout &lt;&lt; ans; return 0;} ## Codeup5974: 【递归入门】组合+判断素数 [Codeup5974: 【递归入门】组合+判断素数](http://codeup.cn/problem.php?id=5974) ```java #include&lt;iostream&gt; #include&lt;string.h&gt; using namespace std; typedef long long ll; int a[21] = {0}; int num,k,n; ll sum; int isPrime(int s) { for(int i=2;i*i&lt;=s;i++) { if(s%i==0) return 0; } return 1; } void dfs(int index, int x, ll sum) { if(x == k){ if(isPrime(sum)) num++; return ; } if(index == n+1) return ; dfs(index+1, x+1, sum+a[index]); //index 数组a的下标 x为已选个数 dfs(index+1, x, sum); } int main() { num = 0; cin &gt;&gt; n &gt;&gt; k; for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i]; dfs(1,0,0); cout &lt;&lt; num; return 0; } 实现全排列（可单调递增）#include&lt;iostream&gt; #include&lt;string.h&gt; using namespace std; int p[10]= {0}; bool vis[10] = {false}; int n; void dfs(int x) { if(x == n+1) { for(int i=1;i&lt;=n;i++) cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } for(int i=1;i&lt;=n;i++) { //if(vis[i]==false) if(vis[i]==false&amp;&amp;i&gt;p[x-1]) /*如若实现单调递增的全排列 */ { p[x] = i; vis[i] = true; dfs(x+1); vis[i] = false; } } } int main() { while(cin &gt;&gt; n) { dfs(1); memset(p,0,sizeof(p)); memset(vis,false,sizeof(vis)); } return 0; } 1~n求所有可能的出栈序列（序列个数）首先先考虑序列个数有两种解法1.卡特兰树$\\tbinom{n}{2n}$/(n+1) #include&lt;iostream&gt; #include&lt;string.h&gt; using namespace std; int n; int fun(int n) //当然这里n不能过大，过大的话会爆，需要另当别论 { int s = 1; for(int i=2*n,j=1;i&gt;=n+1,j&lt;=n;i--,j++) { s = s*i/j; } return s; } int main() { cin &gt;&gt; n; cout &lt;&lt; fun(n)/(n+1); return 0; } 2.DFS思想，用三个变量，num表示栈内元素个数，假如想进栈出栈n个元素对应的需要进栈n次出栈n次，用push表示所需进栈次数，pop表示所需出栈次数 #include&lt;iostream&gt; #include&lt;string.h&gt; using namespace std; int n; int p[10]={0}; bool vis[10] = {false}; int count; void dfs(int num, int pop, int push) { if(pop==0&amp;&amp;push==0) { count++; return ; } if(push&gt;0) dfs(num+1,pop,push-1); if(pop&gt;0&amp;&amp;num&gt;0) dfs(num-1,pop-1,push); } int main() { cin &gt;&gt; n; count = 0; dfs(0,n,n); cout &lt;&lt; count; return 0; } 【递归入门】n皇后 问题（原始的8皇后问题）【递归入门】n皇后 问题（原始的8皇后问题） #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; const int maxn = 25; int c = 0,Data[maxn] = {0};//c代表解的个数 bool hashTable[maxn] = {0}; void dfs(int n, int k) // 在n行n列的棋盘上在第k行放置皇后，进行尝试 { if(k &gt; n) { for(int i=1;i&lt;=n;i++) { cout &lt;&lt; Data[i]; if(i&lt;n) cout &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; c++; } for(int i=1;i&lt;=n;i++) { if(hashTable[i] == false) { bool isvalid = true; for(int j =1;j&lt;k;j++) { if(k-j == abs(i-Data[j])) // (k,i) 与 (j,Data[j]) { isvalid = false; break; } } if(isvalid) { hashTable[i] = true; Data[k] = i; dfs(n,k+1); hashTable[i] = false; } } } } int main() { int n; cin &gt;&gt; n; c = 0; dfs(n,1); if(c==0) cout &lt;&lt; &quot;no solute!&quot;&lt;&lt; endl; cout &lt;&lt; &quot;total:&quot; &lt;&lt; c &lt;&lt; endl; return 0; } HDU2553 N皇后问题HDU2553 N皇后问题DFS+打表打表很重要，不然很可能超时，来个TLE！ #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; using namespace std; int sum,n; int x[15],y[15]={0}; int place(int k) { int i; for(i=1;i&lt;k;i++) { if(abs(k-i)==abs(x[k]-x[i])||x[k]==x[i]) { return 0; } } return 1; } void dfs(int a) { int i; if(a&gt;n) { sum++; return ; } else for(i=1;i&lt;=n;i++) { x[a] = i; if(place(a)) dfs(a+1); } } int main() { int i,j,n1; for(int i=1;i&lt;=10;i++) { n = i; sum = 0; dfs(1); y[i] = sum; } while(cin &gt;&gt; n1 &amp;&amp;n1) { cout &lt;&lt; y[n1] &lt;&lt; endl; } return 0; } 激光样式 这是一道2018蓝桥B组国赛题目 大概是就是有三十盏灯，排成一排，相邻两盏灯不能同时打开，问有多少种打开方式？当然全都不打开也算一种。1.位运算 2.433s偶然间看到一位大神的解法，觉得位运算是真的厉害，大概思想是用一个整型x来表示排列情况，将x左移一位，然后在于x本身相与，假如结果为0，就表明这是一种正确的排列方式，然后计数，代码真的是太简单了 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; bool get(int x) { if(x&amp;(x&lt;&lt;1)) return false; else return true; } int main() { int ans = 0; for(int i=0;i&lt;1&lt;&lt;30;i++) { if(get(i)){ ans++; } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } 2.DFS不过说起来还是深搜快，零点几秒，反正这是个填空题，能做出来就行呗。 #include&lt;iostream&gt; #include&lt;string.h&gt; using namespace std; typedef long long ll; ll ans; int light[31]; void dfs(int x) { if(x == 31) { ans++; return ; } if(light[x-1] == 0) { light[x] = 1; dfs(x+1); light[x] = 0; } dfs(x+1); } int main() { dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0; } 【递归入门】走迷宫Codeup5978【递归入门】走迷宫 #include&lt;iostream&gt; using namespace std; int a[20][20], endx, endy, m, n; bool no = true; int dx[4] = { 0,-1,0,1 }, dy[4] = { -1,0,1,0 }; struct Route { int x, y; }route[5000]; void DFS(int x, int y, int num) { if (x == endx&amp;&amp;y == endy) { for (int i = 0; i &lt; num; i++) { printf(&quot;(%d,%d)-&gt;&quot;,route[i].x,route[i].y); } printf(&quot;(%d,%d)\\n&quot;,x,y); no = false; return; } route[num].x = x, route[num].y = y; for (int i = 0; i &lt; 4; i++) { if (a[x + dx[i]][y + dy[i]] == 1 &amp;&amp; 1 &lt;= x + dx[i] &lt;= m &amp;&amp; 1 &lt;= y + dy[i] &lt;= n) { a[x][y] = 0; DFS(x + dx[i], y + dy[i], num + 1); a[x][y] = 1; } } } int main() { while (cin &gt;&gt; m &gt;&gt; n) { for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; a[i][j]; } } int startx, starty; cin &gt;&gt; startx &gt;&gt; starty &gt;&gt; endx &gt;&gt; endy; DFS(startx, starty, 0); if (no) cout &lt;&lt; -1 &lt;&lt; endl; } return 0; }","categories":[{"name":"搜索","slug":"搜索","permalink":"https://sinclaircoder.top/categories/搜索/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"},{"name":"DFS","slug":"DFS","permalink":"https://sinclaircoder.top/tags/DFS/"}]},{"title":"7-29 修理牧场","slug":"2019-05-04-7-29 修理牧场","date":"2019-05-03T16:00:00.000Z","updated":"2020-01-21T12:46:22.670Z","comments":true,"path":"2019/05/04/2019-05-04-7-29-xiu-li-mu-chang/","link":"","permalink":"https://sinclaircoder.top/2019/05/04/2019-05-04-7-29-xiu-li-mu-chang/","excerpt":"来源：(PTA数据结构与算法题目集(中文) 农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数Li个长度单位，于是他购买了一条很长的、能锯成N块的木头，即该木头的长度是Li的总和。但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。请编写程序帮助农夫计算将木头锯成N块的最少花费。","text":"来源：(PTA数据结构与算法题目集(中文) 农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数Li个长度单位，于是他购买了一条很长的、能锯成N块的木头，即该木头的长度是Li的总和。但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。请编写程序帮助农夫计算将木头锯成N块的最少花费。 输入格式:输入首先给出正整数N（≤10​4），表示要将木头锯成N块。第二行给出N个正整数（≤50），表示每段木块的长度。 输出格式:输出一个整数，即将木头锯成N块的最少花费。 输入样例:84 5 1 2 1 3 1 1输出样例:49 // 哈夫曼树 #include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;queue&gt; using namespace std; int main() { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;p; int n; cin &gt;&gt; n; for(int i=0;i&lt;n;i++){ int t; cin &gt;&gt; t; p.push(t); } int s=0; while(p.size()&gt;1){ int num1 = p.top(); p.pop(); int num2 = p.top(); p.pop(); s += (num1+num2); p.push(num1+num2); } cout &lt;&lt; s; return 0; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"},{"name":"优先队列","slug":"优先队列","permalink":"https://sinclaircoder.top/tags/优先队列/"}]},{"title":"第一次参加蓝桥杯(第十届)感怀","slug":"2019-03-24-第一次参加蓝桥杯(第十届)感怀","date":"2019-03-23T16:00:00.000Z","updated":"2020-01-21T12:26:59.091Z","comments":true,"path":"2019/03/24/2019-03-24-di-yi-ci-can-jia-lan-qiao-bei-di-shi-jie-gan-huai/","link":"","permalink":"https://sinclaircoder.top/2019/03/24/2019-03-24-di-yi-ci-can-jia-lan-qiao-bei-di-shi-jie-gan-huai/","excerpt":"四个小时，十道题目，花了学院300块大洋 \\捂脸","text":"四个小时，十道题目，花了学院300块大洋 \\捂脸这是我第一次参加规模还差不多的程序设计比赛，蓝桥杯，当然一些大牛高校的王牌选手是不稀罕参加的，网上风评称其为“暴力杯”，说根本用不到什么算法技巧，只要会点数学，全程暴力求解就ok，比赛之前看了很多关于蓝桥杯的经验贴，其中出现频率最高的词汇是暴力求解，后来慢慢的训练的做题目的时候，才知道什么是真正的暴力求解，所谓暴力求解，并非无脑不假思索的就直接暴力枚举，而是要经过若干逻辑判断之后，进行求解，相比于十分精巧的算法技巧来说，是暴力了些。比赛的前一天，也就是昨天，我还在看蓝桥杯必考的快排、DFS、贪心….结果必考的没考，没考快排，考了DFS，一道迷宫题目，当时看了看，因为深搜不熟练，觉得做这道题目的话，做半天可能也做不出来，白浪费时间干脆直接跳过，这道题是填空题，15分，下了考场之后，群里有人说这是一道华为的面试题目，好吧。同样是参加蓝桥杯，车上有18级的、17级的还有16级的，我是17级但是今年是第一次参加蓝桥杯，我大一这时候，听老师的话自己的笔记本还没买…经过我的亲身经历证明，对于计算机专业来说，这是万万不行的，我大一一年一直停留在C，C还没精通，而别人大一就学完了C、C++、数据结构甚至更多，而我大一的时间都去哪儿了，我用我的时间换来了什么？都是值得思考的问题，终于我在大一的暑假反应过来，励志大二上学完数据结构，可是大二上课多，再加上自己的惰性，这个历史性的任务终究还是没完成。大二上参加的学院老师讲的蓝桥杯培训课，去是每次都去了，可是也仅仅是听了听，自己也没有下去动手，导致编码能力太差，到现在，我发现18级的很多学生的编码能力已经比我强了…当然这种事情也说不好，毕竟起跑线不同我又在给自己找借口，菜就是原罪。等到了大二上期末考试考完之后，留校做课设，那个时候我开始准备蓝桥杯，从数论开始学起，没学多少放寒假了，打算寒假训练自己的编码能力，顺便学学数据结构的，结果学习的重心不知不觉跑到了JAVA上。我就是这样一步一步的鸽掉我的算法训练的…到了大二下学期，正儿八经的自我反思过后，决心要努力学习训练算法，没事就刷题，周末时间抱着电脑图书馆刷各大OJ上的题目，看别人说，先来刷个杭电OJ 100题水题100道。然而我到现在也只是异常费劲的写了35道，前几天学习算法知识，做题目，越做越绝望，看一道不会，看一道不会，然后去网上找解题报告看，学习别人的思路，看别人的做法，我立誓要学好算法，去参加各种程序设计比赛，让日后的每一天都不会像现在一样窘迫。昨天周六，比赛前一天，我在图书馆看了一天的往年题目，也思考了很多，思考我努力学习算法到底是为了什么？为了参加比赛？为了拿奖？用拿来的奖来证明自己？用拿来的奖来争取推免资格？我想了又想，我最初就是为了拿到推免资格来参加比赛，一直心急的去参加各种比赛，以前参加的全国大学生数学竞赛、全国大学英语竞赛，每次都是匆匆上阵，每次都是落荒而逃，每次都是说下次一定再去努力。那便是我的2018年的写照。参加程序设计比赛是为了拿奖，而不是出于对编程的热爱，一直以来，觉得自己一个很大的缺点，就是太过于急功近利，我没有别人的聪明才智，也没有别人的超高效率，更没有比别人很强的能力，却总想着去用做一件事的时间来做两件事，有时候会面对两个比赛，别人可能会有所取舍，而我却总想着我能做到，然后急功近利的去报了两个比赛的名，然后最后可能一个比赛的作品都提交不上。如今2019了，不能再鸽了，不能再中途放弃了，包括写博客，这是我2019年开始写的，我的博客搭建好了, 2019年要去更加努力、更加自律、更加脚踏实地、不能再去做思想上的巨人而行动上的侏儒了，今天的蓝桥杯落下帷幕，下周的高校天梯赛，由于种种原因，参赛名单里没我，正好我可以重新训练，学习我要今年3月份完成的数据结构教程学习，还要补作业，写一个带界面的迷宫算法，算是个小课设。接下来的希望就是我能进阶决赛，去首都走一趟。能不能进决赛，下周比赛结果就出来了。最近的一个比赛可能就是中国高校微信小程序比赛，要准备参赛了。总要做出点东西来，才不枉自己对一步步接近梦想时内心的汹涌与澎湃。另外，自己的暑假也被安排上了，前20天去导师实验室跟着做项目学习假如我啥都不会做，那我扫地好了后面的一个月参加数学建模培训，参赛，另外把去年失之交臂的数竞再来一遍，不到长城非好汉，人啊，总是失去了才知道珍惜，当我重新再拿到机会时我想我会倍加珍惜…再来谈谈今天的蓝桥杯，今天去的赛点是一个民办大学，一下车觉得这所学校未免也有点太高端，比我的学校好太多，这建筑、这校园、这高楼，真想来这里读大学，当然这是参赛之前的想法，当我参加完比赛之后，我的认知发生了变化你懂的，与更好的校园设施（宽敞的校园、气派的大门，高端的大楼）相比，我还是更喜欢学习氛围、学术氛围更加浓厚的学校，尽管它的校门可能不是那么气派。 更于2019年3月28日初赛结果出来了，省一，要准备国赛了…","categories":[{"name":"感悟","slug":"感悟","permalink":"https://sinclaircoder.top/categories/感悟/"}],"tags":[{"name":"竞赛感悟","slug":"竞赛感悟","permalink":"https://sinclaircoder.top/tags/竞赛感悟/"}]},{"title":"HDU2032之杨辉三角的多种解法","slug":"2019-03-09-HDU2032之杨辉三角的多种解法","date":"2019-03-08T16:00:00.000Z","updated":"2020-01-21T12:26:42.491Z","comments":true,"path":"2019/03/09/2019-03-09-hdu2032-zhi-yang-hui-san-jiao-de-duo-chong-jie-fa/","link":"","permalink":"https://sinclaircoder.top/2019/03/09/2019-03-09-hdu2032-zhi-yang-hui-san-jiao-de-duo-chong-jie-fa/","excerpt":"HDU2032 还记得中学时候学过的杨辉三角吗？具体的定义这里不再描述，你可以参考以下的图形：11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1 即元素值等于肩上的两个元素之和，每行第一个跟最后一个都为１。","text":"HDU2032 还记得中学时候学过的杨辉三角吗？具体的定义这里不再描述，你可以参考以下的图形：11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1 即元素值等于肩上的两个元素之和，每行第一个跟最后一个都为１。 //解法１、二维数组 int main() { int n,a[30][30]={0}; while(cin&gt;&gt; n) { for(int i=0;i&lt;n;i++) { a[i][0]=1;a[i][i]=1; } for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;=i;j++) { if(j&gt;0) a[i][j] = a[i-1][j] + a[i-1][j-1]; cout &lt;&lt; a[i][j]; if(j&lt;i) cout &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } return 0; } //解法2、一维数组 int main() { int n; while(cin&gt;&gt;n) { int a[40]={0},b[40]={0}; //此处会涉及到初始化问题，故须放到while循环里面 a[1]=1;b[1]=1; for(int i=1;i&lt;=n;i++) // 此处索引从1开始 { for(int j=1;j&lt;=i;j++) { a[j]=b[j]+b[j-1]; } for(int j=1;j&lt;=i;j++) { b[j] = a[j] ; cout&lt;&lt; b[j] ; if(j&lt;i) cout &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } return 0; } //解法3、多项式 杨辉三角中每一行的值为C（ｎ－１，ｍ），其中n为行数，m为列数索引 int fun(int n,int m) { int s1=1,j=1; for(int i=n;i&gt;n-m;i--) { s1 =s1*i/j; j++; } return s1; } int main() { int n; while(cin&gt;&gt; n) { for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;=i;j++) { cout &lt;&lt; fun(i,j); if(j&lt;i)cout &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } return 0; } // 解法4、递推法，发现规律 int main() { int n; while(cin&gt;&gt;n) { for(int i=1;i&lt;=n;i++) { int b=1; for(int j=1;j&lt;=i;j++) { cout &lt;&lt; b; b = b*(i-j)/j; // 下一个元素值=上一个*(行数-列数)/列数 if(j&lt;i) cout &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } return 0; } 本该大一学会的，现在才学会，我干了什么？我究竟用时间换来了什么？","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"},{"name":"HDU","slug":"HDU","permalink":"https://sinclaircoder.top/tags/HDU/"}]},{"title":"一个小绿锁引发的问题","slug":"2019-03-08-博客添加SSL","date":"2019-03-07T16:00:00.000Z","updated":"2020-01-21T12:26:24.170Z","comments":true,"path":"2019/03/08/2019-03-08-bo-ke-tian-jia-ssl/","link":"","permalink":"https://sinclaircoder.top/2019/03/08/2019-03-08-bo-ke-tian-jia-ssl/","excerpt":"最近在阿里云买了个域名，毕竟**.github.io有点长，买了个便宜的top。在阿里云控制台解析了之后，后来访问的时候总是显示非安全连接，身为强迫症患者，这肯定不能忍，然后就着手开始做了。 据外媒报道，从2017年1月份正式发布的Chrome 56开始，Google将把某些包含敏感内容的HTTP页面标记为“不安全”，比如含有密码或支付表单信息。Google最终目标是将所有打破了https连接的HTTP页面，用特定的红色图标给标记出来… 此举旨在唤起用户有关HTTP连接不安全、容易受到中间人攻击等危险的意识。通过HTTP连接发送的数据（比如密码和支付细节），会被通网络下别有用心的人轻易拦截。 为了这把小绿锁（安全问题），需要添加第三方的证书，这时Cloudflare提供的免费的SSL成为不二之选 收费的SSL服务总是比免费的更加周到，一般收费的SSL都会提供端到端的加密。但是价格不菲，对于个人博客来说，这是一笔不必要的开销。我只是需要看到网站地址栏有绿色的锁头，那就证明我们的网站相对安全了。此外，使用https之后，谷歌、百度等搜索排名权值（PR等）也会有相对提升。还有其他的一些，例如Cloudflare还提供免费的CDN和缓存技术，让浏览者有更好的体验~~","text":"最近在阿里云买了个域名，毕竟**.github.io有点长，买了个便宜的top。在阿里云控制台解析了之后，后来访问的时候总是显示非安全连接，身为强迫症患者，这肯定不能忍，然后就着手开始做了。 据外媒报道，从2017年1月份正式发布的Chrome 56开始，Google将把某些包含敏感内容的HTTP页面标记为“不安全”，比如含有密码或支付表单信息。Google最终目标是将所有打破了https连接的HTTP页面，用特定的红色图标给标记出来… 此举旨在唤起用户有关HTTP连接不安全、容易受到中间人攻击等危险的意识。通过HTTP连接发送的数据（比如密码和支付细节），会被通网络下别有用心的人轻易拦截。 为了这把小绿锁（安全问题），需要添加第三方的证书，这时Cloudflare提供的免费的SSL成为不二之选 收费的SSL服务总是比免费的更加周到，一般收费的SSL都会提供端到端的加密。但是价格不菲，对于个人博客来说，这是一笔不必要的开销。我只是需要看到网站地址栏有绿色的锁头，那就证明我们的网站相对安全了。此外，使用https之后，谷歌、百度等搜索排名权值（PR等）也会有相对提升。还有其他的一些，例如Cloudflare还提供免费的CDN和缓存技术，让浏览者有更好的体验~~ 下面是我参考的教程(博主尊重原创，故此下面只给出超链)：为自定义域名的GitHub Pages添加SSL 完整方案为添加了自定义域名的GitHub Pages添加SSL，启用强制HTTPS(小绿锁） 总之，博客愈发完善，每次改动都会碰见一堆高大上的专业术语，而他们却真实的来自那看起来枯燥无聊的基础知识，实战受蹩，或许看书应该能更加投入。等技术再成熟些，博客应该会更完善！ 调试完一个动态连接函数，固然值得兴奋，但真正的成功远还在无数个函数之后。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://sinclaircoder.top/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://sinclaircoder.top/tags/Blog/"}]},{"title":"HDU2018母牛的故事","slug":"2019-03-03-HDU2018母牛的故事","date":"2019-03-02T16:00:00.000Z","updated":"2020-01-21T12:46:13.336Z","comments":true,"path":"2019/03/03/2019-03-03-hdu2018-mu-niu-de-gu-shi/","link":"","permalink":"https://sinclaircoder.top/2019/03/03/2019-03-03-hdu2018-mu-niu-de-gu-shi/","excerpt":"Problem Description 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 Output 对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。","text":"Problem Description 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 Output 对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 Sample Input 2450 Sample Output246 分析根据题目已知，列出表格 第n年 成年牛 幼牛1 幼牛2 幼牛3 总数 1 1 1 2 1 1 2 3 1 1 1 3 4 1 1 1 1 4 5 2 2 1 1 6 6 3 3 2 1 9 7 4 4 3 2 13 8 6 6 4 3 19 9 9 9 6 4 28 … … … … … … 观察表格，联想斐波那契数列，可得出以下公式： fn = fn-1 + fn-3 题解//解法1 #include&lt;iostream&gt; using namespace std; int main() { int n; while(cin&gt;&gt;n&amp;&amp;n!=0) { int a[56]; a[0] = 1;a[1] = 2;a[2] = 3;a[3] = 4; for(int i=4;i&lt;56;i++) a[i] = a[i-1] + a[i-3]; cout &lt;&lt; a[n-1] &lt;&lt; endl; } return 0; } //解法2—递归实现 #include &lt;iostream&gt; using namespace std; int fun(int n) { if(n&lt;5) return n; else return fun(n-1)+fun(n-3); } int main() { int n; while(cin&gt;&gt;n&amp;&amp;n!=0) { cout &lt;&lt; fun(n) &lt;&lt; endl; } return 0; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"}]},{"title":"Python3字符串API之expandtabs()","slug":"2019-02-11-Python3字符串API之expandtabs()","date":"2019-02-10T16:00:00.000Z","updated":"2020-01-21T12:46:10.746Z","comments":true,"path":"2019/02/11/2019-02-11-python3-zi-fu-chuan-api-zhi-expandtabs/","link":"","permalink":"https://sinclaircoder.top/2019/02/11/2019-02-11-python3-zi-fu-chuan-api-zhi-expandtabs/","excerpt":"Challenges make you discover things about yourself that you never really knew.挑战能让你发现自己都不曾了解过的一面。 ——-Cicely Tyson 描述 def expandtabs(self, *args, **kwargs): # real signature unknown** &quot;&quot;&quot; Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. &quot;&quot;&quot; pass 返回字符串的一个拷贝，该拷贝中把字符串中的tab (即’\\t‘)转换为指定的tabsize数量的空格，其中若tabsize未给出则默认为8.","text":"Challenges make you discover things about yourself that you never really knew.挑战能让你发现自己都不曾了解过的一面。 ——-Cicely Tyson 描述 def expandtabs(self, *args, **kwargs): # real signature unknown** &quot;&quot;&quot; Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. &quot;&quot;&quot; pass 返回字符串的一个拷贝，该拷贝中把字符串中的tab (即’\\t‘)转换为指定的tabsize数量的空格，其中若tabsize未给出则默认为8. 语法 str.expandtabs(tabsize = 8); 实例其实还是例子更直观 # 代码段 print(&quot;第一行为基准&quot;) print(&quot;123456789012345678901&quot;) s1 = &quot;123456\\t7890\\t123&quot; print(s1) print(s1.expandtabs(6)) print(s1.expandtabs(7)) print(s1.expandtabs(8)) print(s1.expandtabs(9)) s2 = &quot;\\t12\\t345678\\t123&quot; print(s2) print(s2.expandtabs()) # 结果显示 第一行为基准 123456789012345678901 123456 7890 123 123456 7890 123 123456 7890 123 123456 7890 123 123456 7890 123 12 345678 123 12 345678 123 总结 &emsp;&emsp;expandtabs() 方法是把字符串中的’\\t’转换为空格。 &emsp;&emsp;下面首先来说说’\\t’，在Python3中 ‘\\t’ 是补4的整数倍个空格，假如’\\t’在字符串首，则会补4个空格，当在串中时要看’\\t’前面的字符，距离4的整数倍差多少补多少空格。 &emsp;&emsp;下面再说一下这个 expandtabs() 方法就是在 ‘\\t’ 处补指定长度tabsize的空格，可以自定指定，也可以使用默认的补8个空格，即看前面的字符串然后将其补到tabsize的整数倍，假如’\\t’在串首则直接补tabsize数量的空格。","categories":[{"name":"Python3","slug":"Python3","permalink":"https://sinclaircoder.top/categories/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://sinclaircoder.top/tags/Python3/"}]},{"title":"Java中关于日期的printf格式化输出","slug":"2019-02-09-Java中关于日期的printf格式化输出","date":"2019-02-08T16:00:00.000Z","updated":"2020-01-21T12:46:07.852Z","comments":true,"path":"2019/02/09/2019-02-09-java-zhong-guan-yu-ri-qi-de-printf-ge-shi-hua-shu-chu/","link":"","permalink":"https://sinclaircoder.top/2019/02/09/2019-02-09-java-zhong-guan-yu-ri-qi-de-printf-ge-shi-hua-shu-chu/","excerpt":"If you believe in yourself enough and know what you want, you’re gonna make it happen.如果你足够自信，也知道自己想要什么，就一定会实现心中所想。——-Mariah Carey, “Make It Happen” printf方法可以很轻易的格式化日期，用两个字母，以%t开头并以下面的其中一个字母结尾。转换符|说明—-|—-|—-|——-a|日期中星期简称A|日期中星期全称b|日期中月份的简称B|日期中月份的全称C|日期中年份的前两位数y|日期中年份的后两位数Y|日期中年份的完整表示D|“年/月/日”格式F|“年-月-日”格式j|一年中的第几天m|日期中的月份，两位数字表示，不足两位补零d|日期中的日，两位数字表示，不足两位补零e|日期中月份的日，不补零T|“HH:MM:SS” 格式（24小时）r|“HH:MM:SS PM”格式（12小时）R|“HH:MM”格式（24小时） 测试public class Sinclair_java_20190122 { public static void main(String[] args) { Date date = new Date(); String str = String.format(Locale.US,&quot;英文月份简称：%tb&quot;,date); System.out.println(str); System.out.printf(&quot;本地月份简称：%tb\\n&quot;,date); str = String.format(Locale.US, &quot;英文月份全称：%tB&quot;,date); System.out.println(str); System.out.printf(&quot;本地月份全称：%tB%n&quot;,date); str = String.format(Locale.US, &quot;英文星期简称：%ta&quot;,date); System.out.println(str); System.out.printf(&quot;本地星期的全称：%tA%n&quot;,date); System.out.printf(&quot;本地星期的简称：%ta%n&quot;,date); System.out.printf(&quot;年的前两位数字：%tC%n&quot;,date); System.out.printf(&quot;年的后两位数字：%ty%n&quot;,date); System.out.printf(&quot;年的完整表示：%tY%n&quot;,date); System.out.printf(&quot;一年中的天数：%tj%n&quot;,date); System.out.printf(&quot;%s %tY-%&lt;tm-%&lt;td%n&quot;,&quot;日期的完整表示：&quot;,date); System.out.printf(&quot;在本月是第几天(不补零)：%te%n&quot;,date); System.out.printf(&quot;在本月是第几天(补零)：%td%n&quot;,date); } }","text":"If you believe in yourself enough and know what you want, you’re gonna make it happen.如果你足够自信，也知道自己想要什么，就一定会实现心中所想。——-Mariah Carey, “Make It Happen” printf方法可以很轻易的格式化日期，用两个字母，以%t开头并以下面的其中一个字母结尾。转换符|说明—-|—-|—-|——-a|日期中星期简称A|日期中星期全称b|日期中月份的简称B|日期中月份的全称C|日期中年份的前两位数y|日期中年份的后两位数Y|日期中年份的完整表示D|“年/月/日”格式F|“年-月-日”格式j|一年中的第几天m|日期中的月份，两位数字表示，不足两位补零d|日期中的日，两位数字表示，不足两位补零e|日期中月份的日，不补零T|“HH:MM:SS” 格式（24小时）r|“HH:MM:SS PM”格式（12小时）R|“HH:MM”格式（24小时） 测试public class Sinclair_java_20190122 { public static void main(String[] args) { Date date = new Date(); String str = String.format(Locale.US,&quot;英文月份简称：%tb&quot;,date); System.out.println(str); System.out.printf(&quot;本地月份简称：%tb\\n&quot;,date); str = String.format(Locale.US, &quot;英文月份全称：%tB&quot;,date); System.out.println(str); System.out.printf(&quot;本地月份全称：%tB%n&quot;,date); str = String.format(Locale.US, &quot;英文星期简称：%ta&quot;,date); System.out.println(str); System.out.printf(&quot;本地星期的全称：%tA%n&quot;,date); System.out.printf(&quot;本地星期的简称：%ta%n&quot;,date); System.out.printf(&quot;年的前两位数字：%tC%n&quot;,date); System.out.printf(&quot;年的后两位数字：%ty%n&quot;,date); System.out.printf(&quot;年的完整表示：%tY%n&quot;,date); System.out.printf(&quot;一年中的天数：%tj%n&quot;,date); System.out.printf(&quot;%s %tY-%&lt;tm-%&lt;td%n&quot;,&quot;日期的完整表示：&quot;,date); System.out.printf(&quot;在本月是第几天(不补零)：%te%n&quot;,date); System.out.printf(&quot;在本月是第几天(补零)：%td%n&quot;,date); } } 测试结果英文月份简称：Feb 本地月份简称：2月 英文月份全称：February 本地月份全称：二月 英文星期简称：Sat 本地星期的全称：星期六 本地星期的简称：周六 年的前两位数字：20 年的后两位数字：19 年的完整表示：2019 一年中的天数：040 日期的完整表示： 2019-02-09 在本月是第几天(不补零)：9 在本月是第几天(补零)：09 大家新年好哇！","categories":[{"name":"Java","slug":"Java","permalink":"https://sinclaircoder.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sinclaircoder.top/tags/Java/"}]},{"title":"HDU2097Sky数","slug":"2019-01-09-HDU 2097Sky数","date":"2019-01-08T16:00:00.000Z","updated":"2020-01-21T12:25:28.749Z","comments":true,"path":"2019/01/09/2019-01-09-hdu-2097sky-shu/","link":"","permalink":"https://sinclaircoder.top/2019/01/09/2019-01-09-hdu-2097sky-shu/","excerpt":"Sky数 My life didn’t please me, so I created my life.我的生活不曾取悦于我，所以我创造了自己的生活 ———-Coco Chanel Problem Description Sky从小喜欢奇特的东西，而且天生对数字特别敏感，一次偶然的机会，他发现了一个有趣的四位数2992，这个数它的十进制数表示，其四位数字之和为2+9+9+2=22，它的十六进制数BB0，其四位数字之和也为22，同时它的十二进制数表示1894，其四位数字之和也为22，啊哈，真是巧啊。Sky非常喜欢这种四位数，由于他的发现，所以这里我们命名其为Sky数。但是要判断这样的数还是有点麻烦啊，那么现在请你帮忙来判断任何一个十进制的四位数，是不是Sky数吧。 Input 输入含有一些四位正整数，如果为0，则输入结束。 Output 若n为Sky数，则输出“#n is a Sky Number.”，否则输出“#n is not a Sky Number.”。每个结果占一行。注意：#n表示所读入的n值。","text":"Sky数 My life didn’t please me, so I created my life.我的生活不曾取悦于我，所以我创造了自己的生活 ———-Coco Chanel Problem Description Sky从小喜欢奇特的东西，而且天生对数字特别敏感，一次偶然的机会，他发现了一个有趣的四位数2992，这个数它的十进制数表示，其四位数字之和为2+9+9+2=22，它的十六进制数BB0，其四位数字之和也为22，同时它的十二进制数表示1894，其四位数字之和也为22，啊哈，真是巧啊。Sky非常喜欢这种四位数，由于他的发现，所以这里我们命名其为Sky数。但是要判断这样的数还是有点麻烦啊，那么现在请你帮忙来判断任何一个十进制的四位数，是不是Sky数吧。 Input 输入含有一些四位正整数，如果为0，则输入结束。 Output 若n为Sky数，则输出“#n is a Sky Number.”，否则输出“#n is not a Sky Number.”。每个结果占一行。注意：#n表示所读入的n值。 Sample Input 299212340 Sample Output 2992 is a Sky Number.1234 is not a Sky Number. 思路 输入一个四位整数，需要将其进制转换，而在进制转换的过程中又可以实现四位数各位相加，看似需要将数据转换成十六进制、十二进制（输入的便是十进制），实则，只需一个进制转换求和函数就可以实现，不妨设转换为n进制，在转换的过程中便可实现求和，先对n求模，再整除n，最后判断和是否相等即可。 代码#include &lt;iostream&gt; using namespace std; int DBC(int a,int n) //将数字a转化为n进制，将其每位相加求和 { int sum=0; while(a) { sum += a%n; a /= n; } return sum; } int main() { int a,b,sum=0; while(cin &gt;&gt; a &amp;&amp; a!=0) { b=a; //个人认为，这里只要三者相等即可，不一定为22 if((DBC(b,10)==DBC(b,16)) &amp;&amp; (DBC(b,10)==DBC(b,12))) cout&lt;&lt; a &lt;&lt; &quot; is a Sky Number.&quot; &lt;&lt; endl; else cout&lt;&lt; a &lt;&lt; &quot; is not a Sky Number.&quot; &lt;&lt; endl; } return 0; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"}],"author":"Sinclair"},{"title":"欧几里得算法","slug":"2019-01-09-欧几里得算法","date":"2019-01-08T16:00:00.000Z","updated":"2020-01-21T12:21:42.999Z","comments":true,"path":"2019/01/09/2019-01-09-ou-ji-li-de-suan-fa/","link":"","permalink":"https://sinclaircoder.top/2019/01/09/2019-01-09-ou-ji-li-de-suan-fa/","excerpt":"欧几里得算法求最大公约数 Sometimes your whole life boils down to one insane move. 人这一辈子，有时就得靠一次疯狂的举动才能扭转乾坤。 —————————《阿凡达》 @[toc] 一、介绍欧几里得 &emsp;&emsp;像所有博客一样，出于尊重，介绍一下这位伟大的数学家欧几里得。 &emsp;&emsp;欧几里得，古希腊人，数学家，主要成就：数学巨著《几何原本》、欧几里得算法、完全数。 &emsp;&emsp;在柏拉图学派晚期导师普罗克洛斯（约410～485）的《几何学发展概要》中，就记载着这样一则故事，说的是数学在欧几里得的推动下，逐渐成为人们生活中的一个时髦话题(这与当今社会截然相反)，以至于当时亚里山大国王托勒密一世也想赶这一时髦，学点儿几何学。 &emsp;&emsp;虽然这位国王见多识广，但欧氏几何却令他学的很吃力。于是，他问欧几里得“学习几何学有没有什么捷径可走？”，欧几里得笑道：“抱歉，陛下!学习数学和学习一切科学一样，是没有什么捷径可走的。学习数学，人人都得独立思考，就像种庄稼一样，不耕耘是不会有收获的。在这一方面，国王和普通老百姓是一样的。” 从此,“在几何学里,没有专为国王铺设的大道。”这句话成为千古传诵的学习箴言。&emsp;&emsp;总之呢，任何事情都是这样，哪有这么多得捷径可走，天才往往都是天天积累成才。","text":"欧几里得算法求最大公约数 Sometimes your whole life boils down to one insane move. 人这一辈子，有时就得靠一次疯狂的举动才能扭转乾坤。 —————————《阿凡达》 @[toc] 一、介绍欧几里得 &emsp;&emsp;像所有博客一样，出于尊重，介绍一下这位伟大的数学家欧几里得。 &emsp;&emsp;欧几里得，古希腊人，数学家，主要成就：数学巨著《几何原本》、欧几里得算法、完全数。 &emsp;&emsp;在柏拉图学派晚期导师普罗克洛斯（约410～485）的《几何学发展概要》中，就记载着这样一则故事，说的是数学在欧几里得的推动下，逐渐成为人们生活中的一个时髦话题(这与当今社会截然相反)，以至于当时亚里山大国王托勒密一世也想赶这一时髦，学点儿几何学。 &emsp;&emsp;虽然这位国王见多识广，但欧氏几何却令他学的很吃力。于是，他问欧几里得“学习几何学有没有什么捷径可走？”，欧几里得笑道：“抱歉，陛下!学习数学和学习一切科学一样，是没有什么捷径可走的。学习数学，人人都得独立思考，就像种庄稼一样，不耕耘是不会有收获的。在这一方面，国王和普通老百姓是一样的。” 从此,“在几何学里,没有专为国王铺设的大道。”这句话成为千古传诵的学习箴言。&emsp;&emsp;总之呢，任何事情都是这样，哪有这么多得捷径可走，天才往往都是天天积累成才。 二、实现思路 定义2.1：设m和n是两个不全为0的整数，称m与n的公因子中最大的为m与n的最大公因子，或最大公约数(greatest common divisor)，记作gcd(m,n)定义2.2：设m和n是两个非零整数，称a与b最小的公倍数为m与n的最小公倍数(least common multiple)，记作lcm(m,n) 欧几里得算法又称辗转相除法 s：设两个正整数m，n且m &gt; n ; s1：令r=m%n（%代表取余）； s2：若r=0(即n整除m)运算结束，n为结果 ； s3：否则令m=n，n=r并返回s1 ； 三、核心思想gcd(m,n)=gcd(n,mod(m,n) lcm(m,n) = ab/gcd(m,n) 证明：不妨设 m=k1d ,n=k2d , k3 = m/n (整除) 则 r=m-k3n=k1d-k2k3d=(k1- k2k3)d故r也是d的倍数，得证$\\it gcd (m,n)=gcd(n,mod(m,n)$ 四、优点 一看相比于穷举法，效率也会高很多 五、核心代码 int gcd(int m,int n) { int t,r; if(m&lt;n) swap(m,n); //交换二者的值 while(n!=0) { r=m%n; m=n; n=r; } return n; } int gcd(int m,int n) // 递归做法 { if(m&lt;n) swap(m,n); //交换二者的值 if(n==0) return m; return gcd(n,m%n); } int lcm(int gcd,int m,int n) { return m*n/gcd; } 参考来源：人物简介源自百度百科 在CSDN上的第一篇文章，２０１９加油！","categories":[{"name":"数论","slug":"数论","permalink":"https://sinclaircoder.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sinclaircoder.top/tags/数论/"}],"author":"Sinclair"},{"title":"HDU2099整除的尾数","slug":"2019-01-09-HDU2099整除的尾数","date":"2019-01-08T16:00:00.000Z","updated":"2020-01-21T12:46:04.003Z","comments":true,"path":"2019/01/09/2019-01-09-hdu2099-zheng-chu-de-wei-shu/","link":"","permalink":"https://sinclaircoder.top/2019/01/09/2019-01-09-hdu2099-zheng-chu-de-wei-shu/","excerpt":"整除的尾数 You have to live spherically - in many directions.Never lose your childish enthusiasm and things will come your way.人要活得精彩，各个领域都要勇于尝试，永远保持童真般的热情，一切就会得偿所愿。 ——《托斯卡尼艳阳下》 Problem Description 一个整数，只知道前几位，不知道末二位，被另一个整数除尽了，那么该数的末二位该是什么呢？ Input 输入数据有若干组，每组数据包含二个整数a，b（0&lt;a&lt;10000, 10&lt;b&lt;100），若遇到0 0则处理结束。 Output 对应每组数据，将满足条件的所有尾数在一行内输出，格式见样本输出。同组数据的输出，其每个尾数之间空一格，行末没有空格。","text":"整除的尾数 You have to live spherically - in many directions.Never lose your childish enthusiasm and things will come your way.人要活得精彩，各个领域都要勇于尝试，永远保持童真般的热情，一切就会得偿所愿。 ——《托斯卡尼艳阳下》 Problem Description 一个整数，只知道前几位，不知道末二位，被另一个整数除尽了，那么该数的末二位该是什么呢？ Input 输入数据有若干组，每组数据包含二个整数a，b（0&lt;a&lt;10000, 10&lt;b&lt;100），若遇到0 0则处理结束。 Output 对应每组数据，将满足条件的所有尾数在一行内输出，格式见样本输出。同组数据的输出，其每个尾数之间空一格，行末没有空格。 Sample Input 200 401992 950 0 Sample Output 00 40 8015 一、思路 输入要判断是否为0，先将这个整数乘以100，然后利用0到99的穷举进行判断，输出时考虑到0的问题，用printf函数输出。 二、代码实现#include &lt;iostream&gt; using namespace std; int main() { int a,b,count=0; while(cin&gt;&gt; a &gt;&gt; b &amp;&amp; a!=0 &amp;&amp; b!=0) { a *= 100; for(int i=0;i&lt;=99;i++) { if((a+i)%b == 0) { count++; // 计数，用于空格的输出 if(count==1) printf(&quot;%02d&quot;,i); //输出空格的问题 else printf(&quot; %02d&quot;,i); } } cout &lt;&lt; endl; count=0; //每一组整数的后两位判断完毕之后，count需清零，然后输出换行 } return 0; }","categories":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/categories/数据结构与算法训练/"}],"tags":[{"name":"数据结构与算法训练","slug":"数据结构与算法训练","permalink":"https://sinclaircoder.top/tags/数据结构与算法训练/"}],"author":"Sinclair"}]}