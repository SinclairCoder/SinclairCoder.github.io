<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[裴蜀定理&&扩展欧几里得算法]]></title>
    <url>%2F2019%2F10%2F22%2F2019-10-22-pei-shu-ding-li-kuo-zhan-ou-ji-li-de-suan-fa%2F</url>
    <content type="text"><![CDATA[裴蜀定理也就是Bezout定理，对于任意整数a,b，存在一对整数x,y，满足$ax+by=gcd(a,b)$。在数论中，裴蜀定理是一个关于最大公约数（或最大公约式）的定理，裴蜀定理得名于法国数学家艾蒂安·裴蜀。裴蜀定理说明了对任何整数 a、b和它们的最大公约数 d ，关于未知数 x 和 y 的线性丢番图方程（称为裴蜀等式）。 证明： 若b=0时，此时迭代到算法的最后一步，显然存在一对整数，$x=1,y=0$ ，使得a*1+0*0 = gcd(a,0) 若b&gt;0时，则 $gcd(a,b) = gcd(b,a\,mod\,b)$ ，假设存在一对整数 $x_1,y_1$ ，满足 b*x_1+(a\,mod\,b)*y_1 = gcd(b,a\,mod\,b) ，因为 b*x_1+(a\,mod\,b)*{y_1}= b*x_1+(a-a/b*b)y_1= a*y_1 +b*(x_1-(a/b)*y_1) 证毕 裴蜀定理是按照欧几里得算法的思路被证明的，并且同时给出了整数x和y的计算方法。这种计算方法被称为扩展欧几里得算法。 联立一下 \begin{cases} gcd=a*x+b*y \\ gcd = a*y_1 + b*(x_1-(a/b)*y_1) \end{cases}可以得出 \begin{cases} x=y_1 \\ y = x_1-(a/b)*y_1 \end{cases}实现int exgcd(int a,int b,int &x,int &y){ if(b==0){ x = 1,y = 0; return a; } int ans = exgcd(b,a%b,x,y); int z = y; y = x - (a/b)*z,x = z; return ans; } 说明上述程序求出的是一组特解$x_0,y_0$，并返回a,b的最大公约数d。 未完，待续…]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马小定理]]></title>
    <url>%2F2019%2F10%2F22%2F2019-10-22-fei-ma-xiao-ding-li%2F</url>
    <content type="text"><![CDATA[若p是质数，则对于任意整数a，有$a^p \equiv a (mod \, p)$]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计字符]]></title>
    <url>%2F2019%2F10%2F21%2F2019-10-21-tong-ji-zi-fu%2F</url>
    <content type="text"><![CDATA[输入一行字符，分别统计出其中英文字母、空格、数字和其他字符的个数。 #include using namespace std; typedef long long ll; const int maxn = 2e5; # define mod(a,b) (a)%(b) int main(){ char ch; int count[4]={0}; while(cin.get(ch)){ if(ch>='a'&&ch='A'&&ch='0'&&ch]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeWeeklyContest-159]]></title>
    <url>%2F2019%2F10%2F21%2F2019-10-21-leetcodeweeklycontest-159%2F</url>
    <content type="text"><![CDATA[最近看了篇文章，文章里说 希望你身边能有个比你聪明五倍，但却比你还努力十倍的人。倍数虽然有些夸张，但是这个思想还是能get到的。 5230. 缀点成线在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。 请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。 思路根据前两个点构造直线，看后续的点是否在直线上。直线方程为 $ax+by+c=0$，其中：$a=y_2-y_1$ $b=x_1-x_2$ $c=-ax_1-by_1$好处是不用考虑斜率，这是个方程的一般式。如果考虑斜率，还得分斜率是否为0。 实现class Solution { public: bool checkStraightLine(vector& coordinates) { vector v1,v2,v3; v1 = coordinates[0]; v2 = coordinates[1]; int a = v2[1]-v1[1]; int b = v1[0]-v2[0]; int c = -1*a*v1[0]-b*v1[1]; for(int i=1;i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共子序列(LongestCommonSubsequence)]]></title>
    <url>%2F2019%2F10%2F17%2F2019-10-17-zui-chang-gong-gong-zi-xu-lie-longestcommonsubsequence%2F</url>
    <content type="text"><![CDATA[问题描述求两个长度分别为m和n的字符串A、B的最长公共子序列。A：a0a1a2…am-1B：b0b1b2…bn-1 思路构造一个大小为(m+1)*(n+1)的二维数组dpdp[i][j] 表示a0a1a2…ai-1 和 b0b1b2…bj-1 两个字符串的最大公共子序列 状态转移方程dp[i][j]= \begin{cases}0 & \text {if i=0 or j=0} \\ dp[i-1][j-1]+1 & \text{if a[i-1]=b[j-1] } \\ max(dp[i-1][j],dp[i][j-1]) &\text{if a[i-1]!=b[j-1]}\end{cases}实现int dp[MAXN][MAXN]={0}; vector subs; vector longestCommonSubsequence(string s1, string s2) { memset(dp,0,sizeof(dp)); int m = s1.length(),n = s2.length(); for(int i=1;i]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>最长公共子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeWeeklyContest-157]]></title>
    <url>%2F2019%2F10%2F13%2F2019-10-13-leetcodeweeklycontest-158%2F</url>
    <content type="text"><![CDATA[戒骄戒躁，勇往直前。 传送门：第 158 场周赛分割平衡字符串在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。返回可以通过分割得到的平衡字符串的最大数量。输入：s = “RLRRLLRLRL”输出：4解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。 思路用两个数组记录当前出现的R和L的次数，进行比对相等则cnt+1。 实现class Solution { public: int balancedStringSplit(string s) { int n = s.length(),cnt=0; int rcnt[n]={0},lcnt[n]={0}; for(int i=0;i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeWeeklyContest-157]]></title>
    <url>%2F2019%2F10%2F07%2F2019-10-7-leetcodeweeklycontest-157%2F</url>
    <content type="text"><![CDATA[秋意寂寥，国庆假期归来，”百废待兴”。路漫漫其修远兮，吾将上下而求索。 题目传送玩筹码数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：将第 i 个筹码向左或者右移动 2 个单位，代价为 0。将第 i 个筹码向左或者右移动 1 个单位，代价为 1。最开始的时候，同一位置上也可能放着两个或者更多的筹码。返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。 思路做的时候看了半天，不会写，后来发现题目理解错了，chips上存放的是筹码的位置，偶数位置跳到偶数位置代价为0，偶数位置跳到奇数位置代价为1，奇数位置跳到奇数位置代价为0，奇数位置跳到偶数位置代价为1，假设奇数位置的筹码数量为 evenN，偶数位置的筹码数量为 oldN，最小代价即为 min(evenN,oldN) 实现int minCostToMoveChips(vector& chips) { int even=0,odd=0; for(int &i:chips){ if(i%2==0) odd++; else even++; } return min(even,odd); } 最长定差子序列给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。举个栗子输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2输出：4解释：最长的等差子序列是 [7,5,3,1]。 思路经典dp问题，不过我的dp确实不熟。首先打个表dp，用arr[i]作为dp的索引，dp[j]表示到j为止存在的等差子序列长度的最大值。状态转移方程如下：dp[arr[i]] = dp[arr[i]-d] + 1 实现int longestSubsequence(vector& arr, int difference) { map dp; int ans=0; for(int i:arr){ dp[i] = dp[i-difference] + 1; ans = max(dp[i],ans); } return ans; } 没有冗长的代码，真的爱上了这种感觉，写起来真的既轻松又愉快。 黄金矿工你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。为了使收益最大化，矿工需要按以下规则来开采黄金：每当矿工进入一个单元，就会收集该单元格中的所有黄金。矿工每次可以从当前位置向上下左右四个方向走。每个单元格只能被开采（进入）一次。不得开采（进入）黄金数目为 0 的单元格。矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。 思路DFS，其实这里面还是有很多问题要注意一下的，比如dfs函数里的参数tmp不能传引用，而value、visit要传引用，tmp是每次的中间值，每次与value进行比较，用两者的最大值去更新value。另外，leetcode支持c++11，故此代码里用了很多新特性，比如类的属性定义时初始化，vector初始化等，如果要在Dev上跑的话，在文件首部加上下面这一行： #pragma GCC diagnostic error "-std=c++11" 实现class Solution { public: int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0}; void dfs(vector& grid, int x, int y, int tmp, int& value, vector& visit){ // tmp 不能加引用 if(grid[x][y]==0) return ; value = max(value,tmp += grid[x][y]); visit[x][y] = true; for(int i=0;i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Python数据分析与应用》复现笔记]]></title>
    <url>%2F2019%2F10%2F04%2F2019-10-4-python-shu-ju-fen-xi-yu-ying-yong-fu-xian-bi-ji%2F</url>
    <content type="text"><![CDATA[Numpy arr.ravel() 完成数组的展开工作 arr.flatten() 展平数组，可以选择横向（’A’）或者纵向（’F’）展开 np.hstack() 横向组合 np.vstack() 纵向组合 np.concatenate() 通过调参数axis来实现横向或者纵向组合，axis=1 为横向组合，axis=0为纵向组合 np.hsplit() 横向分割 np.vsplit() 纵向分割 np.split() 通过调参数axis来实现横向或者纵向分割，axis=1 为横向分割，axis=0为纵向分割 np.multiply(mat1,mat2) 两个矩阵点乘 mat1.T 矩阵的转置矩阵 mat1.H 共轭转置 mat1.I 矩阵的逆 mat1.A 返回自身数据的二维数组的一个视图 np.save() 以二进制格式保存数据 np.load() 从二进制的文件中读取数据 注：存储的时候可以省略扩展名，但读取的时候 np.savetxt(fname,data,fmt=”%.18e”,delimiter=’’”,newline=’\n’,header=’’,footer=’’,comments=’#’) 将数组写到某种分隔符隔开的文本文件中 np.loadtxt(fname,data,delimiter=’’”）把一个文件加载到一个二维数组中 np.genfromtxt(fname,delimiter=””,names) 和loadtxt很相似，它面向的是结构化数组和缺失的数据 np.sort() 最常用的排序函数 arr.sort(axis=1) 沿横轴排序 arr.sort(axis=0) 沿纵轴排序 arr.argsort() 给定一个或多个键时，得到一个由整数构成的索引数组，索引值表示数据在新序列中的位置 arr.lexsort() 一次性对满足多个键的数组执行间接排序，与argsort()相似，返回索引数组 np.unique() 找出数组中的唯一值并返回已排序的结果 sorted() 可以对所有可迭代的对象进行排序操作 list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作 np.tile(A,reps) 将数组A重复reps次 np.repeat(a,repeats,axis) 将数组a 沿着特定的 轴进行重复 tile函数是对数组进行重复操作，而repeat函数对数组中的每个元素进行重复操作 np.cumsum() 计算数组累计和 np.cumprod() 计算数组累计积 Pandas pd.read_sql_table(table_name,con) 只能读取数据库的一个表格，不能实现查询的操作 pd.read_sql_query(sql,con) 只能执行查询操作，不能直接读取数据库中的某个表 pd.read_sql(sql,con) 既能读取数据库中的某一个表，也能够执行查询操作 DataFrame.to_sql(table_name,con) 将DataFrame写入数据库，同样也要依赖SQLAlchemy库的create_engine函数创建数据库连接 pd.read_csv(filepath,sep) 读取CSV文件 pd.read_table(filepath,sep) 读取文本文件 DataFrame.to_csv(path_or_buf) 对于结构化数据，可以通过pandas中的to_csv函数实现以CSV文件格式存储 pd.read_excel(filepath,sep) 读取文本文件 DataFrame.to_excel(excel_writer) 将文件存储为Excel文件 DataFrame.loc[行索引名称，列索引名称] 切片 包括最后索引 DataFrame.iloc[行索引位置，列索引位置] 切片 不包括最后索引 DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True，group_keys=True，squeeze=False) 能够根据索引或者字段对数据进行分组，by用于确定进行分组的依据，axis默认为0，默认对列进行操作，level表示标签所在的级别，as_index 表示聚合标签是否以DataFrame索引形式输出，sort是否对分组进行排序，group_keys是否显示分组标签的名称，squeeze表示是否允许对返回数据进行降维。 DataFrame.agg(func,axis=0) DataFrame.aggregate(func,axis=0) agg函数和aggregate函数都支持对每个分组应用某个函数（包括内置函数和自定义函数），这两个方法也能直接对DataFrame进行函数应用操作。 DataFrame.apply(func，axis=0) 能将函数应用于每一列，但是无法像agg一样能够对不同字段应用不同函数来获取不同结果。 DataFrame.transform(func) 能够对整个DataFrame的所有元素进行操作 pd.pivot_table(data,values=None,index=Nobe,columns=None,aggfunc=’mean’) 实现透视表，data表示创建表的数据，values用于指定要聚合的数据字段名，index表示行分组键，columns表示列分组键，aggfunc表示聚合函数 pd.crosstab(index,columns,values) 创建交叉表，主要用于计算分组频率，crosstab函数中的index，columns、values都是从DataFrame中取出的某一列]]></content>
      <categories>
        <category>数据分析</category>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeWeeklyContest-156]]></title>
    <url>%2F2019%2F10%2F02%2F2019-10-2-leetcodeweeklycontest-156%2F</url>
    <content type="text"><![CDATA[题目传送写题解就像写博客一样真的有好处，尽管会多花点时间。 1 、独一无二的出现次数描述给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 思路统计出现次数，然后排序。有相同的为false，否则为true。 实现 bool uniqueOccurrences(vector& arr) { int a[2001]={0}; for(int i=0;i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改Jupyter Notebook的默认存储路径]]></title>
    <url>%2F2019%2F10%2F02%2F2019-10-2-xiu-gai-jupyter-notebook-de-mo-ren-cun-chu-lu-jing%2F</url>
    <content type="text"><![CDATA[最近在复现数据分析，发现JupyterNotebook默认存储路径在C盘 /user/.jupyter里面想改一下默认存储路径。 step1进入Anaconda安装路径，一般来说都是 */Anaconda3/Scripts，比如我的就是在 E:\Python\Anaconda\INSTALL\Scripts这个路径下，在cmd中将路径转到该路径下，这样替换代码如下，其中路径替换成自己的。 >> cd E:\Python\Anaconda\INSTALL\Scripts >> e: step2在cmd中输入命令： jupyter notebook --generate-config 然后就会在C盘用户路径（例如我的路径是：C:\Users\三寸旧城七寸执念\.jupyter）下生成jupyter_notebook_config.py文件，使用文本编辑器（VS Code等）打开该文件。 step3定位到第246行 #c.NotebookApp.notebook_dir = '' 替换为 c.NotebookApp.notebook_dir = 'E:/CodeCache/JupyterNotebook' step4右击JupyterNotebook的快捷方式点击属性，将目标那一栏里的%USERPROFILE%删掉，应该就可以了。 重启Jupyter Notebook。 另外，需要给Jupyter NoteBook 换主题，换字体，字号，以及代码自动补全可参考使用 Jupyter Themes 修改 Jupyter Notebook 的主题、字体、字号Jupyter Notebook 更换主题、设置字体(jupyterthemes的使用)、代码自动补全、变更工作目录（默认目录） 其实个人觉得貌似也没有好看的字体，传说中的Consolas字体貌似也不支持，主题换来换去其实还不如最初的默认的。其实个人觉得比较有用的还是代码补全。另外，需要注意里面的命令行是在 Anaconda Prompt输入的，而非cmd。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>JupyterNotebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式(一)]]></title>
    <url>%2F2019%2F09%2F24%2F2019-09-24-she-ji-mo-shi-yi%2F</url>
    <content type="text"><![CDATA[简介 软件模式 软件开发中的重复出现的问题的解决方案，可认为是设计经验，在讨论问题的解决方案时，一种可交流的词汇 设计模式 简言之，就是可重复使用的设计经验，主要还是为了达到优化设计的目的 软件开发中的几个模式 业务领域模式 分析模式 设计模式 Idioms模式 记录设计模式的四个要素 名称 问题 方案 效果 设计模式的起源 软件领域的设计模式起源于建筑学 建筑大师Alexander出版了《A pattern Language：Towns，Building，Construction》一书，将建筑领域的许多问题的最佳解决方案记录为200多种模式，其著作的思想不仅在建筑行业影响深远，很快影响到了软件设计领域 目前，被公认的在设计模式最有影响力的著作Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides的著作《Design Pattern：Elements of Reusable Object-Orient Software》(《设计模式：可复用的面向对象软件的基本原理》)，讲述了23个设计模式，四位作者的著作成为空前畅销书，被大众戏称GOF之书，学习设计模式必读著作 框架与设计模式的区别 层次不同 模式比框架更抽象，框架不是一种可重用的设计方案，是为解决某种问题的一些类的集合 范围不同 模式本质上是逻辑概念，框架是以具体的软件组织存在的 相互关系 一个框架会包含多个设计模式，一个著名的框架往往是许多设计模式的具体体现 面向对象的几个基本原则 面向抽象原则 抽象类 可以有抽象方法也可以有非抽象方法 不能用new运算符创建对象 子类必须重写父类的abstract方法 可作为上转型对象 接口 接口中只能有public权限的abstract的方法，能不能有abstract方法 接口由类来实现，必须重写接口中的abstract方法 接口回调 可以把实现接口的类的对象的引用赋给该接口声明的接口变量中，那么该接口变量就可以调用被类实现的接口中的方法 // Com.java public interface Com{ public abstract int sub(int x,int y); } // ComImp.java class ComImp implements Com{ public int sub(int x,int y){ return x-y; } } // Application.java public class Application{ public static void main(String args[]){ Com com; com = new ComImp(); int m = com.sub(8,2); system.out.println(m); } } 所谓面向抽象编程，是指设计一个类的时候，不让该类面向具体的类，而是面向抽象类或接口，即所设计类中的重要数据是抽象类或接口声明的变量，而不是具体类声明的变量 举个例子，计算一个柱体的体积。 // Geometry.java public abstract class Geometry { public abstract double getArea(); } // Pillar.java public class Pillar { private Geometry bottom; // 抽象类 private double height; Pillar(Geometry bottom,double height){ this.bottom = bottom; this.height = height; } public double getVolume(){ return bottom.getArea()*height; // bottom可以调用子类重写的getArea方法 } } // Circle.java public class Circle extends Geometry { private double r; Circle(double r){ this.r = r; } @Override public double getArea() { return Math.PI*r*r; } } // Rectangle.java public class Rectangle extends Geometry { private double a,b; public Rectangle(double a, double b) { this.a = a; this.b = b; } @Override public double getArea() { return a*b; } } // Application.java public class Application { public static void main(String[] args) { Pillar pillar; Geometry bottom; bottom = new Rectangle(12,22); pillar = new Pillar(bottom,58); System.out.println("矩形底的体积为："+pillar.getVolume()); bottom = new Circle(10); pillar = new Pillar(bottom,58); System.out.println("圆形底的体积为："+pillar.getVolume()); } } 开-闭原则 设计对扩展开放，对修改关闭,实际上这句话的本质是指当一个设计中增加新的模块时不需要修改现有模块。 多用组合少用继承原则 继承与复用 通过继承，子类与父类的关系是强耦合关系，即父类方法的行为更改时，必然导致子类发生变化 通过继承的复用也称为“白盒复用”，其缺点是父类的内部细节对于子类而言是可见的 组合与复用 也即“Has-A”,一个对象是由几个对象组合而成 组合对象来复用的方法称为“黑盒”复用 对象与所包含的对象属于弱耦合关系 可以在运行时，动态指定所包含的对象 高内聚-低耦合原则 如果类中的方法是一组相关的行为，则称该类是高内聚的，反之，则称是低内聚 所谓低耦合就是不要让一个类包含太多其他的类的实例引用，以避免修改一部分会影响到另一部分]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蛮力法求解幂集问题]]></title>
    <url>%2F2019%2F09%2F23%2F2019-09-23-man-li-fa-qiu-jie-mi-ji-wen-ti%2F</url>
    <content type="text"><![CDATA[问题描述对于给定的正整数n(n&gt;=1),求1到n构成的集合的幂集（包括全集和空集） 解法一 直接枚举法思路将二进制位与幂集对应起来，n的幂集个数为$2^n$，每一个二进制位代表一个元素。下面以n等于3为例。 集合元素 对应的二进制位 对应的十进制数 { } 000 - {1} 001 1 {2} 010 2 {1，2} 011 3 {3} 100 4 {1，3} 101 5 {2，3} 110 6 {1，2，3} 111 7 算法复杂度: $O(n*2^n)$ 实现#include using namespace std; /* Alogorithm Design 蛮力法 1.直接枚举法求解幂集问题 */ // 将b表示的二进制加1 // b数组下表从小到大对应从低到高位 int inc(int b[],int n){ for(int i=0;i]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>幂集问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCodeWeeklyContest-155]]></title>
    <url>%2F2019%2F09%2F22%2F2019-09-22-leetcodeweeklycontest-155%2F</url>
    <content type="text"><![CDATA[操千曲而晓声,观千剑而后识器 —— 《文心雕龙》 力扣的周赛自闭了，好久没写了，丢掉的改捡了。 题目传送个人博客同步更新 Problem1 最小绝对差 难度：Easy题目 给你个整数数组 arr，其中每个元素都 不相同。请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 思路 遍历，边找边push，只需一遍 貌似代码写复杂了 题解#include using namespace std; /* LeetCode WeeklyContest-155 */ vector minimumAbsDifference(vector& arr) { sort(arr.begin(),arr.end()); int n=arr.size(); vector result; int min = arr[1]-arr[0]; vector tmp; for(int i=0;i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联想Y7000装Ubuntu双系统路上的坑]]></title>
    <url>%2F2019%2F09%2F22%2F2019-09-22-lian-xiang-y7000-zhuang-ubuntu-shuang-xi-tong-lu-shang-de-keng%2F</url>
    <content type="text"><![CDATA[三言两语道不尽心酸，一句两句说不尽心酸一个Ubuntu装了2天，装的无比心酸一直报ACPI错误，后来加上nomodeset才搞定后来专门搜了一下联想Y7000装Ubuntu的教程才知道这是联想显卡的问题。而且最好装Ubuntu 16.04.5 下面是一些参考文章：关于在联想Y7000上安装ubuntu和win10双系统的卡死坑 y7000安装ubuntu和一些小tips ubuntu 添加中文拼音输入法 Ubuntu16.04系统查看已安装的python版本，及其配置 其实装上Ubuntu之后，还有很多事情要做，很多环境要配，显卡要修改，就不一一列出了，主要是前面进入开机界面太艰难了，写篇博客记录下。 2019年9月30日更新 windows休眠，没有彻底关闭Ubuntu 无法访问windows下的磁盘的解决方法Ubuntu系统打不开windows磁盘文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学建模集训知识大纲]]></title>
    <url>%2F2019%2F09%2F16%2F2019-09-16-shu-xue-jian-mo-ji-xun-zhi-shi-da-gang%2F</url>
    <content type="text"><![CDATA[评价算法简单加权法 线性加权 非线性加权 逼近于理想解的排序法(TOPSIS算法)层次分析法主成分分析法模糊综合评价法聚类分析法秩和比法人工神经网络熵权法灰色关联度分析预测算法插值拟合 小样本内部预测 回归模型预测 大样本内部预测 灰色预测GM 小样本未来预测 时间序列 大样本的随机因素或周期特征的未来预测 神经网络 针对大样本的内部机理复杂的数据的未来预测 统计分析方差分析 分析因变量的总误差中，除开随机误差以外，是否有类别变量（自变量）造成的处理误差，有多少误差是自变量造成的 分类 单自变量 单因素方差分析 两个自变量 无重复双因素分析：只考虑主效应，不考虑交互效应 可重复双因素分析：考虑主效应，也考虑交互效应 回归分析多元统计分析 分类 聚类分析 判别分析 综合评价 主成分分析 从原来的坐标系转换到新的坐标系，第一个新坐标轴选择的是原始数据中方差最大的方向，第二个坐标轴选择的是和第一个新坐标轴正交且具有最大方差的方向。该过程一直重复，重复次数为原始数据中特征的数目。 因子分析 隐变量和某些噪声的组合 典型相关分析 偏最小二乘回归 分类问题 神经网络 逻辑回归 判别分析 最邻近方法 朴素贝叶斯 支持向量机 决策树 集成学习 ROC曲线 假设检验（非参数） 分布拟合检验 秩和检验 如果两个样本来自两个独立的但非正态或形态不清的两总体，要检验两样本之间的差异是否显著，不应运用参数检验中的t检验，而需要采用之和检验 配对检验 K-S 检验 K-S检验不仅能够检验单个总体是否服从某一理论分布，还能够检验两总体分布是否存在显著差异。其原假设是：两组独立样本来自的两总体的分布无显著差异。 Q-Q图 用变量数据分布的分位数与所指定分布的分位数之间的关系曲线来进行检验的 P-P图 根据变量的累积比例与指定分布的累积比例之间的关系所绘制的图形。通过P-P图可以检验数据是否符合指定的分布。当数据符合指定分布时，P-P图中各点近似呈一条直线。 聚类 层次聚类 划分聚类 K-means 网络聚类 聚类评价 共表型相关系数 相似性矩阵 共表矩阵 外部指标 相仪表 调整兰德系数ARI 互信息MI 自助 最优化方法常用算法 模拟退火 神经网络 遗传算法 无约束优化 基本算法 共轭梯度法 在最优化方法中占有重要地位，最速下降法的优点是工作量小，缺点是收敛慢，适用于寻优过程中前期迭代或作为间插步骤，当接近极值点时，宜选用别种收敛快的算法 牛顿法 如果f是对称正定矩阵A的二次函数，用牛顿法经过一次迭代就可到达最优点，如不是二次函数，则牛顿法不能一部达到极值点 牛顿法收敛速度虽然快，但要求Hessian矩阵可逆，要计算二阶导数和逆矩阵，就加大了计算机计算量和存储量。 拟牛顿法 修改了牛顿方向 两种算法 DFP BFGS 有约束优化 罚函数法 通过构造罚函数把约束问题转化为一系列无约束最优化问题，进而用无约束最优化方法求解，这类方法称为序列无约束最小化方法，简称SUMT法（分为SUMT外点法 其二为SUMT内点法） 近似规划法 二次规划 quadprog 一般有约束非线性规划 fmincon 计算机算法动态规划回溯搜索分治贪心分枝定界图论与网络欧拉图二分图 匈牙利算法 网络流 最小费用最大流 最短路径TSP问题 近似算法和启发式算法 二边逐次修正法 P和NP问题背包问题最小生成树 Prime算法 Kruskal算法 图的基本概念及其矩阵表示 无向图 有向图 完全图 二分图 图与网络的数据结构表示方法 邻接矩阵表示法 关联矩阵表示法 弧表表示法 邻接表表示法 星形表示法 常见的网络优化问题 最短路问题 公路连接问题 中国邮递员问题（欧拉图） 旅行商问题TSP（哈密顿图） 运输问题 图像处理基本概念 图像分类 离散图像 用一个数字序列表示的图像，0和1 连续图像 二维坐标系中具有连续变化的图像 矩阵中的元素称为像素，以256灰色等级的数字图像为例，一般由8位，即一个字节表示灰度值 灰度值量化为对应灰度等级 等间隔量化（一般采用这个） 非等间隔量化 数据类 数值数据类 double uint8 uint16 uint32 int8 int16 int32 single char 字符类（逻辑数据类） logical 图像类型 二值图像 二维矩阵由０、１构成，０为黑色，１为白色 通常用于OCR 一般二值图像是逻辑数组，只有０和１的uint8类数组，并不会认为是二值图像，需要使用logical函数 B= logical(A); 灰度图像 即人们常说的256灰度图像，0表示纯黑色，255表示纯白色 二值图像可以看成是灰度图像的一个特例 索引图像 有两个分量。即数据矩阵X和彩色映射矩阵map，矩阵map是一个大小为m*3且由范围在[0,1]之间的浮点值构成的double数组，map数组的长度同它所定义的颜色数目相等，map数组的每一行都定义单色的红绿蓝三个分量，X则是索引矩阵 真彩色RGB图像 是彩色像素的一个mn3数组，其中每一个彩色像素点，都是在特定空间位置的彩色图像相对应的红、绿、蓝三个分量 数据类之间转换 im2uint8 im2uint16 mat2gray：将输入转换为double，范围为[0,1] im2double im2bw 图像类型之间转换 ind2fray gray2ind rgb2ind ind2rgb ntec2rgb rgb2ntsc 使用imtool命令查看一个图像文件的信息 空间滤波器 线性滤波器 使用拉普拉斯滤波器增强图像 使用fspecial生成过滤器以及imfilter的使用 非线性滤波器 一个工具是ordfilt2函数，可以生成统计排序滤波器 g=ordfilt2(f,order,domain) ordfilt2函数生成图像g的方式：使用邻域的一组排序元素中的第order个元素来代替f中的每个元素，该淋雨则由domain中的非零元素指定 数字图像处理中最著名的统计排序滤波器是中值滤波器，对应第50个百分位，使用g=ordfilt2(f,median(1:m*n),ones(m,n));创建中值滤波器 工具箱提供了二维中值滤波函数g=medfilt2(f,[m,n]) 频域变换 为了有效的对图像进行处理和分析，需要将原定义的图像空间的图像以某种形式转换到频域空间，利用频域空间的特有性质方便的进行一定的加工，最后转换回图像空间 傅里叶变换 将图像从空域变换到频域 二维连续傅里叶变换 二维离散傅里叶变换（DFT） 基于离散傅里叶变换的频域滤波 离散余弦变换DCT 图像处理中常用的变换算法，通过DCT变换，可以将图像空间域上的信息变换到频率域上 两种实现 基于快速傅里叶变换FFT的算法，通过工具箱提供的dct2 另一种是DCT变换矩阵，工具箱提供了dctmtx函数来计算变换矩阵 图像保真和质量 图像处理中为了增加压缩率有时会放弃图像细节或者其他不太重要的内容，为了衡量解码图像相对于原始图像的偏离程度，这些测度一般称为保真度准则 主要准则 客观保真度准则 当所损失的信息量可用编码输入图与解码输出图的函数表示时，可以认为是基于客观保真度准则的 均方根误差 均方信噪比（SNR） 均方根误差越小，峰值信噪比越大，处理的图像质量越好 主观保真度准则 用分数代表主观评价{很差，较差，相同，稍好，较好，很好} 数字图像的水印防伪 内嵌水印的特点 透明性 鲁棒性 能够承受施加于图像的变换操作，不会因变换处理而丢失 安全性 空间域水印 将水印信息嵌入到载体图像的空间域特性上 频率域水印 将水印信息嵌入到载体图像的变换域系数等特征上 基于矩阵奇异值分解的数字水印算法 奇异值分解定理 Weyl定理 在原矩阵上加一个小小的扰动，看是否矩阵奇异值的变化是否会超过扰动矩阵的最大奇异值，从而判断稳定性 水印嵌入 水印提取 嵌入的逆过程 基于DCT变换的水印算法 DCT变换是实数域变换，对实系数处理更加方便，不会使相位信息发生变化，另外，DCT变换是有损图像压缩JPEG的核心，基于DCT变换的图像水印将兼容JPEG图像压缩 水印嵌入算法 图像加密 图像隐藏 规划问题连续优化 线性规划 LP 非线性规划 NLP 二次规划 QP 离散优化 整数线性规划 整数非线性规划 纯整数规划 混合整数规划 一般整数规划 0-1整数规划 整数规划的特殊情形，要求线性规划模型中的决策变量只能取值为0和1 模拟和仿真模拟 拟合 非线性最小二乘法 Isqcurvefit Isqnonlin 拟合与统计回归 线性回归 非线性回归 [beta,t,J]=nlinfit(x,y,’model’,beta0) 常用解法：线性最小二乘法 a=polyfit(x,y,m) 插值 一维插值 拉格朗日插值 yy=lagrange(x,y,xx) 分段插值 yy=interp1(x , y ,xx , ‘method’) - 三次样条插值 - yy=spline(x,y,xx) 二维插值 最邻近插值 分片线性插值 双线性插值 仿真 动态仿真 连续系统仿真 时间步长法 离散系统仿真 事件步长法 静态仿真 蒙特卡罗方法 随机数产生 均匀随机数 其他方法 逆变换法 舍选法 近似抽样法 指数分布 泊松分布 标准正态分布 正态分布 二项分布 排队问题 可靠性问题 蒙特卡罗方法 元胞自动机 数值计算常微分方程数值解 微分方程解析解 u=dsolve(‘Du=1+u^2’,’t’) 欧拉方法 向前欧拉公式 向后欧拉公式 梯形公式 龙格—库塔方法 matlab求解 高阶微分方程转一阶常微分方程 刚性常微分方程与非刚性常微分方程 工具箱的使用统计工具箱拟合工具箱神经网络工具箱小波工具箱并行计算工具箱优化工具箱 一元函数极小值 fminbnd 无约束极小 fminunc 为无约束优化提供了大型优化和中型优化算法 为中型优化算法的搜索方向提供了4种算法，由options中的HessUpdate控制，默认为bfgs（拟牛顿法的DFP公式） 另外，还有dfp（拟牛顿法的DFP公式），还有steepdesc（最速下降法） 为中型优化算法的步长一维搜索提供了两种算法，由options中的参数LineSearchType控制，默认是quadcubic （缺省值，混合的二次和三次插值）另外还有cubicpoly（三次多项式插值） fminsearch 线性规划 linprog 二次规划 quadprog 约束极小 fmincon 达到目标问题 fgoalattain 极小极大问题 fminimax 全局优化工具箱]]></content>
      <categories>
        <category>竞赛感悟</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019数学建模赛后感悟：一次灵魂与肉体的交织&&一次参赛终身收益]]></title>
    <url>%2F2019%2F09%2F16%2F2019-09-16-2019-shu-xue-jian-mo-sai-hou-gan-wu-yi-ci-ling-hun-yu-rou-ti-de-jiao-zhi-yi-ci-can-sai-zhong-shen-shou-yi%2F</url>
    <content type="text"><![CDATA[一年一度的全国大学生数学建模比赛（CUMCM）已接近尾声… SinclairWang 个人博客同步更新，欢迎关注相信每个参赛者都会有自己的感悟一句恰如其分的描述：一次灵魂与肉体的交织。下面是自己的一点感悟与思考。 赛前 最初听说，大概是在一年前，决定参加比赛是在今年5月份，暑假有两个选择，要么参加8月份的建模集训，要么实验室打杂，综合考虑了一下，看到培训大纲上的东西，可能对日后专业方向走向有益，遂放弃了锻炼编码能力的时间，毅然决定参加去参加集训。 集训8月1日份开始，9月5日结束，9月12日比赛开始，9月15日比赛结束。 一个多月的集训，每天上午8点半到12点，可能下午还要加课，一个老师讲一个专题3天，理学院的老师轮流来，每人一个模块，每三天一个专题，智能计算、统计分析、数值计算、图与网络、模拟仿真、分类与聚类、组合优化、图像处理、历年赛题与优秀论文讲评。 老师们每天讲课，一个上午动辄上百页PPT，所以这一个月的日常就是上午上课，下午看老师讲的PPT、理解原理和复现程序。CUMCM涉及层面广而多，虽说深度欠缺，但是对于本科生来说，掌握这些知识，也是不易。 集训的过程，也曾想过放弃，不是畏难，而是有一段时间觉得自己做的可能没有自己想象中的有意义，正如本专业同学那句话 “或许当初没有选择数学建模，这一个月的时间，可能已经足够可以在专业上走的很远了…” 我也认同，可是大家还是选择坚持了下来，一直坚持到了最后。 一场集训下来，我也学到了很多东西，虽不知不觉，却也潜移默化，老师们讲的n个专题，不敢说全部掌握了，但可以说学了个大概，而且学的知识对日后专业方向走向极其有益，虽然理论深度掌握不够，但也相当于在自己的方向相关领域，在自己的学习进程上写了一句HelloWorld，其实集训之前本来想着老师们每讲一个专题，就跟着写一篇Blog，事实上，集训时每天的知识都消化不了，更不要说写博客了，这件事仔细想想，也并非完全不能做到，只是决心不够。虽然专题博客没跟上，但是将老师讲的专题总结成思维导图，形成数学建模集训的整个知识框架，这是不难做到的，思维导图是用xmind做的，用markdown文本导出，我放到了博客上，总结了一下建模期间的博客，不算这篇的话，还有一篇关于的图像处理的,当初看图像处理的时候觉得很有意思,就没忍住写了一篇。 数学建模集训知识大纲 基于奇异值分解的图像压缩 除此之外,我也从队友身上学到了很多,我们队人员组成是2计算机专业(一个SE，一个CS)+数学专业。我从队友身上看到了高效,其实一直很想写一篇关于效率与时间管理的文章,不过时间安排上没提上日程,一个人只有把效率提上去,才能做到自己想做的。之前知乎上有篇高赞文章,是讲*人是怎么废掉的,没想到其中有一条是瞎忙,除了没方向之外,更重要的是低效率,忙了一天不知道在忙什么,忙了点啥,就好比泡图书馆学习,一泡就是一天,到了晚上应该正确评估白天的效率如何,而不应该单纯陷在因为短暂的长时间学习而产生的自我感动上,只有走出了这个误区才能有所进步。经此,我也有了新的认知。另外,我也认识到了学习方式的不足,也有专业大环境的原因,认真专注听课反倒成为了一个大难题,另外,上课认真听课,下课才能用更少的时间去复习,节省出更多的时间去做自己想做的事情。 赛中 9月12日 进驻机房,晚上6点钟放题目,一开始略卡。下载到题目之后,A、B、C任选一题。读题： A题精确计算 有一定的专业知识背景，否则题意不好理解 B题 物理题目？果断放弃 C题 开放性题目 只有大概思路，具体思路没有 估计找数据会劝退一拨人 综合评估，我的答案是选C，队友讨论了一晚上A题，但是我给不出说服他们选C题的东西。没过多久，我找到了数据。但是模型没具体思路。晚上11点半回寝室休息 第二天一早队友们想选C题，其实我内心有点欣喜~然后就开始了建模…建模全靠队友，其中有个神奇的男人，中午小憩都能想到idea，上趟厕所模型都能被改进，回来说“我知道了…应该这样做…”。太神奇了…赛期说好的写论文的队友，最后却在编程，说好了写程序的队友，比赛的时候却开始写起了论文，只有我始终打杂，凭实力打杂。 “我要的折线图你画了没？” “我需要你画个直方图。” “决策树画好了没？” “给你说个思路，你看能实现吗？#$#%#^*@#” “数据处理好了吗？” “打点的图发我了没？” “附录整理好没？” “支撑材料打包了没？” 终于我成了全队无可替代的凭实力打杂的选手！ 到了最后一天，进度有点慢，14日晚上觉得得通宵了，一夜爆肝，那一晚仿佛大家都没回去，都在通宵做模型，计算，一双双熬红的双眼，其实熬夜或许不是最难的，最难的是建不出模，算不出来。那晚的月亮格外美，格外的圆。 那晚队友们几乎都没怎么睡，我凌晨5点撑不住了，睡到了7点多。 起来，洗把脸，下楼吃了东西，队友们赶进度顾不上了… 然后就开始了最刺激压力最大的一天 题目只做了一半，四问只做了两问，晚上8点就要截止了。 到了中午重新改思路，我编程计算，队友们将思路写到论文，完善前面的部分。 高压下编程或许是最考验编程能力的… 到了下午5点半初稿还没出来,还有很多格式要调整，公式要编辑…. 晚上7点40多交了初稿… 没过多久就到8点了，就剩下最后一次交的机会了… 终于能略微喘口气了 但是，还有一次机会，不能放弃 于是，接着完善，修改摘要，修改正文… 终于9点39分交上了这最后一次… 如释重负… 三个人都笑了… 欣喜若狂~ 这一天没吃饭，没水喝，压力大，睡眠不足 但是还是撑了下来，队内也没有发生矛盾，互相理解，合作愉快。 最后一起等到了10点，把参赛作品交了上去 然后离开了机房，嘴上都说着“我再也不想听到’数学建模‘这四个字”… 虽然数学建模门槛低，有人说这不是数学建模，是面向写作和美术的建模，最终看的是论文。但是我还是觉得我参加数学建模是一个无比正确的决定，无论结果如何，它教会了很多东西，我学了很多数学知识，也掌握了很多能力，比如快速学习的能力，随便甩给你个200多页PPT，两天内就能看完，让我更加专注，变得更加有毅力和耐心去学习，比赛教给我团队协作的重要性，一个人可以走的很快，但一群人能走的更远，你终究能走多远，可能不只是跟你自己有关系，还跟你身边的人有关系，别人会影响你，会改变你。我觉得或许自己跟顶尖名校的同龄人的差距或许不只是软硬件实力配置的差距，而是身边有没有一群这样的一群人：大家有着共同的想法，热衷眼前的事情，能全身心的投入，走在一起去实现这个想法的路上。这是我思考了很久得出的结论，也是从数学建模中收获的，尽管这有些难以置信。比赛的时候，我看到一群人通宵建模，尽管很累但都还在撑着，就像何凯文说的那样，“你有多久没有认真过了？”感悟喷涌，能写出来的寥寥数语总归显得苍白无力，只要经历过的全身心投入的人总归会懂得。 赛后好好休息了一下 还了借的参考书籍 今天周一，投入到了新的学习征程中，仿佛又是个崭新的开始。 哦，对了我还写了一篇参赛感悟，正如你所看到的… 后来 2019年9月25日更被抽中答辩，心中自是欣喜万分，同样，无形的压力扑面而来。 2019年9月28日更答辩结束，无论结果如何，石头落地了，尽人事，听天命，一切终于结束了。 准备答辩的过程中，听说了一句话叫做 一次参赛，终身收益 后来才知道这是建模组委会的口号，也越发觉得这句话真的很贴切，参赛经历和比赛的魅力或许已经远远超过了奖项本身了，无论是心智，还是毅力，还是个人能力，都得到了很好的锻炼，参赛期间高压下编程、高压下写作和高压下的团队合作对每个参赛选手都是一次很好的磨练。另外，我觉得答辩期间的压力也是不亚于竞赛期间的，压力反而更大，从准备到答辩结束，需要自己重新审视自己的作品，正确认识作品的缺点，勇于承认或许这才是最重要的。另外，参加一次省级甚至是国家级别的学术答辩，无论结果如何，这都是很好的锻炼。此时，一个累的打字都快打不动了的蒟蒻，还在拖着疲惫的身躯码着自己的切身体会，一般来说，能写出来的文字总归苍白无力。用两句话结个尾吧，给2019CUMCM画上个句号。星光不负赶路人，时光不负有心人。一次参赛，终身收益。]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>竞赛感悟</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于奇异值分解的图像压缩]]></title>
    <url>%2F2019%2F09%2F09%2F2019-09-09-ji-yu-qi-yi-zhi-fen-jie-de-tu-xiang-ya-suo%2F</url>
    <content type="text"><![CDATA[理论：矩阵的奇异值分解变换是一种正交变换，它可以将矩阵对角化定理：设A是一个秩为$r$的$m*n$矩阵,则存在正交矩阵$U$和$V$,使得 U^TAV= \begin{bmatrix} \Sigma & 0 \\ 0 & 0 \\ \end{bmatrix}其中$\Sigma=diag\{\sigma_1,\sigma_2,\sigma_3,….,\sigma_r\}$，这里$\sigma_1&gt;=\sigma_2&gt;=\sigma_3….&gt;=\sigma_r$，$\sigma_1^2….\sigma_r^2$是矩阵$A^TA$对应的特征值。称A=U \begin{bmatrix} \Sigma & 0 \\ 0 & 0 \\ \end{bmatrix}V^TA的奇异值分解，$\sigma_i(i=1,…r)$称为A的奇异值 根据自己的理解，压缩的思路就是先进行奇异值分解，将前k大个特征值保留下来，其余的变为0，然后进行逆变换，起到基本替代原来奇异值矩阵的作用，从而实现图像的压缩，压缩率也会随k的变化而变化，诚然，k越大，压缩率越小。 实现步骤： 读取RGB图像 将RGB图像变为灰度图像 奇异值分解 保留前k大个特征值 逆变换 计算压缩率 打印图像（保存） 修改k的值，重复以上步骤 实现：% 通过奇异值分解 进行图像压缩 clc;clear; I = imread('figure1.jpg'); % rgb图像为274KB [m,n,h] = size(I); % Igray = rgb2gray(I); % imwrite(Igray,'figure1grayByrgb2gray.png','png') % 灰度图像为993KB，文件变大了好几倍 % 参考别人的博客，手写将rgb图像变成灰度图像 for i=1:m for j=1:n Igray(i,j)=0.299*I(i,j,1)+0.587*I(i,j,2)+0.114*I(i,j,3); end end imwrite(Igray,'figure1grayBymyself.png','png') k = 20; Igray = double(Igray); [U,S,V] = svd(Igray); S = diag(S); % 变成列向量 Smax = max(S); Smin = min(S); S1 = S; S1(k:end)=0; %保留前ｋ个 % S1 = diag(S1); % 考虑不周到 if m>=n % 对于非方图形 S1 = [diag(S1);zeros(m-n,n)]; else S1 = [diag(S1),zeros(m,n-m)]; end g = U*S1*V'; % S1的奇异值分解 g = uint8(g); compressration = n^2/(k*(2*n+1)); subplot(1,2,1),imshow(mat2gray(Igray)),title('soure'); subplot(1,2,2),imshow(g),title(['k =',num2str(k),' compress ratio =',num2str(compressration)]); imwrite(g,'figure1Compress20.png','png') figure,plot(S,'.','Color','k'); % 画出奇异值对应的点 原RGB图像： 灰度图像 特征值分布 K=20时的压缩率 可以调节k的值得到不同的压缩率 参考博客：RGB图像转为灰度图像原理RGB转灰度的几种算法图像压缩（SVD方法）]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件体系结构笔记]]></title>
    <url>%2F2019%2F09%2F02%2F2019-09-02-ruan-jian-ti-xi-jie-gou-bi-ji%2F</url>
    <content type="text"><![CDATA[传说中的软件体系结构与设计模式课程中的软件体系结构部分就结束了，好短，6个学时，匆匆掠过，走马观花，根据老师讲的内容写了份笔记，日后慢慢补充… 概念 具有一定形式的结构化元素，即构件的集合 处理构件：处理函数 数据构件：存储数据 （JavaBean） 连接构件 软件设计过程中的一个层次 为软件系统提供了一个结构行为和属性的高级抽象 代码重用构件 语义完整、语法正确和有重用价值的单位软件，是重用过程中可以明确辨识的系统，结构上是语义的描述、通讯接口和实现代码的复合体 粒度 大概就是所容纳的逻辑，逻辑越多为粗粒度，逻辑越少为细粒度，逻辑多少是相对而言的。比方说，对用户暴露了太多细节相对来说就是细粒度的，例如提供Getter和Setter方法，相反，如果提供getData()和setData()方法，就可以认为是粗粒度 ”4+1“模型 逻辑视图 描述系统的功能需求，即系统提供给最终用户的服务 开发视图 描述软件模块的组织与管理，服务于软件编程人员 进程视图 侧重系统的运行特性，关注非功能的需求，服务于系统集成人员 物理视图 描述硬件配置，服务于系统工程人员 场景 用于刻画构件之间的相互关系 元模型 元模型是关于模型的模型 四层元模型 四层元模型是OMG组织指定的UML的语言体系结构 体系结构 信息层 information layer 由我们希望的数据组成，通常是一些用户数据 模型层 model layer 由元数据组成，元数据是描述信息层的数据 元模型层 metamodel layer 是为了描述模型层而定义的一种“抽象语言”，是对模型层的进一步抽象。 元元模型层 meta-metamodel layer 是为了描述元模型而定义的一种“抽象语言”。元元模型的定义要比元模型更加抽象、简洁。一个元元模型可以定义多个元模型，而每个元模型也可以与多个元元模型相关联。 经典体系结构风格 数据流风格：批处理序列；管道过滤器 管道／过滤器 在该体系结构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流，这里的构件被称为过滤器，而连接件称为管道 优点 具有良好的隐蔽性、高内聚、低耦合 缺点 通常导致进程成为批处理的结构 不适合处理交互应用 举例：UNIX下的Shell编程 调用／返回风格：主程序／子程序 面向对象风格：层次结构 分层系统 独立构件风格：进程通讯 事件系统 虚拟机风格：解释器，基于规则的系统 仓库系统：数据库系统 超文本系统 黑板系统 目前流行的体系结构 客户/服务器 Client/Server 任务分配 服务器 数据库安全性的要求 数据库访问并发性的控制 数据库的备份与恢复 客户端 用户与数据库交互的界面 向数据库提交用户请求，接收来自服务器的信息 业务逻辑处理 评价 优点 客户应用程序和服务器构件分别运行在不同的计算机上 缺点 软件维护和升级困难 三层C/S结构 结构 数据库服务器 应用服务器 客户端 优点 应用的各层可以并行开发 功能层有效的隔开了数据层和表示层，更安全 浏览器/服务器模式 Browser/Server 即上述三层C/S结构的一种实现，浏览器/Web服务器/服务器 优点：系统安装、修改、维护全在服务端解决 缺点：缺乏对动态页面的支持，系统扩展能力差，在数据查询等响应速度要远远低于C/S 公共对象请求代理结构 Common ObjectRequest Broker Architecture（CORBA） 由OMG组织制订的一种标准的面向对象应用程序体系规范。或者说 CORBA体系结构是对象管理组织（OMG）为解决分布式处理环境(DCE)中，硬件和软件系统的互连而提出的一种解决方案 异构结构 反射体系结构 功能 动态获取到类或对象的属性或函数，修改对象的行为 把应用程序分成两层：基础层（定义应用程序的逻辑）和元层 消息的截取 Open C++ 反射 Reflect 处理从元级转化到基本级 具体化 Reify 从基本级转化到元级 元对象协议 Meta object Protocol 软件框架 定义：在给定的问题领域范围内建立起可重用解决设计方案问题而相互访问协作的一组类的集合 类库与框架区别 行为相对于协议 类库是行为的结合，而框架除了是行为的集合，而且还是与支配行为的一组规则或协议 ‘’不是访问我们，而是我们访问你‘’ 这里出现了一个控制的翻转，框架调用开发者写的程序代码，而开发者的程序是要去调用类库来实现某种功能 实现相对于设计 类库重用实现，框架重用设计 几个重要概念 Frozen Spots 冷冻部分 框架本身 Hot Spots 热点 可变部分 Hooks 直译过来就是 钩子，即通常理解的回调函数]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F01%2F00%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归]]></title>
    <url>%2F2019%2F08%2F17%2F2019-08-17-ji-qi-xue-xi-zhi-xian-xing-hui-gui%2F</url>
    <content type="text"><![CDATA[简单的线性回归以某产品的温度和产率关系为例，其中产率(y)是温度(x)的函数。请构建模型预测产品产率。 温度 产率 100 45 110 51 120 54 130 61 140 66 150 70 160 74 170 78 180 85 190 89 首先，我们可以先把数据可视化，画个散点图出来。根据散点图可知，数据基本上都在一条直线上，我们可以用一条直线去拟合。 正规方程求解\theta=(X^TX)^{-1}X^TYfunction [ theta ] = linearReg( ) % 线性回归正规方程求解 % 用130、190作为测试集 train = 8; X = [1 100;1 110;1 120;1 140;1 150;1 160;1 170;1 180;] Y = [45; 51 ;54 ;66; 70; 74 ;78; 85]; A = inv(X'*X); theta = A*X'*Y; end 解得： \theta=\begin{pmatrix} -3.1507 \\ 0.4851 \end{pmatrix}散点图拟合情况如下： 看起来拟合效果还不错 梯度下降求解假设函数：h_\theta(x)=\theta_0+\theta_1x代价函数： J(\theta_0 ,\theta_1)= \frac{1} {2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2梯度下降：(同步更新) temp_0 = \theta_0- \alpha \frac{\partial} {\partial \theta_0}J(\theta_0 ,\theta_1)temp_1 = \theta_1- \alpha \frac{\partial} {\partial \theta_1}J(\theta_0 ,\theta_1)\theta_0 = temp_0\theta_1 = temp_1假设函数 function [ res ] = h_func(inputx,theta ) % 预测函数 res = theta(1)+theta(2)*inputx; end 代价函数 function [ jVal,gradient ] = costFunction2( theta ) % jVal 为 代价值 gradient为梯度 % cost function % 用130、190作为测试集 x = [100 110 120 140 150 160 170 180] y = [45 51 54 66 70 74 78 85]; m = size(x,1); % size(x) = [1 8] size(x,1) 表示获取x的行 hypothesis = h_func(x,theta); delta = hypothesis - y; % 预测误差 向量 jVal= sum(delta.^2); % 损失函数 gradient(1) = sum(delta)/m; gradient(2) = sum(delta.*x)/m; end 梯度下降 function [ optTheta,functionVal,exitFlag ] = Gradient_descent() % 梯度下降 % fminunc 非线性优化 % 找到min f(x) 的 x f(x)是一个返回值为标量的函数，x是一个向量或矩阵 % options 配置选项，'GradObj' 'on' 表示使用自定义的梯度下降函数，'MaxIter',1000 表示最大迭代次数 options = optimset('GradObj','on','MaxIter',1000); % 需要返回的参数， 需要初始化 initialTheta = zeros(2,1); [optTheta,functionVal,exitFlag] = fminunc(@costFunction2,initialTheta,options); end 运行结果： optTheta = \begin{pmatrix} -3.1507 \\0.4851 \end{pmatrix}functionVal = 6.1996可见利用正规方程和梯度下降求解出来的参数一样未完，待续…]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0/1背包入门]]></title>
    <url>%2F2019%2F08%2F12%2F2019-08-12-bei-bao-ru-men%2F</url>
    <content type="text"><![CDATA[问题描述有n个重量分别为w1 、 w2 、w3、w4···wn的物品，编号1~n，它们的价值为v1 、 v2 、v3、v4···vn。现有一容量为W的背包，求尽可能的把背包装满并使价值最大 下面不妨以ｎ＝４ Ｗ＝６为例 物品编号 重量 价值 1 5 4 2 3 4 3 2 3 4 1 1 蛮力法—求幂集搜索 思路大概是用蛮力法找出n的所有幂集,然后遍历一遍,找到最优解 复杂度为O(2n)```c includeincludeincludeincludeincludeusing namespace std;/* 求解简单0/1背包问题 2019-8-12 /vector]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
        <tag>动态规划</tag>
        <tag>0/1背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一线爬虫爬虫工程师纪实]]></title>
    <url>%2F2019%2F07%2F17%2F2019-07-17-yi-xian-pa-chong-gong-cheng-shi-ji-shi%2F</url>
    <content type="text"><![CDATA[最近遇到了反爬虫 在CSDN上逛到了一篇很不错的博文Java 那些你不知道的爬虫反爬虫套路 一篇一线爬虫工程师的纪实~ ==注：侵删==]]></content>
      <categories>
        <category>工程项目</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat 8080端口被占用]]></title>
    <url>%2F2019%2F07%2F14%2F2019-07-14-tomcat-8080-duan-kou-bei-zhan-yong%2F</url>
    <content type="text"><![CDATA[最近在学习Spring Boot ，新建项目运行的时候出现了Tomcat 8080端口被占用的问题描述如下： 解决方法1.管理员身份打开cmd窗口2.使用命令 netstat -ano 查看当前端口信息 3.找到对应端口PID ，输入指令找到对应进程杀掉 4.重新运行程序]]></content>
      <tags>
        <tag>Tomcat</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的prototype属性]]></title>
    <url>%2F2019%2F06%2F24%2F2019-06-24-javascript-de-prototype-shu-xing%2F</url>
    <content type="text"><![CDATA[今天写js代码的时候，看别的用prototype看的我云里雾里的，了解了一下： prototype 是函数的属性，它的本质是函数的原型对象 可以以此执行一下如下代码，体会一下。 var ob = { };//超级简单的空对象 alert(JSON.stringify(ob.prototype)); function func(){ } alert(func.prototype); function func(){ } alert(JSON.stringify(func.prototype)); function func(){ } func.prototype.name ='prototype是函数的的属性，本质是函数的原型对象'; alert(JSON.stringify(func.prototype)) function func(){ } //给函数的属性prototype赋予一个方法get func.prototype.get=function(value){ return value; } var ob1 = new func; //用func实例化出来的对象来调用get属性函数 alert(ob1.get('hello,prototype原型对象')); var ob2 = new func; //用func实例化出来的对象来调用get属性方法 alert(ob2.get('我依然是func实例化出来的对象')); 详情请见==&gt;简单理解js的prototype属性]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图-深度优先搜索的应用]]></title>
    <url>%2F2019%2F06%2F17%2F2019-06-17-shu-ju-jie-gou-tu-shen-du-you-xian-sou-suo-de-ying-yong%2F</url>
    <content type="text"><![CDATA[@[toc]之前还写过一篇关于DFS的题解入门学习文章，详情见DFS入门学习 深度优先搜索的应用头文件声明即图的基本运算，详情见数据结构-图-基本运算 #include"Graph.cpp" 顶点u到顶点v是否有简单路径 /* 顶点u到顶点v是否有简单路径，has表示是否存在 典型的DFS */ void ExistPath(AdjGraph *G,int u, int v, bool &has) { int w; ArcNode *p; visited[u] = 1; if(u == v) // 出口 { has = true; return ; } p = G->adjlist[u].firstarc; while(p!=NULL) { w = p->adjvex; if(visited[w] == 0) ExistPath(G,w,v,has); p = p->nextarc; } } 输出图G中从定点u到v的一条简单路径/* 输出图G中从定点u到v的一条简单路径 典型的DFS */ void FindPath(AdjGraph *G, int u, int v,int path[], int d) { // d 为路径长度 初始为-1 int w; ArcNode *p; visited[u] = 1; d++; path[d] = u; if(u==v) // 出口 { for(int i=0;inextarc; } } 输出图G中从定点u到v的所有简单路径/* 输出图G中从定点u到v的所有简单路径 典型的DFS 需要额外写一个恢复 */ void FindAllPath(AdjGraph *G, int u, int v,int path[], int d) { int w; ArcNode *p; visited[u] = 1; d++; path[d] = u; if(u == v && d>=0) // 出口 { for(int i=0;inextarc; } visited[u] = 0; // 恢复，该顶点可重复使用 } 求图G中所有从顶点u到v的长度为l的简单路径/* 求图G中所有从顶点u到v的长度为l的简单路径 典型DFS */ void PathlenAll(AdjGraph *G, int u, int v, int l, int path[], int d) { int w; ArcNode *p; visited[u] = 1; d++; path[d] = u; if(u == v&& d==l) { printf(" "); for(int i=0;inextarc; } visited[u] = 0; // 恢复 } 主函数测试int main() { int path[MAXV]; int u=1,v=4,l=3; int n=5,e =8; int A[MAXV][MAXV]={{0,1,0,1,1},{1,0,1,1,0},{0,1,0,1,1},{1,1,1,0,1},{1,0,1,1,0}}; AdjGraph *G; CreateAdj(G,A,n,e); for(int i=0;i]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
        <tag>图算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图-基本运算]]></title>
    <url>%2F2019%2F06%2F16%2F2019-06-16-shu-ju-jie-gou-tu-ji-ben-yun-suan%2F</url>
    <content type="text"><![CDATA[定义 图G由两个集合V和E组成，记为G=(V,E)，其中V是顶点的有限集合，记为V(G), E是连接V中两个不同顶点（顶点对）的边的有限集合，记为E(G) 存储结构 邻接矩阵 邻接表 十字链表 邻接多重表 结构体定义#include #include #include using namespace std; #define MAXV 100 #define INF 32767 typedef struct { int num; // 序号 int data; }VertexType; // 顶点类型 typedef struct { int edges[MAXV][MAXV]; // 邻接矩阵数组 int n,e; // 顶点数，边数 VertexType vertex[MAXV]; // 顶点 }MatGraph; // 图的邻接表表示 typedef struct ANode { //边结点类型 int adjvex; //该边邻接点编号 struct ANode *nextarc; int weight; }ArcNode; typedef struct Vnode{ // 头结点类型 VertexType data; // 顶点信息 int count; // 增加数据域：存放顶点入度 ArcNode *firstarc; }VNode; typedef struct { VNode adjlist[MAXV]; int n; int e; }AdjGraph; // 用一个头节点数组构造的图 邻接表创建图// 用邻接表创建图 void CreateAdj(AdjGraph *&G,int A[MAXV][MAXV], int n, int e) { int i,j; ArcNode* p; G = (AdjGraph*)malloc(sizeof(AdjGraph)); for(i=0;iadjlist[i].firstarc = NULL; for(i=0;i=0;j--) { if(A[i][j] !=0&&A[i][j]!=INF) { p = (ArcNode*)malloc(sizeof(ArcNode)); p->adjvex = j; p->weight = A[i][j]; p->nextarc = G->adjlist[i].firstarc; G->adjlist[i].firstarc = p; } } G->n = n , G->e = e; } 输出图G// 输出图G void DispAdj(AdjGraph *G) { int i; ArcNode *p; for(i=0;in;i++) { p = G->adjlist[i].firstarc; printf("%3d:",i); while(p!=NULL) { printf("%3d[%d]->",p->adjvex,p->weight); p = p->nextarc; } cout < "^\n"; } } adjlist[i].firstarc; if(pre!=NULL) { p = pre->nextarc; while(p!=NULL) { free(pre); pre = p; p = p->nextarc; } free(pre); } } free(G); } 邻接矩阵与邻接表的相互转化// 邻接矩阵转邻接表 复杂度：O(n^2) void MatToList(MatGraph g, AdjGraph *&G) { int i,j; ArcNode *p; G = (AdjGraph*)malloc(sizeof(AdjGraph)); for(i=0;in;i++) G->adjlist[i].firstarc = NULL; for(i=0;i=0;j--) if(g.edges[i][j]!=0&&g.edges[i][j]!=INF) { p = (ArcNode*)malloc(sizeof(ArcNode)); p->adjvex = j; p->weight = g.edges[i][j]; p->nextarc = G->adjlist[i].firstarc; G->adjlist[i].firstarc = p; } G->n = g.n; G->e = g.e; } // 邻接表转邻接矩阵 复杂度 O(n+e) void ListToMat(AdjGraph *G, MatGraph &g) { int i; ArcNode *p; for(i=0;in;i++) { p = G->adjlist[i].firstarc; while(p!=NULL) { g.edges[i][p->adjvex] = p->weight; p = p->nextarc; } } g.n = G->n; g.e = G->e; } 图的遍历深度优先搜索 int visited[MAXV]={0}; // 深度优先搜索 DFS O(n+e) void DFS(AdjGraph *G,int v) // 遍历连通图 { ArcNode *p; visited[v] = 1; printf("%2d",v); p = G->adjlist[v].firstarc; while(p!=NULL) { if(visited[p->adjvex] == 0) DFS(G,p->adjvex); p = p->nextarc; } } void DFS1(AdjGraph *G) // 遍历非连通图 { for(int i=0;in;i++) if(visited[i]==0) DFS(G,i); } 广度优先搜索 // 广度优先搜索 O(n^2) void BFS(AdjGraph *&G, int v) // 遍历连通图 { int w; ArcNode *p; int visited[MAXV] ={0}; visited[v] = 1; printf("%2d",v); deque de; de.push_back(v); while(!de.empty()) { w = *de.begin(); de.pop_front(); p = G->adjlist[w].firstarc; while(p!=NULL){ if(visited[p->adjvex] == 0) { printf("%2d",p->adjvex); visited[p->adjvex] = 1; de.push_back(p->adjvex); } p = p->nextarc; } } cout < endl; } void BFS1(AdjGraph *G) // 遍历非连通图 { for(int i=0;i]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
        <tag>图算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-查找-二叉搜索树]]></title>
    <url>%2F2019%2F06%2F12%2F2019-06-12-shu-ju-jie-gou-cha-zhao-er-cha-sou-suo-shu%2F</url>
    <content type="text"><![CDATA[二叉排序树（Binary Search Tree ，BST）又称二叉排序树，其定义为二叉排序树，或空树，或者是满足以下性质的二叉树： 1.若根节点的左子树非空，则左子树上所有节点关键字小于根节点关键字；2.若根节点的右子树非空，则右子树上所有节点关键字大于根节点关键字；3.根节点的左右子树本身又是一棵二叉排序树。 即在二叉树的基础上添加了结点值的约束。 以下是二叉搜索树的实现。 /* @author:Sinclair @time:2019-06-12 Binary Search Tree 数据结构之二叉搜索（排序）树 */ typedef int KeyType; typedef struct tree{ KeyType key; // other struct tree *lchild,*rchild; }BST; // 插入关键字为k的结点 bool Insert(BST *&bt, KeyType k) { if(bt==NULL) { bt = (BST *)malloc(sizeof(BST)); bt->key = k; bt->lchild = bt->rchild = NULL; return true; } else if(k == bt->key){ return false; } else if(k < bt->key){ return Insert(bt->lchild,k); } else{ return Insert(bt->rchild,k); } } // 创建二叉排序树 BST* Create(KeyType A[],int n) { BST *bt = NULL; int i=0; while(ikey == k) { return bt; } if(kkey){ return Search(bt->lchild, k); } else{ return Search(bt->rchild,k); } } // 查找关键字为k的结点并且还要查找其双亲结点 BST* SearchParents(BST *bt,KeyType k,BST *temp, BST *&father) { if(bt == NULL) { father = NULL; return bt; } else if(bt->key == k) { father = temp; return bt; } if(kkey){ return SearchParents(bt->lchild,k,bt,father); } else{ return SearchParents(bt->rchild, k, bt, father); } } // 找出树中k最大的和最小的结点 KeyType FindMaxNode( BST *p) { while(p->rchild !=NULL){ p = p->rchild; } return p->key; } KeyType FindMinNode( BST *p) { while(p->lchild !=NULL){ p = p->rchild; } return p->key; } void FindMaxMinNode(BST *p) { if(p!=NULL) { if(p->lchild !=NULL) printf("左子树的最大结点为:%d\n",FindMaxNode(p->lchild)); if(p->rchild !=NULL) printf("右子树的最大结点为:%d\n",FindMinNode(p->rchild)); } } void Delete1(BST *p,BST *& r) { BST *q; if(r->rchild!=NULL){ Delete1(p,p->rchild); } else{ p->key = r->key; q = r; r = r->lchild; free(q); } } // 删除树中关键字为k的结点 void Delete(BST *&bt, KeyType k) { BST *p = Search(bt,k); BST *q; if(p->rchild==NULL) // 右子树为空，左子树结点代替 { q = p; p = p->lchild; free(q); } else if(p->lchild ==NULL){ // 左子树为空，右子树结点代替 q = p; p = p->rchild; free(q); } else Delete1(p, p->lchild); // 结点p既有左子树又有右子树 } void DisplayBST(BST* bt) { if(bt != NULL) { cout < bt->key; if(bt->lchild != NULL ||bt->rchild !=NULL) { cout < "("; DisplayBST(bt->lchild); if(bt->rchild != NULL){ cout < ","; } DisplayBST(bt->rchild); cout < ")"; } } }]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
        <tag>图算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019第十届蓝桥杯CB组国赛心得]]></title>
    <url>%2F2019%2F05%2F28%2F2019-05-28-2019-di-shi-jie-lan-qiao-bei-cb-zu-guo-sai-xin-de%2F</url>
    <content type="text"><![CDATA[一年一度的传说中的“暴力”杯又过去了，今年是第一次参加蓝桥杯省赛跟国赛，今天刚从北京回来，觉得应该写点东西，觉得不能再叫蓝桥杯暴力杯了当然大佬觉得还是暴力还请忽略，要改名了，今年难度有点大，首先题目数量变成了 10个，分值设置相对均匀5~25分的样子，之前分数梯度很大，然后难度也加了些，具体多少我也不是很清楚，我做去年第九届跟前年第十届的题目的时候也是很多也都不会做，有人下午比赛比了一半就溜出来了，觉得比CCPC还难，好吧，我还没参加过。我是C/C++B组，当时大概开始2小时左右我也想溜了，题目看到结尾了，好几个不会做的，看别人吃起了面包，觉得可能会分心，就没吃只是喝了口水，然后开始继续写，坚持到了最后，最后还是空了3个题目，大概两个大题，一个填空题，考完心凉了一半，下午6点考完，出来合了个影，既然比赛不顺利，那就玩耍的愉快吧，然后就开始了流浪北京，北京印象的日子。欢迎大家收看一年一集的《北京印象》，总共三集，当前是第一集。比赛那天是周六，周六晚上在首都经贸吃了顿饭（考点在首都经贸）然后去奥体公园看了看，看了下鸟巢，水立方，逛了逛然后就回去了。周日早上下雨其实周六武汉淹了，真遗憾错过了，到了11点觉得待在酒店有点奢侈，有点浪费大好时光，然后冒雨出去逛故宫，逛之前吃了顿烤鸭，真难忘，逛完故宫，骑车观光北京，逛了几个北京的高校，感慨颇多，还是要努力学习，觉得自己的危机意识还是不强，周一中午就踏上了回学校的路。 周日上午大概10点左右在隔壁蓝桥备考群有人上传了获奖名单，翻了半天找到了自己，国二，属于国二下游那种，大概是矬子里拔将军，轮到了我，不过还是听惊喜的，拿了个奖， 下面简单写下题目情况，等到题目放出来更新题解。1.填空题求满足2019 &lt; x &lt; y且20192，x2，y2构成等差数列的x,y，使得x+y最小，输出最小的x+y。 2x2=20192+y2,写个循环找一下，结果是7020 2.填空题把2019分解成若干个两个质数之和，例如2017和2 与 2 和2017是一种情况，求有多少种。 比赛时，这个题目读题不仔细，看成了两个质数之和，暴力搜了一遍发现只有一种，反复核对还是一种，然后半信半疑的写了个1，就提交了。这个题目需要用DP ３.填空题给的是3x3的九个格子，然后如何分割，进行旋转，能完美拼接在一起，好像是问7*7的格子有多少种分案？ 这个题目真的跪了，一开始还能想象到是如何旋转的，后来怎末想都转不过去了，罢了罢了，是在下输了还是太菜 4.填空题大概是求有100个约数的最小整数（比如6有4个约数，1，2，3，6） 暴力枚举搜一下，搜到有100个约数的数就直接break 5.填空题6*6的方格里面从左上角顶点出发，问有多少条有向回路（尽管路径相同，但方向不同也是不同）路线不能出现交叉情况，路径长度不大于12 明显是个深搜题目，比赛之前准备了深搜，地图迷宫类没怎末准备，果然*，应该还是对深搜的理解不够深入，比赛之前敲了个DFS全排列的板子，在这上面改，当时改了半天，觉得很浪费时间，熟练度不够，然后就果断放弃，做后面的题目，唉，惋惜~ 6.编程大题字符串题目，给一个长串s1，一个短串s2，然后在s2中找s1的子序列，然后问最少需要修改s2的几个字符才能实现s2是s1的子序列 每次都被字符串教育，一看根本就不是板子题目，然后需要在板子的基础上稍加处理，当时先机智的跳过了，后来转过头来，写的时候硬着头皮写了个解法，当字符串中出现相同字符的时候的测试数据就过不去，罢了罢了能过几个过几个吧，因为最后回过头来写的时候，时间也不多了。 7.编程大题单调序列，如果三个数a,b,c，如果b&gt;a并且b&gt;c，或者b&lt;a并且b&lt;c则称b点为1个转折点（大概是这个意思）然后就会有1+1个严格单调区间，然后求1~n之间的数，全排列有多少个严格单调区间？ 用next_permutation全排列函数，或者用dfs深搜实现全排列，后来发现这样最多只能实现1~10之间的求解（20%的数据测试），n稍微一大，就一时半会出不来了，优化当时没想出来，反正20分的大题只能拿20%的分数，凉了 ~ 比赛完了，有个学长说这是个找规律的题目，是道数学题 ~ 果然，不加思索直接上去写，真的暴力 ~ 8.编程大题解密 题目记不太清了，当时直接跳了 9.编程大题求第八大奇迹，大致是一边输入数据一边查询第八大奇迹，第k大的问题？？然后奇迹值x会更新，每个查询求区间[l,r]之间的第八大奇迹。简化下：长度为n的序列A，初始值均为0。有m次操作，分为以下两种：1、C p x：把A[p]的值改为x.2、Q l r： 询问区间[l,r] 的第8大的数，不存在输出0。 当时写了好久这个题目，最后用了一个结构体，来保存查询信息，即Q，然后C就直接用数组即a[p] = x 然后拷贝出区间数据，然后进行排序，查询，觉得应该能过大部分数据，比赛完我看群里说要用线段树~ 还没学到~ 10.编程大题他们说是数学题，概率DP？？？当时直接跳了~ 所以算下来大概就是2道填空题，2道能过10%~20%数据的大题，还有一道能过70%或者80%数据的题目，国二下游，还是要努力，明年再见 ~ 哦 ~ 今年发了件T恤，蓝桥十周年，考场面包带回去给室友吃了、牛奶、矿泉水还可以，还有只印有蓝桥的圆珠笔。]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>竞赛感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最妙不过位运算]]></title>
    <url>%2F2019%2F05%2F23%2F2019-05-23-zui-miao-bu-guo-wei-yun-suan%2F</url>
    <content type="text"><![CDATA[先来占个坑，以后慢慢补充。 一道蓝桥杯2018B组国赛题目 格雷码补全代码的题目格雷码是以n位的二进制来表示数。 与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。 首尾两个数字也要求只有1位之差。有很多算法来生成格雷码。以下是较常见的一种： 从编码全0开始生成。 当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0） 当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。 用这个规则产生的4位格雷码序列思路：偶数时直接异或1；奇数时找到最低位的1，然后将其左移一位，在于原来的值进行异或。试问，如何找到最低位的1？直接x&amp;(-x)即可！ #include void show(int a,int n) { int i; int msk = 1; for(i=0; i]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS入门学习]]></title>
    <url>%2F2019%2F05%2F22%2F2019-05-22-dfs-ru-men-xue-xi%2F</url>
    <content type="text"><![CDATA[学习DFS看了很多篇博客慢慢入门，感谢我看过的所有博客，我把其中做过的题目汇总起来，里面有很多是大神的代码，与大家分享。@[toc] 计蒜客A1601全排列 计蒜客A1601全排列找的是全排列中，排列结果互不相同的个数 #include #include #include #include #include using namespace std; const int N=1e3; char str[N], buf[N];//buffer int vis[N], total, len; void arrange(int num) { if (num == len){ printf("%s\n", buf); total++; return; } for (int i = 0; i < len; ++i) { if (!vis[i]) { int j; for (j = i + 1; j < len; ++j) { if (vis[j]&&str[i] == str[j]) { break; } } if (j == len) { vis[i] = 1; buf[num] = str[i]; arrange(num + 1); vis[i] = 0; } } } } int main() { while (~scanf("%s",str)) { len = strlen(str); sort(str, str + len); total = 0; buf[len] = '\0'; arrange(0); printf("Total %d\n", total); } return 0; } 计蒜客A1636素数个数 计蒜客A1636素数个数 题目大致是求0~7的全排列组成的数字（首位不为0）中素数的个数，该题可理解为在全排列的基础上进行了条件限制 DFS+判断 答案：2668#include #include #include #include using namespace std; typedef unsigned long long ll; int isPrime1(ll s) { if(s==2||s==3) return 1; if(s%6!=1&&s%6!=5) return 0; int t = sqrt(s); for(int i=5;i]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-29 修理牧场]]></title>
    <url>%2F2019%2F05%2F04%2F2019-05-04-7-29-xiu-li-mu-chang%2F</url>
    <content type="text"><![CDATA[来源：(PTA数据结构与算法题目集(中文) 农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要N块木头，每块木头长度为整数Li个长度单位，于是他购买了一条很长的、能锯成N块的木头，即该木头的长度是Li的总和。但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。请编写程序帮助农夫计算将木头锯成N块的最少花费。 输入格式:输入首先给出正整数N（≤10​4），表示要将木头锯成N块。第二行给出N个正整数（≤50），表示每段木块的长度。 输出格式:输出一个整数，即将木头锯成N块的最少花费。 输入样例:84 5 1 2 1 3 1 1输出样例:49 // 哈夫曼树 #include #include #include #include using namespace std; int main() { priority_queuep; int n; cin >> n; for(int i=0;i> t; p.push(t); } int s=0; while(p.size()>1){ int num1 = p.top(); p.pop(); int num2 = p.top(); p.pop(); s += (num1+num2); p.push(num1+num2); } cout < s; return 0; }]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次参加蓝桥杯(第十届)感怀]]></title>
    <url>%2F2019%2F03%2F24%2F2019-03-24-di-yi-ci-can-jia-lan-qiao-bei-di-shi-jie-gan-huai%2F</url>
    <content type="text"><![CDATA[四个小时，十道题目，花了学院300块大洋 \捂脸这是我第一次参加规模还差不多的程序设计比赛，蓝桥杯，当然一些大牛高校的王牌选手是不稀罕参加的，网上风评称其为“暴力杯”，说根本用不到什么算法技巧，只要会点数学，全程暴力求解就ok，比赛之前看了很多关于蓝桥杯的经验贴，其中出现频率最高的词汇是暴力求解，后来慢慢的训练的做题目的时候，才知道什么是真正的暴力求解，所谓暴力求解，并非无脑不假思索的就直接暴力枚举，而是要经过若干逻辑判断之后，进行求解，相比于十分精巧的算法技巧来说，是暴力了些。比赛的前一天，也就是昨天，我还在看蓝桥杯必考的快排、DFS、贪心….结果必考的没考，没考快排，考了DFS，一道迷宫题目，当时看了看，因为深搜不熟练，觉得做这道题目的话，做半天可能也做不出来，白浪费时间干脆直接跳过，这道题是填空题，15分，下了考场之后，群里有人说这是一道华为的面试题目，好吧。同样是参加蓝桥杯，车上有18级的、17级的还有16级的，我是17级但是今年是第一次参加蓝桥杯，我大一这时候，听老师的话自己的笔记本还没买…经过我的亲身经历证明，对于计算机专业来说，这是万万不行的，我大一一年一直停留在C，C还没精通，而别人大一就学完了C、C++、数据结构甚至更多，而我大一的时间都去哪儿了，我用我的时间换来了什么？都是值得思考的问题，终于我在大一的暑假反应过来，励志大二上学完数据结构，可是大二上课多，再加上自己的惰性，这个历史性的任务终究还是没完成。大二上参加的学院老师讲的蓝桥杯培训课，去是每次都去了，可是也仅仅是听了听，自己也没有下去动手，导致编码能力太差，到现在，我发现18级的很多学生的编码能力已经比我强了…当然这种事情也说不好，毕竟起跑线不同我又在给自己找借口，菜就是原罪。等到了大二上期末考试考完之后，留校做课设，那个时候我开始准备蓝桥杯，从数论开始学起，没学多少放寒假了，打算寒假训练自己的编码能力，顺便学学数据结构的，结果学习的重心不知不觉跑到了JAVA上。我就是这样一步一步的鸽掉我的算法训练的…到了大二下学期，正儿八经的自我反思过后，决心要努力学习训练算法，没事就刷题，周末时间抱着电脑图书馆刷各大OJ上的题目，看别人说，先来刷个杭电OJ 100题水题100道。然而我到现在也只是异常费劲的写了35道，前几天学习算法知识，做题目，越做越绝望，看一道不会，看一道不会，然后去网上找解题报告看，学习别人的思路，看别人的做法，我立誓要学好算法，去参加各种程序设计比赛，让日后的每一天都不会像现在一样窘迫。昨天周六，比赛前一天，我在图书馆看了一天的往年题目，也思考了很多，思考我努力学习算法到底是为了什么？为了参加比赛？为了拿奖？用拿来的奖来证明自己？用拿来的奖来争取推免资格？我想了又想，我最初就是为了拿到推免资格来参加比赛，一直心急的去参加各种比赛，以前参加的全国大学生数学竞赛、全国大学英语竞赛，每次都是匆匆上阵，每次都是落荒而逃，每次都是说下次一定再去努力。那便是我的2018年的写照。参加程序设计比赛是为了拿奖，而不是出于对编程的热爱，一直以来，觉得自己一个很大的缺点，就是太过于急功近利，我没有别人的聪明才智，也没有别人的超高效率，更没有比别人很强的能力，却总想着去用做一件事的时间来做两件事，有时候会面对两个比赛，别人可能会有所取舍，而我却总想着我能做到，然后急功近利的去报了两个比赛的名，然后最后可能一个比赛的作品都提交不上。如今2019了，不能再鸽了，不能再中途放弃了，包括写博客，这是我2019年开始写的，我的博客搭建好了, 2019年要去更加努力、更加自律、更加脚踏实地、不能再去做思想上的巨人而行动上的侏儒了，今天的蓝桥杯落下帷幕，下周的高校天梯赛，由于种种原因，参赛名单里没我，正好我可以重新训练，学习我要今年3月份完成的数据结构教程学习，还要补作业，写一个带界面的迷宫算法，算是个小课设。接下来的希望就是我能进阶决赛，去首都走一趟。能不能进决赛，下周比赛结果就出来了。最近的一个比赛可能就是中国高校微信小程序比赛，要准备参赛了。总要做出点东西来，才不枉自己对一步步接近梦想时内心的汹涌与澎湃。另外，自己的暑假也被安排上了，前20天去导师实验室跟着做项目学习假如我啥都不会做，那我扫地好了后面的一个月参加数学建模培训，参赛，另外把去年失之交臂的数竞再来一遍，不到长城非好汉，人啊，总是失去了才知道珍惜，当我重新再拿到机会时我想我会倍加珍惜…再来谈谈今天的蓝桥杯，今天去的赛点是一个民办大学，一下车觉得这所学校未免也有点太高端，比我的学校好太多，这建筑、这校园、这高楼，真想来这里读大学，当然这是参赛之前的想法，当我参加完比赛之后，我的认知发生了变化你懂的，与更好的校园设施（宽敞的校园、气派的大门，高端的大楼）相比，我还是更喜欢学习氛围、学术氛围更加浓厚的学校，尽管它的校门可能不是那么气派。 更于2019年3月28日初赛结果出来了，省一，要准备国赛了…]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>竞赛感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2032之杨辉三角的多种解法]]></title>
    <url>%2F2019%2F03%2F09%2F2019-03-09-hdu2032-zhi-yang-hui-san-jiao-de-duo-chong-jie-fa%2F</url>
    <content type="text"><![CDATA[HDU2032 还记得中学时候学过的杨辉三角吗？具体的定义这里不再描述，你可以参考以下的图形：11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1 即元素值等于肩上的两个元素之和，每行第一个跟最后一个都为１。 //解法１、二维数组 int main() { int n,a[30][30]={0}; while(cin>> n) { for(int i=0;i]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个小绿锁引发的问题]]></title>
    <url>%2F2019%2F03%2F08%2F2019-03-08-bo-ke-tian-jia-ssl%2F</url>
    <content type="text"><![CDATA[最近在阿里云买了个域名，毕竟**.github.io有点长，买了个便宜的top。在阿里云控制台解析了之后，后来访问的时候总是显示非安全连接，身为强迫症患者，这肯定不能忍，然后就着手开始做了。 据外媒报道，从2017年1月份正式发布的Chrome 56开始，Google将把某些包含敏感内容的HTTP页面标记为“不安全”，比如含有密码或支付表单信息。Google最终目标是将所有打破了https连接的HTTP页面，用特定的红色图标给标记出来… 此举旨在唤起用户有关HTTP连接不安全、容易受到中间人攻击等危险的意识。通过HTTP连接发送的数据（比如密码和支付细节），会被通网络下别有用心的人轻易拦截。 为了这把小绿锁（安全问题），需要添加第三方的证书，这时Cloudflare提供的免费的SSL成为不二之选 收费的SSL服务总是比免费的更加周到，一般收费的SSL都会提供端到端的加密。但是价格不菲，对于个人博客来说，这是一笔不必要的开销。我只是需要看到网站地址栏有绿色的锁头，那就证明我们的网站相对安全了。此外，使用https之后，谷歌、百度等搜索排名权值（PR等）也会有相对提升。还有其他的一些，例如Cloudflare还提供免费的CDN和缓存技术，让浏览者有更好的体验~~ 下面是我参考的教程(博主尊重原创，故此下面只给出超链)：为自定义域名的GitHub Pages添加SSL 完整方案为添加了自定义域名的GitHub Pages添加SSL，启用强制HTTPS(小绿锁） 总之，博客愈发完善，每次改动都会碰见一堆高大上的专业术语，而他们却真实的来自那看起来枯燥无聊的基础知识，实战受蹩，或许看书应该能更加投入。等技术再成熟些，博客应该会更完善！ 调试完一个动态连接函数，固然值得兴奋，但真正的成功远还在无数个函数之后。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2018母牛的故事]]></title>
    <url>%2F2019%2F03%2F03%2F2019-03-03-hdu2018-mu-niu-de-gu-shi%2F</url>
    <content type="text"><![CDATA[Problem Description 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 Output 对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 Sample Input 2450 Sample Output246 分析根据题目已知，列出表格 第n年 成年牛 幼牛1 幼牛2 幼牛3 总数 1 1 1 2 1 1 2 3 1 1 1 3 4 1 1 1 1 4 5 2 2 1 1 6 6 3 3 2 1 9 7 4 4 3 2 13 8 6 6 4 3 19 9 9 9 6 4 28 … … … … … … 观察表格，联想斐波那契数列，可得出以下公式： fn = fn-1 + fn-3 题解//解法1 #include using namespace std; int main() { int n; while(cin>>n&&n!=0) { int a[56]; a[0] = 1;a[1] = 2;a[2] = 3;a[3] = 4; for(int i=4;i]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3字符串API之expandtabs()]]></title>
    <url>%2F2019%2F02%2F11%2F2019-02-11-python3-zi-fu-chuan-api-zhi-expandtabs%2F</url>
    <content type="text"><![CDATA[Challenges make you discover things about yourself that you never really knew.挑战能让你发现自己都不曾了解过的一面。 ——-Cicely Tyson 描述 def expandtabs(self, *args, **kwargs): # real signature unknown** """ Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. """ pass 返回字符串的一个拷贝，该拷贝中把字符串中的tab (即’\t‘)转换为指定的tabsize数量的空格，其中若tabsize未给出则默认为8. 语法 str.expandtabs(tabsize = 8); 实例其实还是例子更直观 # 代码段 print("第一行为基准") print("123456789012345678901") s1 = "123456\t7890\t123" print(s1) print(s1.expandtabs(6)) print(s1.expandtabs(7)) print(s1.expandtabs(8)) print(s1.expandtabs(9)) s2 = "\t12\t345678\t123" print(s2) print(s2.expandtabs()) # 结果显示 第一行为基准 123456789012345678901 123456 7890 123 123456 7890 123 123456 7890 123 123456 7890 123 123456 7890 123 12 345678 123 12 345678 123 总结 &emsp;&emsp;expandtabs() 方法是把字符串中的’\t’转换为空格。 &emsp;&emsp;下面首先来说说’\t’，在Python3中 ‘\t’ 是补4的整数倍个空格，假如’\t’在字符串首，则会补4个空格，当在串中时要看’\t’前面的字符，距离4的整数倍差多少补多少空格。 &emsp;&emsp;下面再说一下这个 expandtabs() 方法就是在 ‘\t’ 处补指定长度tabsize的空格，可以自定指定，也可以使用默认的补8个空格，即看前面的字符串然后将其补到tabsize的整数倍，假如’\t’在串首则直接补tabsize数量的空格。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中关于日期的printf格式化输出]]></title>
    <url>%2F2019%2F02%2F09%2F2019-02-09-java-zhong-guan-yu-ri-qi-de-printf-ge-shi-hua-shu-chu%2F</url>
    <content type="text"><![CDATA[If you believe in yourself enough and know what you want, you’re gonna make it happen.如果你足够自信，也知道自己想要什么，就一定会实现心中所想。——-Mariah Carey, “Make It Happen” printf方法可以很轻易的格式化日期，用两个字母，以%t开头并以下面的其中一个字母结尾。转换符|说明—-|—-|—-|——-a|日期中星期简称A|日期中星期全称b|日期中月份的简称B|日期中月份的全称C|日期中年份的前两位数y|日期中年份的后两位数Y|日期中年份的完整表示D|“年/月/日”格式F|“年-月-日”格式j|一年中的第几天m|日期中的月份，两位数字表示，不足两位补零d|日期中的日，两位数字表示，不足两位补零e|日期中月份的日，不补零T|“HH:MM:SS” 格式（24小时）r|“HH:MM:SS PM”格式（12小时）R|“HH:MM”格式（24小时） 测试public class Sinclair_java_20190122 { public static void main(String[] args) { Date date = new Date(); String str = String.format(Locale.US,"英文月份简称：%tb",date); System.out.println(str); System.out.printf("本地月份简称：%tb\n",date); str = String.format(Locale.US, "英文月份全称：%tB",date); System.out.println(str); System.out.printf("本地月份全称：%tB%n",date); str = String.format(Locale.US, "英文星期简称：%ta",date); System.out.println(str); System.out.printf("本地星期的全称：%tA%n",date); System.out.printf("本地星期的简称：%ta%n",date); System.out.printf("年的前两位数字：%tC%n",date); System.out.printf("年的后两位数字：%ty%n",date); System.out.printf("年的完整表示：%tY%n",date); System.out.printf("一年中的天数：%tj%n",date); System.out.printf("%s %tY-%]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧几里得算法]]></title>
    <url>%2F2019%2F01%2F09%2F2019-01-09-ou-ji-li-de-suan-fa%2F</url>
    <content type="text"><![CDATA[欧几里得算法求最大公约数 Sometimes your whole life boils down to one insane move. 人这一辈子，有时就得靠一次疯狂的举动才能扭转乾坤。 —————————《阿凡达》 @[toc] 一、介绍欧几里得 &emsp;&emsp;像所有博客一样，出于尊重，介绍一下这位伟大的数学家欧几里得。 &emsp;&emsp;欧几里得，古希腊人，数学家，主要成就：数学巨著《几何原本》、欧几里得算法、完全数。 &emsp;&emsp;在柏拉图学派晚期导师普罗克洛斯（约410～485）的《几何学发展概要》中，就记载着这样一则故事，说的是数学在欧几里得的推动下，逐渐成为人们生活中的一个时髦话题(这与当今社会截然相反)，以至于当时亚里山大国王托勒密一世也想赶这一时髦，学点儿几何学。 &emsp;&emsp;虽然这位国王见多识广，但欧氏几何却令他学的很吃力。于是，他问欧几里得“学习几何学有没有什么捷径可走？”，欧几里得笑道：“抱歉，陛下!学习数学和学习一切科学一样，是没有什么捷径可走的。学习数学，人人都得独立思考，就像种庄稼一样，不耕耘是不会有收获的。在这一方面，国王和普通老百姓是一样的。” 从此,“在几何学里,没有专为国王铺设的大道。”这句话成为千古传诵的学习箴言。&emsp;&emsp;总之呢，任何事情都是这样，哪有这么多得捷径可走，天才往往都是天天积累成才。 二、实现思路 定义2.1：设m和n是两个不全为0的整数，称m与n的公因子中最大的为m与n的最大公因子，或最大公约数(greatest common divisor)，记作gcd(m,n)定义2.2：设m和n是两个非零整数，称a与b最小的公倍数为m与n的最小公倍数(least common multiple)，记作lcm(m,n) 欧几里得算法又称辗转相除法 s：设两个正整数m，n且m &gt; n ; s1：令r=m%n（%代表取余）； s2：若r=0(即n整除m)运算结束，n为结果 ； s3：否则令m=n，n=r并返回s1 ； 三、核心思想gcd(m,n)=gcd(n,mod(m,n) lcm(m,n) = ab/gcd(m,n) 证明：不妨设 m=k1d ,n=k2d , k3 = m/n (整除) 则 r=m-k3n=k1d-k2k3d=(k1- k2k3)d故r也是d的倍数，得证$\it gcd (m,n)=gcd(n,mod(m,n)$ 四、优点 一看相比于穷举法，效率也会高很多 五、核心代码 int gcd(int m,int n) { int t,r; if(m]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2099整除的尾数]]></title>
    <url>%2F2019%2F01%2F09%2F2019-01-09-hdu2099-zheng-chu-de-wei-shu%2F</url>
    <content type="text"><![CDATA[整除的尾数 You have to live spherically - in many directions.Never lose your childish enthusiasm and things will come your way.人要活得精彩，各个领域都要勇于尝试，永远保持童真般的热情，一切就会得偿所愿。 ——《托斯卡尼艳阳下》 Problem Description 一个整数，只知道前几位，不知道末二位，被另一个整数除尽了，那么该数的末二位该是什么呢？ Input 输入数据有若干组，每组数据包含二个整数a，b（0&lt;a&lt;10000, 10&lt;b&lt;100），若遇到0 0则处理结束。 Output 对应每组数据，将满足条件的所有尾数在一行内输出，格式见样本输出。同组数据的输出，其每个尾数之间空一格，行末没有空格。 Sample Input 200 401992 950 0 Sample Output 00 40 8015 一、思路 输入要判断是否为0，先将这个整数乘以100，然后利用0到99的穷举进行判断，输出时考虑到0的问题，用printf函数输出。 二、代码实现#include using namespace std; int main() { int a,b,count=0; while(cin>> a >> b && a!=0 && b!=0) { a *= 100; for(int i=0;i]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2097Sky数]]></title>
    <url>%2F2019%2F01%2F09%2F2019-01-09-hdu-2097sky-shu%2F</url>
    <content type="text"><![CDATA[Sky数 My life didn’t please me, so I created my life.我的生活不曾取悦于我，所以我创造了自己的生活 ———-Coco Chanel Problem Description Sky从小喜欢奇特的东西，而且天生对数字特别敏感，一次偶然的机会，他发现了一个有趣的四位数2992，这个数它的十进制数表示，其四位数字之和为2+9+9+2=22，它的十六进制数BB0，其四位数字之和也为22，同时它的十二进制数表示1894，其四位数字之和也为22，啊哈，真是巧啊。Sky非常喜欢这种四位数，由于他的发现，所以这里我们命名其为Sky数。但是要判断这样的数还是有点麻烦啊，那么现在请你帮忙来判断任何一个十进制的四位数，是不是Sky数吧。 Input 输入含有一些四位正整数，如果为0，则输入结束。 Output 若n为Sky数，则输出“#n is a Sky Number.”，否则输出“#n is not a Sky Number.”。每个结果占一行。注意：#n表示所读入的n值。 Sample Input 299212340 Sample Output 2992 is a Sky Number.1234 is not a Sky Number. 思路 输入一个四位整数，需要将其进制转换，而在进制转换的过程中又可以实现四位数各位相加，看似需要将数据转换成十六进制、十二进制（输入的便是十进制），实则，只需一个进制转换求和函数就可以实现，不妨设转换为n进制，在转换的过程中便可实现求和，先对n求模，再整除n，最后判断和是否相等即可。 代码#include using namespace std; int DBC(int a,int n) //将数字a转化为n进制，将其每位相加求和 { int sum=0; while(a) { sum += a%n; a /= n; } return sum; } int main() { int a,b,sum=0; while(cin >> a && a!=0) { b=a; //个人认为，这里只要三者相等即可，不一定为22 if((DBC(b,10)==DBC(b,16)) && (DBC(b,10)==DBC(b,12))) cout< a < " is a Sky Number." < endl; else cout< a < " is not a Sky Number." < endl; } return 0; }]]></content>
      <categories>
        <category>数据结构与算法训练</category>
      </categories>
      <tags>
        <tag>数据结构与算法训练</tag>
      </tags>
  </entry>
</search>
