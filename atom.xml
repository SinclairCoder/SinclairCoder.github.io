<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SinclairのBlog</title>
  
  <subtitle>为而不争</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sinclaircoder.top/"/>
  <updated>2020-01-22T04:35:46.061Z</updated>
  <id>https://sinclaircoder.top/</id>
  
  <author>
    <name>SinclairWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PTA朋友圈(并查集)</title>
    <link href="https://sinclaircoder.top/2020/01/20/2020-01-20-pta-peng-you-quan-bing-cha-ji/"/>
    <id>https://sinclaircoder.top/2020/01/20/2020-01-20-pta-peng-you-quan-bing-cha-ji/</id>
    <published>2020-01-19T16:00:00.000Z</published>
    <updated>2020-01-22T04:35:46.061Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>某学校有N个学生，形成M个俱乐部。每个俱乐部里的学生有着一定相似的兴趣爱好，形成一个朋友圈。一个学生可以同时属于若干个不同的俱乐部。根据“我的朋友的朋友也是我的朋友”这个推论可以得出，如果A和B是朋友，且B和C是朋友，则A和C也是朋友。请编写程序计算最大朋友圈中有多少人。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入的第一行包含两个正整数N（≤30000）和M（≤1000），分别代表学校的学生总数和俱乐部的个数。后面的M行每行按以下格式给出1个俱乐部的信息，其中学生从1~N编号：</p><p>第i个俱乐部的人数Mi（空格）学生1（空格）学生2 … 学生Mi</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>输出给出一个整数，表示在最大朋友圈中有多少人。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><blockquote><p>7 4<br>3 1 2 3<br>2 1 4<br>3 5 6 7<br>1 6</p></blockquote><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><blockquote><p>4</p></blockquote><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;#define N 30005int fa[N],num[N];int find(int x){    if(x==fa[x]) return x;    return fa[x] = find(fa[x]);}void Union(int x,int y){    int rootx = find(x),rooty = find(y);    if(rootx!=rooty){        fa[rooty] = rootx;        num[rootx] += num[rooty];    }}int main(){    int n,m;    cin &gt;&gt; n &gt;&gt; m;    for(int i=1;i&lt;=n;i++) {        fa[i] = i;num[i]=1;    }    for(int i=0;i&lt;m;i++){        int cnt,root,x;        cin &gt;&gt; cnt;        cin &gt;&gt; root;            for(int j=1;j&lt;cnt;j++) {            cin &gt;&gt; x;            Union(root,x);        }    }    int res=1;    for(int i=1;i&lt;=n;i++){        res = max(res,num[fa[i]]);    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
      <category term="并查集" scheme="https://sinclaircoder.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>PTA列出连通集(DFS+BFS)</title>
    <link href="https://sinclaircoder.top/2020/01/20/2020-01-20-pta-lie-chu-lian-tong-ji-dfs-bfs/"/>
    <id>https://sinclaircoder.top/2020/01/20/2020-01-20-pta-lie-chu-lian-tong-ji-dfs-bfs/</id>
    <published>2020-01-19T16:00:00.000Z</published>
    <updated>2020-01-22T04:38:55.987Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入第1行给出2个整数N(0&lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>按照”{ v​1 v​2​​  … v​k​​  }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><blockquote><p>8 6<br>0 7<br>0 1<br>2 0<br>4 1<br>2 4<br>3 5</p></blockquote><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><blockquote><p>{ 0 1 4 2 7 }<br>{ 3 5 }<br>{ 6 }<br>{ 0 1 2 7 4 }<br>{ 3 5 }<br>{ 6 }</p></blockquote><p><br></p><p><br></p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;#define N 15int edge[N][N],vis[N];queue&lt;int&gt; qu;void dfs(int x,int n){    vis[x] = 1;    cout &lt;&lt; &quot; &quot; &lt;&lt; x;    for(int i=0;i&lt;n;i++){        if(edge[x][i]&amp;&amp;!vis[i]) dfs(i,n);    }}void bfs(int x,int n){    qu.push(x);    vis[x] = 1;    while(!qu.empty()){        int root = qu.front();        cout &lt;&lt; &quot; &quot; &lt;&lt; root;        qu.pop();        for(int i=0;i&lt;n;i++){            if(edge[root][i]&amp;&amp;!vis[i]){                qu.push(i);                vis[i] = 1;            }        }    }    }int main(){    int n,e,x,y;    cin &gt;&gt; n &gt;&gt; e;    for(int i=1;i&lt;=n;i++) {        edge[i][i] = 1;     }    for(int i=0;i&lt;e;i++){        cin &gt;&gt; x &gt;&gt;y;        edge[x][y] = 1;        edge[y][x] = 1;    }    for(int i=0;i&lt;n;i++) {        if(!vis[i]){            cout &lt;&lt; &quot;{&quot;;            dfs(i,n);            cout &lt;&lt; &quot; }&quot; &lt;&lt; endl;        }        }    memset(vis,0,sizeof(vis));    for(int i=0;i&lt;n;i++){        if(!vis[i]) {            cout &lt;&lt; &quot;{&quot;;            bfs(i,n);            cout &lt;&lt; &quot; }&quot; &lt;&lt; endl;        }    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
      <category term="DFS" scheme="https://sinclaircoder.top/tags/DFS/"/>
    
      <category term="BFS" scheme="https://sinclaircoder.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>PTA小字辈（BFS）</title>
    <link href="https://sinclaircoder.top/2020/01/19/2020-1-19-pta-xiao-zi-bei-bfs/"/>
    <id>https://sinclaircoder.top/2020/01/19/2020-1-19-pta-xiao-zi-bei-bfs/</id>
    <published>2020-01-18T16:00:00.000Z</published>
    <updated>2020-01-22T04:32:14.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。</p><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父/母。家谱中辈分最高的老祖宗对应的父/母编号为 -1。一行中的数字间以空格分隔。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><blockquote><p>9<br>2 6 5 5 -1 5 6 4 7</p></blockquote><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><blockquote><p>4<br>1 9</p></blockquote><p>其实主要是存储的数据结构的设计。<br><br></p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;struct node{    int father;    vector&lt;int&gt; child;}family[100005];queue&lt;int&gt; qu;vector&lt;int&gt; level;int maxh = 1;void bfs(int root){    qu.push(root);    level[root] = 1;    while(qu.size()){        int index = qu.front();        qu.pop();        vector&lt;int&gt; tmp = family[index].child;        for(int i=0;i&lt;tmp.size();i++){            level[tmp[i]] = level[index]+1;            maxh = max(level[tmp[i]],maxh);            qu.push(family[index].child[i]);         }    }}int main(){    int n,x,root;    cin &gt;&gt; n;    level.resize(n+1);    for(int i=1;i&lt;=n;i++){        cin &gt;&gt; family[i].father;        if(family[i].father==-1) root = i;        else {            family[family[i].father].child.push_back(i);        }    }    bfs(root);    cout &lt;&lt; maxh &lt;&lt; endl;    int first = 1;    for(int i=1;i&lt;=n;i++){        if(level[i]==maxh){            if(first) {                cout &lt;&lt; i ; first = 0;            }            else cout &lt;&lt; &quot; &quot; &lt;&lt; i ;         }    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
      <category term="BFS" scheme="https://sinclaircoder.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>PTA列出叶结点(BFS)</title>
    <link href="https://sinclaircoder.top/2020/01/19/2020-01-19-pta-lie-chu-xie-jie-dian-bfs/"/>
    <id>https://sinclaircoder.top/2020/01/19/2020-01-19-pta-lie-chu-xie-jie-dian-bfs/</id>
    <published>2020-01-18T16:00:00.000Z</published>
    <updated>2020-02-16T07:24:07.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于给定的二叉树，本题要求你按从上到下、从左到右的顺序输出其所有叶节点。</p><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>首先第一行给出一个正整数 N（≤10），为树中结点总数。树中的结点从 0 到 N−1 编号。随后 N 行，每行给出一个对应结点左右孩子的编号。如果某个孩子不存在，则在对应位置给出 “-“。编号间以 1 个空格分隔。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中按规定顺序输出叶节点的编号。编号间以 1 个空格分隔，行首尾不得有多余空格。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><pre><code>81 -- -0 -2 7- -- -5 -4 6</code></pre><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><blockquote><p>4 1 5</p></blockquote><p>实现：<br>题意理解了半天… 开个标记数组，在叶子左右孩子节点中出现过的就进行标记。剩下的那一个就是root，然后在进行BFS</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;struct node{    int leaf ;    int right;}q[15]; queue&lt;int&gt; qu; int res[15],top=0;void bfs(){    while(qu.size()){        int num = qu.front();        qu.pop();        if(q[num].leaf==-1&amp;&amp;q[num].right==-1) res[top++] = num;        if(q[num].leaf!=-1) qu.push(q[num].leaf);        if(q[num].right!=-1) qu.push(q[num].right);    }}int main(){    int n,root;    cin &gt;&gt; n;    getchar();    int flag[n];    char a,b;    memset(q,0,sizeof(q));    memset(flag,0,sizeof(flag));    for(int i=0;i&lt;n;i++){        scanf(&quot;%c %c&quot;,&amp;a,&amp;b);        getchar();        if(a==&#39;-&#39;) q[i].leaf=-1;        else {            q[i].leaf = a-&#39;0&#39;;flag[q[i].leaf] = 1;        }         if(b==&#39;-&#39;) q[i].right=-1;        else {            q[i].right = b-&#39;0&#39;;flag[q[i].right] = 1;        }         }    for(int i=0;i&lt;n;i++){        if(flag[i]==0){            root = i;            break;        }    }    qu.push(root);    bfs();    cout &lt;&lt; res[0];    for(int i=1;i&lt;top;i++){        cout &lt;&lt; &quot; &quot; &lt;&lt; res[i];    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
      <category term="BFS" scheme="https://sinclaircoder.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>PTA哥尼斯堡的“七桥问题”（欧拉回路+并查集）</title>
    <link href="https://sinclaircoder.top/2020/01/19/2020-01-19-pta-ge-ni-si-bao-de-qi-qiao-wen-ti-ou-la-hui-lu-bing-cha-ji/"/>
    <id>https://sinclaircoder.top/2020/01/19/2020-01-19-pta-ge-ni-si-bao-de-qi-qiao-wen-ti-ou-la-hui-lu-bing-cha-ji/</id>
    <published>2020-01-18T16:00:00.000Z</published>
    <updated>2020-01-22T04:33:34.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，<br>可否走过这样的七座桥，而且每桥只走过一次？瑞士数学家欧拉(Leonhard Euler，1707—1783)最终解决了这个问题，并由此创立了拓扑学。<br>这个问题如今可以描述为判断欧拉回路是否存在的问题。欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个无向图，问是否存在欧拉回路？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入第一行给出两个正整数，分别是节点数N (1≤N≤1000)和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>若欧拉回路存在则输出1，否则输出0。</p><h2 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h2><blockquote><p>6 10<br>1 2<br>2 3<br>3 1<br>4 5<br>5 6<br>6 4<br>1 4<br>1 6<br>3 4<br>3 6    </p><h2 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h2><p>1</p></blockquote><h2 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h2><blockquote><p>5 8<br>1 2<br>1 3<br>2 3<br>2 4<br>2 5<br>5 3<br>5 4<br>3 4</p></blockquote><h2 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h2><blockquote><p>0</p></blockquote><p><br><br>思路：<br><br>如果欧拉通路的起点与终点一样，则成为欧拉回路， 连通的多重图具有欧拉回路当且仅当它的每个顶点都有偶数度<br>则欧拉回路的条件：</p><ul><li>图是连通的，没有孤立节点</li><li>无向图的每个节点的度数都是偶数度，有向图每个节点的入度等于出度</li></ul><p>使用并查集统计连通分量个数，使用degree数组奇偶数判断是否全为偶数。<br><br></p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;int fa[1005];int father(int x){    if(fa[x]==x) return x;    return fa[x] = father(fa[x]);} int main(){    int n,m,x,y;    cin &gt;&gt; n &gt;&gt; m;    int degree[n+1];    for(int i=1;i&lt;=n;i++)  fa[i] = i;    memset(degree,0,sizeof(degree));    for(int i=0;i&lt;m;i++){        cin &gt;&gt; x &gt;&gt; y;        int rootx = father(x),rooty = father(y);        if(rootx!=rooty){            fa[rooty] = rootx;        }        // fa[father(y)] = father(x);  这样写竟然会超时！！！！        // 不要问我咋知道的        degree[x]++;        degree[y]++;    }    int exist=1,root = fa[1],connectcnt = 0;    for(int i=1;i&lt;=n;i++){        if(fa[i]==i) connectcnt++;    }    if(connectcnt&gt;1) exist = 0;    for(int i=1;i&lt;=n;i++){        if(degree[i]%2){            exist = 0;break;        }    }     cout &lt;&lt; exist &lt;&lt; endl;        return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
      <category term="欧拉回路" scheme="https://sinclaircoder.top/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    
      <category term="并查集" scheme="https://sinclaircoder.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>PTA汉密尔顿回路</title>
    <link href="https://sinclaircoder.top/2020/01/19/2020-01-19-pta-han-mi-er-dun-hui-lu/"/>
    <id>https://sinclaircoder.top/2020/01/19/2020-01-19-pta-han-mi-er-dun-hui-lu/</id>
    <published>2020-01-18T16:00:00.000Z</published>
    <updated>2020-01-22T04:34:51.273Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>著名的“汉密尔顿（Hamilton）回路问题”是要找一个能遍历图中所有顶点的简单回路（即每个顶点只访问 1 次）。本题就要求你判断任一给定的回路是否汉密尔顿回路。</p><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>首先第一行给出两个正整数：无向图中顶点数 N（2&lt;N≤200）和边数 M。随后 M 行，每行给出一条边的两个端点，格式为“顶点1 顶点2”，其中顶点从 1 到N 编号。再下一行给出一个正整数 K，是待检验的回路的条数。随后 K 行，每行给出一条待检回路，格式为：<br>$n\quad V_1\quad V_2⋯ V_​n$</p><p>其中 n 是回路中的顶点数，$V_i$是路径上的顶点编号。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对每条待检回路，如果是汉密尔顿回路，就在一行中输出”YES”，否则输出”NO”。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><blockquote><p>6 10<br>6 2<br>3 4<br>1 5<br>2 5<br>3 1<br>4 1<br>1 6<br>6 3<br>1 2<br>4 5<br>6<br>7 5 1 4 3 6 2 5<br>6 5 1 4 3 6 2<br>9 6 2 1 6 3 4 5 2 6<br>4 1 2 5 1<br>7 6 1 3 4 5 2 6<br>7 6 1 2 5 4 3 1</p></blockquote><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><blockquote><p>YES<br>NO<br>NO<br>NO<br>YES<br>NO</p></blockquote><p><br><br>思路：<br>将边用数组存储起来，判断回路里两条边之前是否连通并且除出发点外其余点只出现一次。如果给定的回路里点的个数不等于n+1，直接NO<br><br></p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;#define N 205int edge[N][N];int main(){    int n,m,x,y;    cin &gt;&gt; n &gt;&gt; m;    memset(edge,0,sizeof(edge));    for(int i=0;i&lt;m;i++){        cin &gt;&gt; x &gt;&gt; y;        edge[x][y] = 1;        edge[y][x] = 1;    }    int t,vis[n+1];    memset(vis,0,sizeof(vis));    cin &gt;&gt; t;    while(t--){        int cnt,pre,flag=1,start;        cin &gt;&gt; cnt;        cin &gt;&gt; start; vis[start]=1;pre = start;        for(int j=1;j&lt;cnt;j++){            cin &gt;&gt; x;            if(!edge[pre][x]) flag = 0;            // 判定条件要注意            if(vis[x]&amp;&amp;(j&lt;cnt-1||x!=start)) flag = 0;//            if(vis[x]&amp;&amp;x!=start||!edge[pre][x]) flag = 0;            vis[x]=1;            pre = x;        }        if(cnt!=n+1) flag = 0;        if(flag) cout&lt;&lt; &quot;YES&quot; &lt;&lt; endl;        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        memset(vis,0,sizeof(vis));    }     return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
      <category term="Hamilton回路" scheme="https://sinclaircoder.top/tags/Hamilton%E5%9B%9E%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>PTA打印学生选课清单(哈希表)</title>
    <link href="https://sinclaircoder.top/2020/01/18/2020-01-18-pta-da-yin-xue-sheng-xuan-ke-qing-dan-ha-xi-biao/"/>
    <id>https://sinclaircoder.top/2020/01/18/2020-01-18-pta-da-yin-xue-sheng-xuan-ke-qing-dan-ha-xi-biao/</id>
    <published>2020-01-17T16:00:00.000Z</published>
    <updated>2020-01-22T04:30:51.009Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>假设全校有最多40000名学生和最多2500门课程。现给出每门课的选课学生名单，要求输出每个前来查询的学生的选课清单。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入的第一行是两个正整数：N（≤40000），为前来查询课表的学生总数；K（≤2500），为总课程数。此后顺序给出课程1到K的选课学生名单。格式为：对每一门课，首先在一行中输出课程编号（简单起见，课程从1到K编号）和选课学生总数（之间用空格分隔），之后在第二行给出学生名单，相邻两个学生名字用1个空格分隔。学生姓名由3个大写英文字母+1位数字组成。选课信息之后，在一行内给出了N个前来查询课表的学生的名字，相邻两个学生名字用1个空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>对每位前来查询课表的学生，首先输出其名字，随后在同一行中输出一个正整数C，代表该生所选的课程门数，随后按递增顺序输出C个课程的编号。相邻数据用1个空格分隔，注意行末不能输出多余空格。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><blockquote><p>10 5<br>1 4<br>ANN0 BOB5 JAY9 LOR6<br>2 7<br>ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6<br>3 1<br>BOB5<br>4 7<br>BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1<br>5 9<br>AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1<br>ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6</p></blockquote><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><blockquote><p>ZOE1 2 4 5<br>ANN0 3 1 2 5<br>BOB5 5 1 2 3 4 5<br>JOE4 1 2<br>JAY9 4 1 2 4 5<br>FRA8 3 2 4 5<br>DON2 2 4 5<br>AMY7 1 5<br>KAT3 3 2 4 5<br>LOR6 4 1 2 4 5</p></blockquote><p><br><br>思路：<br>哈希表的应用，根据名字生成索引，然后将课程号记录。不过要注意，需要使用scanf输入，不能使用cin，否则会超时。</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;#define N 102int hashfun(char s[5]){    return (s[3]-&#39;0&#39;)+(s[2]-&#39;A&#39;)*10+(s[1]-&#39;A&#39;)*260+(s[0]-&#39;A&#39;)*26*260;}vector&lt;int&gt; course[26*26*26*11];int main(){    int n,k,index,cnt;    cin &gt;&gt; n &gt;&gt; k;    char name[5];    for(int i=0;i&lt;k;i++){        scanf(&quot;%d%d&quot;,&amp;index,&amp;cnt);//        cin &gt;&gt; index &gt;&gt; cnt;        for(int j=0;j&lt;cnt;j++){            scanf(&quot;%s&quot;,name);//            cin &gt;&gt; name;            int h = hashfun(name);            course[h].push_back(index);        }    }    for(int i=0;i&lt;n;i++){        scanf(&quot;%s&quot;,name);//        cin &gt;&gt; name;        int h = hashfun(name);        cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; course[h].size();        if(course[h].size()) {            // 谁能想到还要排序..             sort(course[h].begin(),course[h].end());            for(int j=0;j&lt;course[h].size();j++){                cout &lt;&lt; &quot; &quot; &lt;&lt; course[h][j];            }        }        cout &lt;&lt; endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
      <category term="哈希表" scheme="https://sinclaircoder.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>PTA列车调度</title>
    <link href="https://sinclaircoder.top/2020/01/17/2020-01-17-pta-lie-che-diao-du/"/>
    <id>https://sinclaircoder.top/2020/01/17/2020-01-17-pta-lie-che-diao-du/</id>
    <published>2020-01-16T16:00:00.000Z</published>
    <updated>2020-01-22T04:30:45.342Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有N条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？</p><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入第一行给出一个整数N ($2 ≤ N ≤10^5$​​ )，下一行给出从1到N的整数序号的一个重排列。数字间以空格分隔。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><blockquote><p>9<br>8 4 2 5 3 9 1 6 7</p><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>4</p></blockquote><p>样例解释：<br>样例中的四条轨道如下：<br>第一条：2 4 8<br>第二条：1 3 5<br>第三条：6 9<br>第四条：7<br>利用stl中的set自动排序的特性，每次查找大于当前值的数，如果有就用当前值替换，没有就插入，最后集合的大小便为结果。</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;#define N 1000002int main(){    int n,num;    cin &gt;&gt; n;    set&lt;int&gt; s;    set&lt;int&gt;::iterator it;    for(int i=0;i&lt;n;i++){        cin &gt;&gt; num;        it = s.upper_bound(num);        if(it!=s.end()){            s.erase(it);        }        s.insert(num);    }    cout &lt;&lt; s.size();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>PTA求前缀表达式的值</title>
    <link href="https://sinclaircoder.top/2020/01/16/2020-01-16-pta-qiu-qian-zhui-biao-da-shi-de-zhi/"/>
    <id>https://sinclaircoder.top/2020/01/16/2020-01-16-pta-qiu-qian-zhui-biao-da-shi-de-zhi/</id>
    <published>2020-01-15T16:00:00.000Z</published>
    <updated>2020-01-22T04:30:58.324Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3<em>(7-4)+8/4的前缀表达式是：+ + 2 </em> 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><pre><code>+ + 2 * 3 - 7 4 / 8 4</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><p>13.0</p><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>参考：<a href="https://www.cnblogs.com/KeepZ/p/11563413.html" target="_blank" rel="noopener">【表达式转换 (25 分)】</a><br>上面这篇文章写的很清楚，思路很清晰<br>当栈为空或者栈顶运算符的优先级小于当前二元运算符的优先级时，将该二元运算符导入。<br>倘若栈顶运算符的优先级大于或等于当前二元运算符的优先级，又分为以下两种情况，1.若栈顶运算符为（ 符号，则直接将该运算符插入即可； 2.若栈顶运算符不是（ 符号，则优先输出栈内的元素,直到碰到（ 符号或者栈为空，然后将当前二元运算符插入。</p><h2 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h2><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;#define N 205int main(){    string s;    cin &gt;&gt; s;    stack&lt;char&gt; st;    map&lt;char,int&gt; mp;    mp[&#39;+&#39;]=1;mp[&#39;-&#39;]=1;    mp[&#39;*&#39;]=2;mp[&#39;/&#39;]=2;    mp[&#39;(&#39;]=3;mp[&#39;)&#39;]=3;    int len = s.length(),first = 1;    for(int i=0;i&lt;len;i++){        if((i==0||i&amp;s[i-1]==&#39;(&#39;)&amp;&amp;(s[i]==&#39;+&#39;||s[i]==&#39;-&#39;)){            if(!first) cout &lt;&lt; &quot; &quot;;            // 正负号处理             if(s[i]==&#39;-&#39;) cout &lt;&lt; &quot;-&quot;;            while(i+1&lt;len&amp;&amp;s[i+1]&gt;=&#39;0&#39;&amp;&amp;s[i+1]&lt;=&#39;9&#39;||s[i+1]==&#39;.&#39;){                i++;                cout &lt;&lt; s[i];            }            first = 0;        }        else if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;){            if(!first) cout &lt;&lt; &quot; &quot;;            printf(&quot;%c&quot;,s[i]);            while(i+1&lt;len&amp;&amp;s[i+1]&gt;=&#39;0&#39;&amp;&amp;s[i+1]&lt;=&#39;9&#39;||s[i+1]==&#39;.&#39;){                i++;                cout &lt;&lt; s[i];            }            first = 0;        }        else if(s[i]==&#39;)&#39;) {            while(!st.empty()&amp;&amp;st.top()!=&#39;(&#39;){                printf(&quot; %c&quot;,st.top());                st.pop();            }            if(st.top()==&#39;(&#39;) st.pop();        }        else if(st.empty()||mp[s[i]]&gt;mp[st.top()]){            st.push(s[i]);        }        else {            while(!st.empty()&amp;&amp;st.top()!=&#39;(&#39;){                printf(&quot; %c&quot;,st.top());                st.pop();            }            st.push(s[i]);        }    }    while(!st.empty()){        printf(&quot; %c&quot;,st.top());        st.pop();    }    return 0;}</code></pre><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>前缀表达式求值步骤：</p><ul><li>从右向左扫描表达式</li><li>遇到数字压入栈中</li><li>遇到运算符，弹出栈顶两个数，并进行计算，将结果入栈</li><li>重复上述2、3步骤，直到表达式最左端，最后的值即为表达式结果</li></ul><h2 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h2><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;#define N 1000002int main(){    string s;    getline(cin,s);    stack&lt;double&gt; st;    int len = s.length();    double num1,num2,cnt=10;    for(int i=len-1;i&gt;=0;i--){        if(s[i]==&#39; &#39;) continue;        else if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;||s[i]==&#39;.&#39;){            double tmp = s[i]-&#39;0&#39;;            while(i&gt;=1&amp;&amp;(s[i-1]&gt;=&#39;0&#39;&amp;&amp;s[i-1]&lt;=&#39;9&#39;||s[i-1]==&#39;.&#39;||s[i-1]==&#39;-&#39;||s[i-1]==&#39;+&#39;)){                i--;                if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;){                        tmp += (s[i]-&#39;0&#39;)*cnt;                            cnt *= 10.0;                }else if(s[i]==&#39;.&#39;){                    tmp /= cnt;                    cnt = 1;                }else if(s[i]==&#39;-&#39;){                    tmp = -1*tmp;                }            }            st.push(tmp);        }        else {            num1 = st.top();st.pop();            num2 = st.top();st.pop();            switch(s[i]){                case &#39;+&#39;: num1 += num2;break;                case &#39;-&#39;: num1 -= num2;break;                case &#39;*&#39;: num1 *= num2;break;                case &#39;/&#39;: if(num2==0){cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl;exit(0);}                          else num1 /= num2;break;            }            st.push(num1);        }    }        printf(&quot;%.1lf&quot;,st.top());    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="字符串" scheme="https://sinclaircoder.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
      <category term="前缀表达式" scheme="https://sinclaircoder.top/tags/%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《大数据智能》阅读笔记</title>
    <link href="https://sinclaircoder.top/2020/01/15/2020-01-15-da-shu-ju-zhi-neng-yue-du-bi-ji/"/>
    <id>https://sinclaircoder.top/2020/01/15/2020-01-15-da-shu-ju-zhi-neng-yue-du-bi-ji/</id>
    <published>2020-01-14T16:00:00.000Z</published>
    <updated>2020-01-22T04:31:10.867Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>博观而约取，厚积而薄发。                            　　　　　　　　　　——-苏轼</p></blockquote><p>尽管书的名字是《大数据智能》，实则内容则是互联网时代的机器学习和自然语言处理技术的综述。对于nlper，读一读受益匪浅。抑或是仅仅当科普读物一读，也未尝不可。</p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><h3 id="应用分类"><a href="#应用分类" class="headerlink" title="应用分类"></a>应用分类</h3><ul><li>垃圾邮件过滤</li><li>图像分类</li></ul><h3 id="结构分类"><a href="#结构分类" class="headerlink" title="结构分类"></a>结构分类</h3><ul><li>句法分析</li><li>情感分析</li><li>机器翻译</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>语言模型也是一个特殊的回归任务</li></ul><h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><ul><li>大规模知识库</li><li>互联网链接数据</li><li>互联网网页文本数据</li><li><p>多数据源的知识融合</p><ul><li>实体融合</li><li>关系融合</li><li>实例融合</li></ul></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>理解查询</li><li><p>自动问答</p><ul><li>下一代的搜索引擎能直接回大人们提出的问题</li></ul></li><li><p>文档表示</p><ul><li>最简单的方案：将文档表示为基于知识图谱的一个子图，即用改文档中出现或涉及的实体及其关系所构成的图表示该文档</li></ul></li></ul><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><ul><li><p>实体链指</p><p>将互联网网页与实体之间建立链接关系。并不局限于实体与文本之间</p><ul><li><p>实体识别</p><ul><li>从文本中发现实体</li></ul></li><li><p>实体消歧</p></li></ul></li><li><p>关系抽取</p><p>从互联网网页文本中抽取实体</p></li><li><p>知识推理</p></li><li>知识表示：基础技术</li></ul><h3 id="前景与挑战"><a href="#前景与挑战" class="headerlink" title="前景与挑战"></a>前景与挑战</h3><ul><li>知识的类型与表示</li><li>知识获取</li><li>知识融合</li><li>知识应用</li></ul><h2 id="大数据系统"><a href="#大数据系统" class="headerlink" title="大数据系统"></a>大数据系统</h2><h3 id="高性能计算技术"><a href="#高性能计算技术" class="headerlink" title="高性能计算技术"></a>高性能计算技术</h3><ul><li><p>超级计算机</p><ul><li>计算节点</li><li>存储节点</li><li>管理节点</li></ul></li><li><p>并行计算的系统支持</p><ul><li><p>常见并行编程组件</p><ul><li>Pthreads</li><li>OpenMP</li><li>xdfc</li></ul></li></ul></li></ul><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><ul><li>虚拟化技术是指创建虚拟的事物，包括计算机硬件平台、操作系统、存储设备、计算机网络，是云计算的支撑技术</li></ul><h3 id="云计算技术"><a href="#云计算技术" class="headerlink" title="云计算技术"></a>云计算技术</h3><ul><li>美国国家标准技术研究所认为：云计算是通过网络使得一组可配置的计算资源（网络、计算机、存储、应用程序、服务等）能够在任何地点方便地、按需地进行访问的模型，资源的提供和释放可以快速完成，管理开销低，与提供商的交互简便易行</li><li><p>三种服务模型</p><ul><li><p>软件即服务 Software as a Service SaaS</p><ul><li>常见的有亚马逊的AWS、微软的Azure、阿里云</li></ul></li><li><p>平台即服务 Platform as a Service PaaS</p><ul><li>常见的有Google App Engine（GAE）、新浪App Engine、RedHat的OpenShift等</li><li>GAE给开发者提供了包括Python、Java、Go、php等多种语言的开发和运行环境，用于编写Web应用程序，开发者只需专注于应用程序的功能实现，部署到GAE后，应用程序的性能将由平台来保证</li></ul></li><li><p>基础架构即服务 Infrastructure as a Service IaaS</p></li></ul></li><li><p>根据受众进行分类</p><ul><li>私有云</li><li>社区云</li><li>公有云</li><li>混合云</li></ul></li><li><p>常见的云服务</p><ul><li>Elastic Compute Cloud（EC2）虚拟云主机服务</li><li>Simple Storage Service（S3）基于Web服务的存储</li><li>Elastic Block Store（EBS）为EC2提供的持久化块存储</li><li>DynamoDB 可扩展、可延迟的NoSQL数据库服务</li><li>Relational Database Service（RDS）关系型数据库服务</li><li>Route53 高可靠的域名系统服务（DNS）服务</li><li>CloudFront 内容分发服务</li><li>Elastic MapReduce (EMR) 在EC2和S3的基础上用Hadoop搭建的MapReduce</li></ul></li></ul><h3 id="基于分布式计算的大数据系统"><a href="#基于分布式计算的大数据系统" class="headerlink" title="基于分布式计算的大数据系统"></a>基于分布式计算的大数据系统</h3><ul><li><p>Hadoop生态系统</p><ul><li><p>HDFS（Hadoop Distributed File System）</p><ul><li>分布式文件系统，将文件按一定大小切块，然后把每个块以多个副本的形式保存在不同的数据节点上</li></ul></li><li><p>YARN（Yet Another Resource Negotiator）</p><ul><li>Hadoop的计算资源管理和调度系统，接受任务请求，并根据请求的需要来分配资源，调度任务的执行。</li></ul></li><li><p>MapReduce</p><ul><li>Google提出的并行程序编程模型，适合对数据进行统计、分类等处理</li></ul></li><li><p>HBase</p><ul><li>基于列的分布式存储，数据以表的形式组织，每个表可以有很多行，每行可以有若干列簇，每个列簇可以包含多个列</li><li>HBase可作为数据仓库存储有一定结构的海量数据，数据可以发生修改，但不要很频繁，否则会影响效率</li></ul></li><li><p>Hive、Pig</p><ul><li>能够让用户用较为简便的方式来查询保存在HDFS或HBase中的数据</li></ul></li><li><p>ZooKeeper</p><ul><li>提供了编写分布式软件所需的常用工具</li></ul></li><li><p>Tez</p><ul><li>比MapReduce更一般化的数据流编程框架</li></ul></li><li><p>Storm、S4</p><ul><li>建立在Hadoop上的流式处理引擎</li></ul></li><li><p>Mahout</p><ul><li>Hadoop实现的机器学习算法库，包括聚类、分类、推荐以及线性代数常用的算法</li><li>新版本的Mapout主要用一种支持线性代数操作的领域特定语言（Domain Specific Language DSL）来实现</li></ul></li><li><p>Giraph</p><ul><li>在Hadoop上实现了类似于Google的Pregel这样的图计算引擎，用于处理Web链接关系图、社交网络等类型的数据</li></ul></li><li><p>Sqoop</p><ul><li>一个命令行工具，用于在Hadoop和传统的关系型数据库之间传输数据</li></ul></li><li><p>三种安装模式</p><ul><li>单机模式</li><li>伪分布模式</li><li>全分布模式</li></ul></li></ul></li><li><p>Spark</p><ul><li>设计核心：一种叫做可靠分布式数据集（Resilient Distributed Dataset，RDD）的数据结构</li><li>Spark SQL</li><li><p>Spark Streaming</p><ul><li>提供流式处理的功能</li></ul></li><li><p>MLlib</p><ul><li>机器学习算法库</li></ul></li><li><p>GraphX</p><ul><li>Spark的图计算框架</li></ul></li></ul></li><li><p>典型的大数据基础架构</p><ul><li>GFS</li><li>Cosmos</li><li>SCOPE</li></ul></li></ul><h3 id="大规模图计算"><a href="#大规模图计算" class="headerlink" title="大规模图计算"></a>大规模图计算</h3><ul><li><p>分布式图计算框架</p><ul><li>Pregel</li><li>GraphLab</li></ul></li><li><p>高效的单机图计算框架</p><ul><li>GraphChi</li><li>X-Stream</li><li>GridGraph</li></ul></li></ul><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><ul><li><p>分类</p><ul><li><p>基于列的存储</p><ul><li>常见的有HBase</li></ul></li><li><p>基于文档的存储</p><ul><li>常见的有MongoDB、CouchDB</li></ul></li><li><p>键值对存储</p><ul><li><p>单机内存型</p><ul><li>数据持久化在磁盘上，强调单机读写性能，数据一般按照键排序</li><li>常见的有Berkeley DB、LevelDB</li></ul></li><li><p>单机内存型</p><ul><li>数据主要存放在内存中，一般用作数据的缓存</li><li>常见的有memcached、redis</li></ul></li><li><p>分布式</p><ul><li>数据经划分后存放在不同的机器上，同一项数据可以在不同的机器上存有副本</li><li>常见的有Dynamo、Riak</li></ul></li></ul></li><li><p>图数据库</p><ul><li>数据以图的形式组织，数据项是图中的顶点，每个顶点可以带属性，数据项之间的联系用边来表示，边上也可以带属性</li><li>常见的有Neo4j</li></ul></li><li><p>多模型</p><ul><li>同时支持上述若干模型，例如OrientDB、ArangoDB</li></ul></li></ul></li><li><p>NoSQL的理解</p><ul><li>一开始是No SQL 后来添加了对SQL的部分支持，变为Not only SQL</li></ul></li><li><p>MongoDB</p><ul><li>基于文档的存储，数据以文档为单位组织</li><li>存储的数据分为数据库、集合和文档三级，一个数据库可以包含若干集合，而一个集合可以包含若干个文档</li><li>文档在表达上采用JSON格式</li><li>基本操作包括文档的插入、更新、删除和查询，另外还可以单独对文档的某个属性进行修改，还可以进行增加、倍增这样的原子操作</li><li>可以单机使用也可以在分布式的环境中使用</li><li>还具有一定的数据分析能力，可以对数据进行统计</li></ul></li></ul><h2 id="智能问答"><a href="#智能问答" class="headerlink" title="智能问答"></a>智能问答</h2><h3 id="问答技术对于用户提出的问题予以理解，并找到答案回答给用户。经典案例：Siri等，人工智能的一个重要分支：专家系统"><a href="#问答技术对于用户提出的问题予以理解，并找到答案回答给用户。经典案例：Siri等，人工智能的一个重要分支：专家系统" class="headerlink" title="问答技术对于用户提出的问题予以理解，并找到答案回答给用户。经典案例：Siri等，人工智能的一个重要分支：专家系统"></a>问答技术对于用户提出的问题予以理解，并找到答案回答给用户。经典案例：Siri等，人工智能的一个重要分支：专家系统</h3><h3 id="问答系统的输入部分即问题更不容易被计算机理解，输出部分需要更准确，此外答案的来源更加——即知识也多种多样，既有结构化的信息也有非结构化的信息，因此问答系统的难度更大"><a href="#问答系统的输入部分即问题更不容易被计算机理解，输出部分需要更准确，此外答案的来源更加——即知识也多种多样，既有结构化的信息也有非结构化的信息，因此问答系统的难度更大" class="headerlink" title="问答系统的输入部分即问题更不容易被计算机理解，输出部分需要更准确，此外答案的来源更加——即知识也多种多样，既有结构化的信息也有非结构化的信息，因此问答系统的难度更大"></a>问答系统的输入部分即问题更不容易被计算机理解，输出部分需要更准确，此外答案的来源更加——即知识也多种多样，既有结构化的信息也有非结构化的信息，因此问答系统的难度更大</h3><h3 id="问答系统的组成"><a href="#问答系统的组成" class="headerlink" title="问答系统的组成"></a>问答系统的组成</h3><ul><li><p>问题理解</p><ul><li>理解问题是什么，比如北京的温度是多少和太阳的温度是多少根本不是一个领域的问题</li></ul></li><li><p>知识检索</p></li><li>答案生成</li></ul><h3 id="文本问答系统"><a href="#文本问答系统" class="headerlink" title="文本问答系统"></a>文本问答系统</h3><ul><li>最基本的一类问答系统</li><li><p>问题理解</p><ul><li><p>问题理解的内容</p><ul><li>常见分类体系：UIUC体系、Moldovan等人的分类体系、单层的平面分类和根据垂直领域的分类</li></ul></li><li><p>问题理解的方法</p><ul><li>最直观的方法：模板匹配策略。优点在于逻辑清晰可见，易于理解和编写，缺点在于形式固定，对于千变万化的自然语言不容易灵活适应</li><li>灵活的技术则要从词法、句法的分析入手，做词性标注，做句法分析，找出命名实体。</li></ul></li><li><p>问题扩展</p><ul><li>同义词造成的多样性</li><li>在词的级别上，可以借助《同义词词林》、知网（HowNet），这样的同义词词典及词语知识图谱可以扩展我们的词库</li></ul></li></ul></li><li><p>知识检索</p><ul><li><p>非结构化信息检索</p><ul><li>非结构化的信息，通常是指没有或很少标注的整篇文章组成的集合</li><li>最直观的理解便是使用搜索引擎，提取出问题的关键词，查询索引，找出与这些关键词相关的文档，最后经过筛选和提取步骤，生成最终答案</li><li>在挑选出的多篇文档的多个段落中，也需要找出更可能包含答案的段落或局部段落，也因此要对这些文本块排序</li><li>问答系统中的经典做法是采用标准基数排序，排序指标的常见的三个因素：相同顺序的关键词数目、最远关键词间距和未命中关键词数</li></ul></li><li><p>结构化知识检索</p><ul><li>主要侧重于一个实体的各个属性以及他们之间的关系</li><li><p>结构化知识分类</p><ul><li>百科类知识</li><li>关系类知识</li></ul></li></ul></li></ul></li><li><p>答案生成</p><ul><li>可以考虑答案与问题的相似程度，如问题的关键词和答案词之间语义联系的远近，此外，答案与问题也可能存在句式的联系</li></ul></li></ul><h3 id="社区问答系统"><a href="#社区问答系统" class="headerlink" title="社区问答系统"></a>社区问答系统</h3><ul><li>一些比较著名的有国外的Quora和国内的知乎、百度知道和搜狗问问等</li><li><p>社区问答系统的结构</p><ul><li>问题理解</li><li>答案生成</li></ul></li><li><p>相似问题检索</p><ul><li>一般的问答系统是用问题检索，而社区问答中是用问题去找问题。问题的相似性问题与问题扩展所解决的问题是类似 的，同样需要词义的扩展、句式的扩展。</li><li><p>问题相似性度量的几种方式</p><ul><li>模板匹配</li><li>基于统计机器翻译</li><li><p>基于词典的方法</p><ul><li>主要是基于同近义词的知识来扩展关键词，从而识别相似问句</li></ul></li><li><p>基于信息距离</p><ul><li>可以借助信息论中的柯尔莫哥洛夫复杂性来定义一系列语义度量，来衡量两个问题语义的相似性</li></ul></li></ul></li></ul></li><li><p>答案过滤</p><ul><li>根据答案提供者的权威性选择答案</li><li>根据答案内容本身评估质量</li></ul></li></ul><h3 id="多媒体问答系统（Multimedia-Question-Answering）"><a href="#多媒体问答系统（Multimedia-Question-Answering）" class="headerlink" title="多媒体问答系统（Multimedia Question Answering）"></a>多媒体问答系统（Multimedia Question Answering）</h3><ul><li>问答的内容不仅仅限于纯文本内容，多媒体内容的表现力更强、更直观，易于理解</li><li>需要计算机视觉、信号处理等多媒体技术，才能分析出多媒体所表达的内容，属于比较前沿的课题</li></ul><h3 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h3><ul><li>对话系统比问答系统更难，问答系统涉及的技术较多，既包含语义分析，又有信息检索，还涉及到知识的挖掘与管理，若想成为全才，必须在方方面面都下功夫</li></ul><h2 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h2><h3 id="基本任务"><a href="#基本任务" class="headerlink" title="基本任务"></a>基本任务</h3><ul><li>文档分类</li><li>文档摘要</li><li>关键词抽取</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="阅读笔记" scheme="https://sinclaircoder.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前沿科普" scheme="https://sinclaircoder.top/tags/%E5%89%8D%E6%B2%BF%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>PTA整数分解为若干项之和</title>
    <link href="https://sinclaircoder.top/2020/01/04/2020-01-04-pta-zheng-shu-fen-jie-wei-ruo-gan-xiang-zhi-he/"/>
    <id>https://sinclaircoder.top/2020/01/04/2020-01-04-pta-zheng-shu-fen-jie-wei-ruo-gan-xiang-zhi-he/</id>
    <published>2020-01-03T16:00:00.000Z</published>
    <updated>2020-01-22T04:17:19.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如7=6+1，7=5+2，7=5+1+1，…。编程求出正整数N的所有整数分解式子。</p><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个输入包含一个测试用例，即正整数N (0&lt;N≤30)。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>按递增顺序输出N的所有整数分解式子。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。</p><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><blockquote><p>7</p></blockquote><h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><blockquote><p>7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+2<br>7=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+2<br>7=1+2+4;7=1+3+3;7=1+6;7=2+2+3<br>7=2+5;7=3+4;7=7</p></blockquote><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;map&gt;using namespace std;#define rep(i,m,n) for(int i=m;i&lt;n;i++)#define rep1(i,m,n) for(int i=m;i&gt;=n;i--)int res[1000];int n,pos,sum,cnt;void dfs(int x){    if(sum==n){        cnt++;        cout &lt;&lt; n &lt;&lt; &quot;=&quot; &lt;&lt; res[0];        for(int i=1;i&lt;pos;i++){            if(res[i])            cout &lt;&lt; &quot;+&quot; &lt;&lt; res[i];        }        // 每四个一换行，当到了最后一个也要换行，不能输出分号        if(cnt%4==0&amp;&amp;cnt||res[pos-1]==n) cout &lt;&lt; endl;        else cout &lt;&lt; &quot;;&quot;;        return ;    }    else if(sum&gt;n) return ;    for(int i=x;i&lt;=n;i++){        res[pos++] = i;        sum += i;        dfs(i);        sum -= i;        pos--;    }}int main(){    cin &gt;&gt; n;    dfs(1);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="DFS" scheme="https://sinclaircoder.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>PTA切分表达式——写个tokenizer吧</title>
    <link href="https://sinclaircoder.top/2020/01/01/2020-01-16-pta-qie-fen-biao-da-shi-xie-ge-tokenizer-ba/"/>
    <id>https://sinclaircoder.top/2020/01/01/2020-01-16-pta-qie-fen-biao-da-shi-xie-ge-tokenizer-ba/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-01-22T04:31:05.514Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="先说点出题背景"><a href="#先说点出题背景" class="headerlink" title="[先说点出题背景]"></a>[先说点出题背景]</h2><p>这个题是为低年级同学、学C语言的同学准备的，因为，对这部分同学，这个题目编写起来略有一点复杂。如果是高年级、学过了正则表达式（Regular Expression）的同学或者学过了Java等OO语言的同学做这个题，应当发现这题比较简单吧。哦，对了，什么是tokenizer？请自行查询解决。反正在此处不应翻译成“令牌解析器”。</p><h2 id="正题"><a href="#正题" class="headerlink" title="[正题]"></a>[正题]</h2><p>四则运算表达式由运算数（必定包含数字，可能包含正或负符号、小数点）、运算符（包括+、-、*、/）以及小括号（(和)）组成，每个运算数、运算符和括号都是一个token（标记）。现在，对于给定的一个四则运算表达式，请把她的每个token切分出来。题目保证给定的表达式是正确的，不需要做有效性检查。<br>输入格式:<br>在一行中给出长度不超过40个字符的表达式，其中没有空格，仅由上文中token的字符组成</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>依次输出表达式中的tokens，每个token占一行。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><blockquote><p>32*((2-2)+5)/(-15)   </p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><p>```<br>32<br>*<br>(<br>(<br>2<br>-<br>2<br>)<br>+<br>5<br>)<br>/<br>(<br>-15<br>)</p></blockquote><pre><code>## 实现```cpp#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;list&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;#define N 205int main(){    char s[N],ch;    int flag = 0;    scanf(&quot;%s&quot;,s);    printf(&quot;%c&quot;,s[0]);    for(int i=1;i&lt;strlen(s);i++){        if(s[i]&gt;=&#39;0&#39;&amp;&amp;s[i]&lt;=&#39;9&#39;||s[i]==&#39;.&#39;){            if(flag)  cout &lt;&lt; endl;            printf(&quot;%c&quot;,s[i]);            flag = 0;        }        else {            if(s[i-1]==&#39;(&#39;&amp;&amp;s[i]==&#39;-&#39;){                printf(&quot;\n%c&quot;,s[i]);                flag = 0;            }            else {                printf(&quot;\n%c&quot;,s[i]);                flag = 1;            }        }    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="PTA" scheme="https://sinclaircoder.top/categories/PTA/"/>
    
    
      <category term="字符串" scheme="https://sinclaircoder.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="PTA" scheme="https://sinclaircoder.top/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>2019蓝桥杯校内选拔赛题解</title>
    <link href="https://sinclaircoder.top/2019/12/10/2019-12-10-2019-lan-qiao-bei-xiao-nei-xuan-ba-sai-ti-jie/"/>
    <id>https://sinclaircoder.top/2019/12/10/2019-12-10-2019-lan-qiao-bei-xiao-nei-xuan-ba-sai-ti-jie/</id>
    <published>2019-12-09T16:00:00.000Z</published>
    <updated>2020-01-22T04:14:08.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目传送"><a href="#题目传送" class="headerlink" title="题目传送"></a><a href="https://witacm.com/contest_problemset.php?cid=1046" target="_blank" rel="noopener">题目传送</a></h1><h2 id="A-Perfect"><a href="#A-Perfect" class="headerlink" title="A Perfect"></a>A Perfect</h2><p>略</p><h2 id="B-Common-Easy-Version"><a href="#B-Common-Easy-Version" class="headerlink" title="B Common(Easy Version)"></a>B Common(Easy Version)</h2><p>详见<a href="https://blog.csdn.net/SinclairWang/article/details/103428852" target="_blank" rel="noopener">Common(Easy、Middle 、Hard)</a></p><h2 id="C-Common-Hard-Version"><a href="#C-Common-Hard-Version" class="headerlink" title="C Common(Hard Version)"></a>C Common(Hard Version)</h2><p>详见<a href="https://blog.csdn.net/SinclairWang/article/details/103428852" target="_blank" rel="noopener">Common(Easy、Middle 、Hard)</a></p><h2 id="D-Treasure"><a href="#D-Treasure" class="headerlink" title="D Treasure"></a>D Treasure</h2><p>有一个 n 行 m 列的迷宫， 行数从上到下为 1 到 n, 列数从左到右为 1 到 m, 入口为 (1,1),<br>Reverie只能向上下左右四个方向行走。迷宫中有若干个宝箱。Reverie想知道，最少需要走多少步，才能找到一个宝箱。</p><p>第一行两个正整数 n, m, 表示迷宫的行数和列数。<br>之后 n 行，每行 m 个字符, ‘.’ 表示该位置是空地, ‘*’ 表示该位置是障碍, ‘#’ 表示该位置有一个宝箱。<br>保证点 (1,1) 是空地，宝箱所在的格子可以通过。<br>$1≤n,m≤1000$<br>一行内输出一个整数表示答案，如果没有宝箱或者所有宝箱位置均不可达，输出 -1.</p><p>BFS</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define mp make_pair#define pb push_backll gcd(ll a,ll b) { return !b?a:gcd(b,a%b);}ll lcm(ll a,ll b){ return a/gcd(a,b)*b;}int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};int cnt = 0;int r[1000+5][1000+5];bool visited[1000+5][1000+5];int res[1000+5][1000+5];bool bfs(int i,int j){    queue&lt;pair&lt;int,int &gt; &gt; q;    q.push(mp(i,j));visited[i][j] = 1;    pair&lt;int,int&gt; t;    while(!q.empty()){        t = q.front();        i = t.first; j = t.second;        q.pop();        for(int k=0;k&lt;4;k++){            int cx = i+dx[k],cy = j+dy[k];            if(r[cx][cy]&amp;&amp;!visited[cx][cy]){                cnt = res[i][j]+1;                res[cx][cy] = cnt;                visited[cx][cy]=1;                if(r[cx][cy]==2) return true;                else q.push(mp(cx,cy));            }        }    }    return false;}int main(){    int n,m;    cin &gt;&gt; n &gt;&gt; m;    memset(visited,0,sizeof(visited));    memset(r,0,sizeof(r));    char c;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++){            cin &gt;&gt; c;            if(c==&#39;.&#39;) r[i][j] = 1;            else if(c==&#39;#&#39;) r[i][j] = 2;        }            if(bfs(1,1)) cout &lt;&lt; cnt &lt;&lt; endl;    else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;    return 0;}</code></pre><h2 id="E-Select"><a href="#E-Select" class="headerlink" title="E  Select"></a>E  Select</h2><p>$Reverie有一个长度为 n 的正整数数组 A, 她想从中挑出一些数字，$<br>$使得这些数字的和最大，选中的任意两个数字在原数组中不能相邻。$</p><p>$第一行一个正整数 T, 代表测试的组数。$<br>$每组测试第一行一个正整数 n 表示数组的大小，第二行 n 个正整数表示数组里的数，以空格分隔。$<br>$1≤T≤100$<br>$1≤n≤1000$<br>$1≤A_i≤1000$</p><p>状态转移方程：<br>$dp[0]=a[0],dp[1]=max(a[0],a[1])$<br>$dp[i]=max(dp[i-1],dp[i-2]+a[i])$</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(){    int T;    cin &gt;&gt; T;    while(T--){        int n;        cin &gt;&gt; n;        int a[n],dp[n+2];        memset(dp,0,sizeof(dp));        for(int i=0;i&lt;n;i++)            cin &gt;&gt; a[i];        dp[0] = a[0];        dp[1] = max(a[0],a[1]);        for(int i=2;i&lt;n;i++)            dp[i] = max(dp[i-2]+a[i],dp[i-1]);        cout &lt;&lt; dp[n-1] &lt;&lt; endl;    }     return 0;}</code></pre><h2 id="F-Swap-Easy-Vesion"><a href="#F-Swap-Easy-Vesion" class="headerlink" title="F Swap(Easy Vesion)"></a>F Swap(Easy Vesion)</h2><p>$Reverie有一个字符串，她每次操作可以交换其中任意相邻两个字符的位置。$<br>$Reveire想知道，把这个字符串变成字典序最小至少需要多少次操作。$<br>$第一行一个正整数 T, 代表测试的组数。$<br>$每组测试，一行内给出一个仅包含小写字母的字符串 s。$<br>$1≤T≤10$<br>$1≤∣s∣≤1000$</p><p>最小交换次数即逆序对数<br>下面使用两重循环暴力求解</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll res = 0 ; char a[1000005];int main(){    int t;    cin &gt;&gt; t;    getchar();    while(t--){        res = 0;        scanf(&quot;%s&quot;,a);        int n = strlen(a);         for(int i=0;i&lt;n;i++){            for(int j=0;j&lt;i;j++){                if(a[j]&gt;a[i]){                    res ++;                }            }        }        cout &lt;&lt; res &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="G-Swap-Hard-Vesion"><a href="#G-Swap-Hard-Vesion" class="headerlink" title="G Swap(Hard Vesion)"></a>G Swap(Hard Vesion)</h2><p>数据范围改变<br>$1≤T≤10$<br>$1≤∣s∣≤100000$<br>暴力不可行，会超时，使用归并排序求逆序对数</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;/*    归并排序求逆序对 */ ll res = 0 ; char a[1000005];char b[1000005];void merge(char a[],int low,int mid,int high){    int i = low,j = mid +1,k = 0;    while(i&lt;=mid&amp;&amp;j&lt;=high){        if((a[i]-&#39;a&#39;)&lt;=(a[j]-&#39;a&#39;))    b[k++] = a[i++];        else {            b[k++] = a[j++];            res += (mid-i+1);  // 是mid-i+1 而非j-i         }    }    while(i&lt;=mid){        b[k++] = a[i++];    }    while(j&lt;=high){        b[k++] = a[j++];    }    k = 0;    for(i=low;i&lt;=high;i++,k++){        a[i] = b[k];    }    }void merge_sort(char a[],int low, int high){    int mid;    if(low &lt; high){        mid = (low+high)/2;        merge_sort(a,low,mid);        merge_sort(a,mid+1,high);        merge(a,low,mid,high);    }}int main(){    int t;    cin &gt;&gt; t;    getchar();    while(t--){        res = 0;        scanf(&quot;%s&quot;,a);         merge_sort(a,0,strlen(a)-1);        cout &lt;&lt; res &lt;&lt; endl;    }    return 0;}</code></pre><h2 id="H-Operator"><a href="#H-Operator" class="headerlink" title="H Operator"></a>H Operator</h2><p>$Reverie有一个长度为n的整数数组A，她想在每两个数之间填入$<br>$‘+’ 或者 ‘-’, 使得最终运算结果尽可能接近给定的评估值 k.$</p><p>$Input$<br>$第一行一个正整数 T, 代表测试的组数。$<br>$每组测试，第一行两个整数 n, k 分别表示数组的大小和给定的评估值，$<br>$第二行 n 个正整数表示数组里的数，以空格分隔。$</p><p>$1≤T≤10$<br>$2≤n≤20$<br>$1≤k,A_i≤10^6$</p><p>$Output$<br>$每组测试，一行内输出一个整数表示运算结果与 k 的差值的绝对值的最小值。$</p><p>$Sample Input$</p><blockquote><p>2<br>3 7<br>3 6 9<br>4 6<br>1 2 3 4</p></blockquote><p>$Sample Output$</p><blockquote><p>1<br>0</p></blockquote><p>DFS即可</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll inf = 0x3f3f3f3f;const int maxn = 200;char best[maxn];void dfs(int a[],int n,int sum,int i,char op[],int tar){    if(i==n){        if(abs(sum-tar)&lt;abs(inf-tar)){            inf = sum;            for(int i=1;i&lt;n;i++)                best[i] = op[i];            }        return ;    }    sum += a[i];    op[i] = &#39;+&#39;;    dfs(a,n,sum,i+1,op,tar);    sum -= a[i];    sum -= a[i];    op[i] = &#39;-&#39;;    dfs(a,n,sum,i+1,op,tar);    sum += a[i];} int main(){    int t;    cin &gt;&gt; t;    getchar();    while(t--){        int n; cin &gt;&gt; n;        ll tar; cin &gt;&gt; tar;        int a[n];        for(int i=0;i&lt;n;i++)            cin &gt;&gt; a[i];        char op[n];        dfs(a,n,a[0],1,op,tar);        ll res = a[0];        for(int i=1;i&lt;n;i++){            if(best[i]==&#39;+&#39;)                res += a[i];            else if(best[i]==&#39;-&#39;)                res -= a[i];        }        cout &lt;&lt; abs(res-tar) &lt;&lt; endl;        inf = 0x3f3f3f3f;  // 记得修改inf的值     }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>Common (Easy、Middle 、Hard)</title>
    <link href="https://sinclaircoder.top/2019/12/06/2019-12-06-common-easy-middle-hard/"/>
    <id>https://sinclaircoder.top/2019/12/06/2019-12-06-common-easy-middle-hard/</id>
    <published>2019-12-05T16:00:00.000Z</published>
    <updated>2020-01-22T08:33:59.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道题</p><h1 id="Easy-Version"><a href="#Easy-Version" class="headerlink" title="Easy Version"></a>Easy Version</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$求区间 [l, r] 内是 a 或 b 的倍数的数的个数。$</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>$第一行一个正整数 T, 代表测试的组数。$<br>$之后 T 行，每行四个正整数 a, b, l, r, 以空格分隔，意义如题面所述。$<br>$1≤T≤100$<br>$1≤a,b≤10^5$<br>$1≤l≤r≤10^5$</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>$对于每组测试，一行内输出一个整数表示答案。$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><blockquote><p>3<br>2 3 1 100<br>4 6 1 100<br>5 10 1 100</p></blockquote><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><blockquote><p>67<br>33<br>20</p></blockquote><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int l,r,a,b;    int n;    cin &gt;&gt; n;    while(n--){        cin &gt;&gt; a &gt;&gt; b;        cin &gt;&gt; l &gt;&gt; r;        int res = 0;        for(int i=l;i&lt;=r;i++){            if(i%a==0||i%b==0) res ++;        }        cout &lt;&lt; res &lt;&lt; endl;        }    return 0;}</code></pre><h1 id="Middle-Version"><a href="#Middle-Version" class="headerlink" title="Middle Version"></a>Middle Version</h1><p>数据范围改变<br>$1≤T≤100$<br>$1≤a,b≤10^9$<br>$1≤l≤r≤10^9$<br>需要优化</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll gcd(ll a,ll b) { return !b?a:gcd(b,a%b);}ll lcm(ll a,ll b){ return a/gcd(a,b)*b;}int main(){    int n;    cin &gt;&gt; n;    while(n--){        ll a,b,l,r;        cin &gt;&gt; a &gt;&gt; b;        cin &gt;&gt; l &gt;&gt; r;        ll res = 0;        ll t = lcm(a,b);        res += r/a+r/b-r/t-(l/a+l/b-l/t);        if(l%a==0||l%b==0){            res ++;            }        cout &lt;&lt; res &lt;&lt; endl;        }    return 0;}</code></pre><h2 id="Hard-Version"><a href="#Hard-Version" class="headerlink" title="Hard Version"></a>Hard Version</h2><p>$区间[l,r]内, 是a或b倍数的数的和是多少?$<br>$1≤a,b≤10^9$<br>$1≤l≤r≤10^9$</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll gcd(ll a,ll b) { return !b?a:gcd(b,a%b);}ll lcm(ll a,ll b){ return a/gcd(a,b)*b;}int main(){        ll a,b,l,r;        cin &gt;&gt; a &gt;&gt; b;        cin &gt;&gt; l &gt;&gt; r;        ll res = 0;        ll t = lcm(a,b);        ll c1 = r/a,c2 = r/b,c3 = r/t;        ll c4 = (l-1)/a,c5 = (l-1)/b,c6 = (l-1)/t;        res += (a+c1*a)*c1/2+(b+c2*b)*c2/2-(t+c3*t)*c3/2;        res -= (a+c4*a)*c4/2+(b+c5*b)*c5/2-(t+c6*t)*c6/2;        cout &lt;&lt; res &lt;&lt; endl;        return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="组合数学" scheme="https://sinclaircoder.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="暴力" scheme="https://sinclaircoder.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>回溯法求解幂集</title>
    <link href="https://sinclaircoder.top/2019/11/29/2019-11-29-hui-su-fa-qiu-jie-mi-ji/"/>
    <id>https://sinclaircoder.top/2019/11/29/2019-11-29-hui-su-fa-qiu-jie-mi-ji/</id>
    <published>2019-11-28T16:00:00.000Z</published>
    <updated>2020-01-22T04:06:50.303Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回溯—使用解向量"><a href="#回溯—使用解向量" class="headerlink" title="回溯—使用解向量"></a>回溯—使用解向量</h2><p>使用一个大小为n的数组x，来标记解向量，在每次迭代过程重要要么选择当前值，要么不选择</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;void print(int a[], int x[], int n){    cout &lt;&lt; &quot;{&quot;;    for(int i=0;i&lt;n;i++){        if(x[i]) printf(&quot;%d &quot;,a[i]);    }    cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;    cout &lt;&lt; endl;}void dfs(int a[], int x[], int n, int i){    if(i&gt;=n) {        print(a,x,n);return ;    }    else{        x[i] = 0; dfs(a,x,n,i+1);        x[i] = 1; dfs(a,x,n,i+1);    }}int main(){    int n;    cin &gt;&gt; n;    int a[n];    for(int i=0;i&lt;n;i++)        cin &gt;&gt; a[i];    int x[n];    memset(x,0,sizeof(x));    dfs(a,x,n,0);    return 0;}</code></pre><h2 id="回溯法—使用容器存放结果"><a href="#回溯法—使用容器存放结果" class="headerlink" title="回溯法—使用容器存放结果"></a>回溯法—使用容器存放结果</h2><p>不去采用标准的解向量，而是用一个边长数组vector去存放解。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,m,n) for(int i=m;i&lt;n;i++)#define pb push_backint res = 0;void print(vector&lt;int&gt; v){    rep(i,0,v.size()){        cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;    }    cout &lt;&lt; endl;}void dfs(int a[], int n, int i, vector&lt;int&gt; path){    if(i&gt;=n){        print(path);        res++; // 统计个数         return ;    }    else {        dfs(a,n,i+1,path);        path.pb(a[i]);        dfs(a,n,i+1,path);    }}int main(){    int n;    cin &gt;&gt; n;    int a[n];    rep(i,0,n)        cin &gt;&gt; a[i];    vector&lt;int&gt; path;    dfs(a,n,0,path);    cout &lt;&lt; &quot;Total : &quot; &lt;&lt; res &lt;&lt; endl;     return 0;}</code></pre><h2 id="枚举法—使用二进位对应解空间"><a href="#枚举法—使用二进位对应解空间" class="headerlink" title="枚举法—使用二进位对应解空间"></a>枚举法—使用二进位对应解空间</h2><p>用二进制位来对应解</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,m,n) for(int i=m;i&lt;n;i++)#define pb push_backint res = 0;void print(int a[],int n,int x){    int j = 0; // 也可令j变为n,只是会调整输出顺序     cout &lt;&lt; &quot;{&quot;;    while(x){        if(x&amp;1) {            cout &lt;&lt; a[j];            if(x&gt;=2) cout &lt;&lt; &quot; &quot;; // 输出格式控制         }        x &gt;&gt;= 1;j++;    }    cout &lt;&lt; &quot;}&quot;;    cout &lt;&lt; endl;    res++;}int main(){    int n;    cin &gt;&gt; n;    int a[n];    rep(i,0,n)        cin &gt;&gt; a[i];    rep(i,0,1&lt;&lt;n){        print(a,n,i);    }    cout &lt;&lt; &quot;Total：&quot; &lt;&lt; res ; }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据结构与算法训练" scheme="https://sinclaircoder.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="幂集问题" scheme="https://sinclaircoder.top/tags/%E5%B9%82%E9%9B%86%E9%97%AE%E9%A2%98/"/>
    
      <category term="回溯法" scheme="https://sinclaircoder.top/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法求解数独问题(C++ 递归/非递归)</title>
    <link href="https://sinclaircoder.top/2019/11/29/2019-11-29-hui-su-suan-fa-qiu-jie-shu-du-wen-ti-c-di-gui-fei-di-gui/"/>
    <id>https://sinclaircoder.top/2019/11/29/2019-11-29-hui-su-suan-fa-qiu-jie-shu-du-wen-ti-c-di-gui-fei-di-gui/</id>
    <published>2019-11-28T16:00:00.000Z</published>
    <updated>2020-01-22T04:05:23.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img-blog.csdnimg.cn/20191129202756865.png" alt="数独求解"><br>如何使用求解上述数独?</p><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int sudoku[9][9];int dx[9]= {-1,-1,-1,0,0,0,1,1,1},dy[9]={-1,0,1,-1,0,1,-1,0,1};void print(){    for(int i=0;i&lt;9;i++){        for(int j=0;j&lt;9;j++)            cout &lt;&lt; sudoku[i][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    }}bool check(int i,int j, int num){ // (i,j)位置填入num判断是否合适     for(int k=0;k&lt;9;k++){   // 所在行和列判断         if(sudoku[i][k]==num||sudoku[k][j]==num){            return false;        }    }    int cx = i/3*3+1, cy = j/3*3+1;    for(int k=0;k&lt;9;k++){                   // 九宫格         int cur_x = cx+dx[k],cur_y = cy+dy[k];        if(sudoku[cur_x][cur_y]==num)            return false;    }    return true;}void  search(int i,int j){    if(i==8&amp;&amp;j==9) {        print();        return ;    }    if(j==9){        i++;        j=0;    }    if(sudoku[i][j]==0){        for(int num=1;num&lt;=9;num++){            if(check(i,j,num)){                sudoku[i][j] = num;                search(i,j+1);                sudoku[i][j] = 0;            }        }    }    else         search(i,j+1);}int main(){    for(int i=0;i&lt;9;i++)        for(int j=0;j&lt;9;j++)            cin &gt;&gt; sudoku[i][j];        search(0,0);        return 0;}</code></pre><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>非递归回溯求解数独问题，每次在9*9的矩阵中按行优先寻找第一个不为0的位置<br>并将该位置进栈，然后对该位置进行从num=1到9试填，并check该位置放num是否合适，<br>如果不合适就将该点出栈，同时将值置为0，否则就放入num，然后将下一个0位置进栈… </p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt; using namespace std;int sudoku[9][9];int dx[9]= {-1,-1,-1,0,0,0,1,1,1},dy[9]={-1,0,1,-1,0,1,-1,0,1};void print(){    for(int i=0;i&lt;9;i++){        for(int j=0;j&lt;9;j++)            cout &lt;&lt; sudoku[i][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    }}bool check(int i,int j, int num){ // (i,j)位置填入num判断是否合适     for(int k=0;k&lt;9;k++){   // 所在行和列判断         if(sudoku[i][k]==num||sudoku[k][j]==num){            return false;        }    }    int cx = i/3*3+1, cy = j/3*3+1;    for(int k=0;k&lt;9;k++){                   // 九宫格         int cur_x = cx+dx[k],cur_y = cy+dy[k];        if(sudoku[cur_x][cur_y]==num)            return false;    }    return true;}int find(){    for (int i = 0;i&lt;81;i++)        if (!sudoku[i/9][i%9])            return i;    return -1;}bool solve(){   // 非递归回溯     stack&lt;int&gt; st;    st.push(find());    int num;    while(!st.empty()&amp;&amp;(st.top()&gt;=0)){        int x = st.top()/9, y = st.top()%9;        for(num = sudoku[x][y]+1;num&lt;=9&amp;&amp;(!check(x,y,num));num++);        if(num&gt;9){            sudoku[x][y] = 0;            st.pop();            }        else {            sudoku[x][y] = num;            st.push(find());        }        }     return (!st.empty());}int main(){    for(int i=0;i&lt;9;i++)        for(int j=0;j&lt;9;j++)            cin &gt;&gt; sudoku[i][j];    if(solve()){        print();        }    else cout &lt;&lt; &quot;无解&quot; &lt;&lt; endl;     return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据结构与算法训练" scheme="https://sinclaircoder.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="回溯法" scheme="https://sinclaircoder.top/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
      <category term="数独" scheme="https://sinclaircoder.top/tags/%E6%95%B0%E7%8B%AC/"/>
    
  </entry>
  
  <entry>
    <title>切面条</title>
    <link href="https://sinclaircoder.top/2019/11/22/2019-11-22-qie-mian-tiao/"/>
    <id>https://sinclaircoder.top/2019/11/22/2019-11-22-qie-mian-tiao/</id>
    <published>2019-11-21T16:00:00.000Z</published>
    <updated>2020-01-22T03:59:55.874Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道2014蓝桥杯省赛试题<br><strong>切面条</strong><br> 一根高筋拉面，中间切一刀，可以得到2根面条。<br>    如果先对折1次，中间切一刀，可以得到3根面条。<br>    如果连续对折2次，中间切一刀，可以得到5根面条。<br>    那么，连续对折10次，中间切一刀，会得到多少面条呢？  </p><p>不切的话，一根面条原本有两个端点<br>对折0次，中间切一刀，会产生1个端点，一共3个端点，会产生2根面条<br>对折1次，中间切一刀，会产生2个端点，一共4个端点，会产生3根面条<br>对折2次，中间切一刀，会产生4个端点，一共6个端点，会产生5根面条<br>对折3次，中间切一刀，会产生8个端点，一共10个端点，会产生9根面条<br>…<br>…<br>假设对折n次，则中间切一刀，会产生$2^n$个端点，加上原来的两个，一共$2^n+2$个端点，会产生$2^n+2-1$根面条，也即产生的面条数等于端点数减一。<br>即<script type="math/tex">result = 2^n+1</script><br>（证明略..）<br>当n=10时，result = 1025</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>熊怪吃核桃--二进制的使用</title>
    <link href="https://sinclaircoder.top/2019/11/22/2019-11-22-xiong-guai-chi-he-tao-er-jin-zhi-de-shi-yong/"/>
    <id>https://sinclaircoder.top/2019/11/22/2019-11-22-xiong-guai-chi-he-tao-er-jin-zhi-de-shi-yong/</id>
    <published>2019-11-21T16:00:00.000Z</published>
    <updated>2020-01-22T03:59:04.091Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道2015年蓝桥杯省赛试题<br><strong>熊怪吃核桃</strong></p><ul><li>森林里有一只熊怪，很爱吃核桃。</li><li>不过它有个习惯，每次都把找到的核桃分成相等的两份，吃掉一份，留一份。</li><li>如果不能等分，熊怪就会扔掉一个核桃再分。</li><li>第二天再继续这个过程，直到最后剩一个核桃了，直接丢掉。</li><li>有一天，熊怪发现了1543个核桃，请问，它在吃这些核桃的过程中，一共要丢掉多少个核桃。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路就是每次判读一下是奇数还是偶数，奇数的话就减1然后除以2，偶数的话就直接除以2。用C/C++实现写起来其实很简单，其实还有一种更妙的思路，这个过程其实就是一个除2的过程，也就类似于十进制转二进制的过程，所以直接在Windows下利用计算器输入1543转成二进制，然后数一数二进制里面有几个1即可。</p><ul><li>1543对应的二进制是110 0000 0111，里面有5个1。</li></ul><p>顺便放一个代码实现吧</p><pre><code class="lang-cpp">#include&lt;iostream&gt;using namespace std;int main(){    int n = 1543,cnt = 0;    while(n){        if(n&amp;1){            n--;cnt++;            n /= 2;        }        else n /= 2;    }    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="位运算" scheme="https://sinclaircoder.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>黄金连分数--BigDecimal的使用</title>
    <link href="https://sinclaircoder.top/2019/11/22/2019-11-22-huang-jin-lian-fen-shu-bigdecimal-de-shi-yong/"/>
    <id>https://sinclaircoder.top/2019/11/22/2019-11-22-huang-jin-lian-fen-shu-bigdecimal-de-shi-yong/</id>
    <published>2019-11-21T16:00:00.000Z</published>
    <updated>2020-01-22T08:03:14.335Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道2013蓝桥杯省赛试题</p><p><strong>黄金连分数</strong></p><ul><li>黄金分割数是0.61803是一个无理数，…</li><li>写出精确到小数点后100位精度的黄金分割数</li></ul><script type="math/tex; mode=display">\frac{1}{1+\frac{1}{1+\frac{1}{1+\frac{1}{1+\frac{1}{1+\frac{1}{1+}}}}}}</script><p>当然黄金分割数是$\frac{\sqrt5-1}{2}$,可以直接算，但是Windows下的计算器的求解只能到小数点之后32位</p><p><img src="https://img-blog.csdnimg.cn/20191122163245826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NpbmNsYWlyV2FuZw==,size_16,color_FFFFFF,t_70" alt="windows下计算器计算结果"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当然这是一道填空题，只需要结果，假如你懂一点点java，又刚好知道BigDecimal这个类，那你就可以打开桌面的Eclipse轻松求解这个题目。</p><pre><code class="lang-java">import java.math.BigDecimal;import java.math.BigInteger;import java.util.Scanner;public class BigDecimalLearning {    public static void main(String[] args) {        BigDecimal res = new BigDecimal(1); // 没有 new BigDecimal(BigDecimal.ONE); 这种构造方法        for(int i=0;i&lt;100;i++) {            res = res.add(BigDecimal.ONE);            res = BigDecimal.ONE.divide(res,105,BigDecimal.ROUND_HALF_UP);        }        String str = res.toString().substring(2, 102);        System.out.println(str);//        System.out.println(str.length());    }}</code></pre><p>结果：</p><pre><code class="lang-java">6180339887498948482045868343656381177203096998094118264936291294152016354093729191617385189497190563</code></pre><p><br></p><h2 id="简单介绍一下BigDecimal"><a href="#简单介绍一下BigDecimal" class="headerlink" title="简单介绍一下BigDecimal"></a>简单介绍一下BigDecimal</h2><p>Java在java.math包中提供了BigDecimal类，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。<br>常用方法如下：</p><pre><code class="lang-java">BigDecimal b1 = new BigDecimal(&quot;20&quot;);BigDecimal b2 = new BigDecimal(&quot;30&quot;);b1.add(b2)          //加法，求两个BigDecimal类型数据的和。b1.subtract(b2);     //减法，求两个BigDecimal类型数据的差。b1.multiply(b2);     //乘法，求两个BigDecimal类型数据的积。b1.remainder(b2);    //求余数，求b1除以b2的余数。b1.max(b2);        //最大数，求两个BigDecimal类型数据的最大值b1.min(b2);       //最小数，求两个BigDecimal类型数据的最小值。bi.abs();      //绝对值，求BigDecimal类型数据的绝对值。b1.negate();    //相反数，求BigDecimal类型数据的相反数。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
      <category term="BigDecimal" scheme="https://sinclaircoder.top/tags/BigDecimal/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯集训笔记</title>
    <link href="https://sinclaircoder.top/2019/11/22/2019-11-22-lan-qiao-bei-ji-xun-bi-ji/"/>
    <id>https://sinclaircoder.top/2019/11/22/2019-11-22-lan-qiao-bei-ji-xun-bi-ji/</id>
    <published>2019-11-21T16:00:00.000Z</published>
    <updated>2020-01-22T04:02:15.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数学建模的思想"><a href="#数学建模的思想" class="headerlink" title="数学建模的思想"></a>数学建模的思想</h2><p>几道题目</p><ul><li><a href="https://blog.csdn.net/SinclairWang/article/details/103203318" target="_blank" rel="noopener">熊怪吃核桃—二进制的使用</a></li><li><a href="https://blog.csdn.net/SinclairWang/article/details/103204198" target="_blank" rel="noopener">切面条</a><h3 id="余数的使用"><a href="#余数的使用" class="headerlink" title="余数的使用"></a>余数的使用</h3>余数运算对于加法、减法和乘法封闭，常用于循环队列等使用，也可以利用余数的性质大幅度简化编码<br>常用场合：递推法，倒推法<br>有很多经典的题目，比如猴子吃桃..<br>猜字母（待补..）</li></ul><h3 id="统计某种运算的结果末尾0的个数"><a href="#统计某种运算的结果末尾0的个数" class="headerlink" title="统计某种运算的结果末尾0的个数"></a>统计某种运算的结果末尾0的个数</h3><p>统计因子中能被2和5整除的个数分别为n1,n2</p><script type="math/tex; mode=display">result = min(n1,n2)</script><h3 id="毕达哥拉斯定理（勾股定理）"><a href="#毕达哥拉斯定理（勾股定理）" class="headerlink" title="毕达哥拉斯定理（勾股定理）"></a>毕达哥拉斯定理（勾股定理）</h3><p>可以直接利用$x^2+y^2=z^2$在正整数域构造基础解系</p><script type="math/tex; mode=display">\begin{cases}x=2k+1\\y=2k^2+2k\\ z = 2k^2+2k+1 \\ k = 1,2,3,... \end{cases}</script><p>另一种解系：</p><script type="math/tex; mode=display">\begin{cases}x=st\\y=\frac{t^2-s^2}{2}\\ z =\frac{t^2+s^2}{2} \\ s =1,3,5,7.. \\ gcd(t,s)=1 \end{cases}</script><h2 id="超长位数的处理"><a href="#超长位数的处理" class="headerlink" title="超长位数的处理"></a>超长位数的处理</h2><ul><li>存储方式：字符串、整数数组（甚至采用整型数组紧缩存放，即数组中一个元素存放多位，输出的时候使用printf(“%nd”,x[i]);</li><li>存储格式：把低位放在前，高位放在后面，符号位和小数位单独处理，可使用标志变量</li><li><p>运算方式</p><ul><li>C/C++使用数组模拟进行加减乘除，及时取余进位操作，小心溢出</li><li>java 中里面提供了两个类BigInteger，BigDecimal分别对应大整数、高精度小数的处理 。</li><li><strong>tips：尽管是C/C++选手，假如遇到了大数运算的题目，又刚好是个填空题，不妨简单学下Java里面的这个两个类，甚至Date类（日期计算），求结果多快好省，何乐而不为？</strong></li></ul></li></ul><p>两个往年题目练习一下BigInteger，BigDecimal的使用</p><ul><li><a href="https://blog.csdn.net/SinclairWang/article/details/103191468" target="_blank" rel="noopener">大数乘法 java BigInteger的使用</a></li><li><a href="https://blog.csdn.net/SinclairWang/article/details/103202851" target="_blank" rel="noopener">黄金连分数—BigDecimal的使用</a></li></ul><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>对应2019省赛A组题目RSA解密<br>涉及的知识点如下</p><ul><li>逆元</li><li>欧拉函数</li><li>快速幂</li><li>素数筛</li><li>扩展欧几里得算法</li></ul><p>（待补..）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="蓝桥杯" scheme="https://sinclaircoder.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
</feed>
